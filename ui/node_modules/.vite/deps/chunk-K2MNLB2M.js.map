{
  "version": 3,
  "sources": ["../../viem/account-abstraction/clients/createBundlerClient.ts", "../../viem/account-abstraction/clients/decorators/bundler.ts", "../../viem/account-abstraction/actions/bundler/estimateUserOperationGas.ts", "../../viem/account-abstraction/utils/errors/getUserOperationError.ts", "../../viem/account-abstraction/errors/bundler.ts", "../../viem/account-abstraction/errors/userOperation.ts", "../../viem/account-abstraction/utils/errors/getBundlerError.ts", "../../viem/account-abstraction/utils/formatters/userOperationGas.ts", "../../viem/account-abstraction/utils/formatters/userOperationRequest.ts", "../../viem/account-abstraction/actions/bundler/prepareUserOperation.ts", "../../viem/account-abstraction/actions/paymaster/getPaymasterData.ts", "../../viem/account-abstraction/actions/paymaster/getPaymasterStubData.ts", "../../viem/account-abstraction/actions/bundler/getSupportedEntryPoints.ts", "../../viem/account-abstraction/actions/bundler/getUserOperation.ts", "../../viem/account-abstraction/utils/formatters/userOperation.ts", "../../viem/account-abstraction/actions/bundler/getUserOperationReceipt.ts", "../../viem/account-abstraction/utils/formatters/userOperationReceipt.ts", "../../viem/account-abstraction/actions/bundler/sendUserOperation.ts", "../../viem/account-abstraction/actions/bundler/waitForUserOperationReceipt.ts", "../../viem/account-abstraction/index.ts", "../../viem/account-abstraction/accounts/createWebAuthnCredential.ts", "../../viem/account-abstraction/accounts/implementations/toCoinbaseSmartAccount.ts", "../../viem/account-abstraction/constants/abis.ts", "../../viem/account-abstraction/utils/userOperation/getUserOperationHash.ts", "../../viem/account-abstraction/utils/userOperation/getInitCode.ts", "../../viem/account-abstraction/utils/userOperation/getUserOperationTypedData.ts", "../../viem/account-abstraction/utils/userOperation/toPackedUserOperation.ts", "../../viem/account-abstraction/accounts/toSmartAccount.ts", "../../viem/account-abstraction/accounts/implementations/toSimple7702SmartAccount.ts", "../../viem/account-abstraction/accounts/implementations/toSoladySmartAccount.ts", "../../viem/experimental/erc7739/actions/signMessage.ts", "../../viem/experimental/erc7739/actions/signTypedData.ts", "../../viem/experimental/erc7739/utils/wrapTypedDataSignature.ts", "../../viem/account-abstraction/accounts/toWebAuthnAccount.ts", "../../viem/account-abstraction/clients/createPaymasterClient.ts", "../../viem/account-abstraction/clients/decorators/paymaster.ts", "../../viem/account-abstraction/constants/address.ts", "../../viem/account-abstraction/utils/userOperation/toUserOperation.ts", "../../ox/erc4337/index.ts", "../../ox/erc4337/EntryPoint.ts", "../../ox/_esm/erc4337/RpcSchema.js", "../../ox/erc4337/UserOperation.ts", "../../ox/erc4337/UserOperationGas.ts", "../../ox/erc4337/UserOperationReceipt.ts", "../../viem/experimental/index.ts", "../../viem/experimental/eip5792/actions/writeContracts.ts", "../../viem/experimental/eip5792/decorators/eip5792.ts", "../../viem/experimental/erc7715/actions/grantPermissions.ts", "../../viem/experimental/erc7715/decorators/erc7715.ts", "../../viem/experimental/erc7739/decorators/erc7739.ts", "../../viem/experimental/erc7811/decorators/erc7811.ts", "../../viem/experimental/erc7811/actions/getAssets.ts", "../../viem/experimental/erc7846/decorators/erc7846.ts", "../../viem/experimental/erc7846/actions/connect.ts", "../../viem/experimental/erc7846/actions/disconnect.ts", "../../viem/experimental/erc7895/decorators/erc7895.ts", "../../viem/experimental/erc7895/actions/addSubAccount.ts"],
  "sourcesContent": ["import type { EstimateFeesPerGasReturnType } from '../../actions/public/estimateFeesPerGas.js'\nimport {\n  type Client,\n  type ClientConfig,\n  type CreateClientErrorType,\n  createClient,\n} from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { BundlerRpcSchema, RpcSchema } from '../../types/eip1193.js'\nimport type { Prettify } from '../../types/utils.js'\nimport type { SmartAccount } from '../accounts/types.js'\nimport type { UserOperationRequest } from '../types/userOperation.js'\nimport { type BundlerActions, bundlerActions } from './decorators/bundler.js'\nimport type { PaymasterActions } from './decorators/paymaster.js'\n\nexport type BundlerClientConfig<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n  client extends Client | undefined = Client | undefined,\n  rpcSchema extends RpcSchema | undefined = undefined,\n> = Prettify<\n  Pick<\n    ClientConfig<transport, chain, account, rpcSchema>,\n    | 'account'\n    | 'cacheTime'\n    | 'chain'\n    | 'key'\n    | 'name'\n    | 'pollingInterval'\n    | 'rpcSchema'\n    | 'transport'\n  >\n> & {\n  /** Client that points to an Execution RPC URL. */\n  client?: client | Client | undefined\n  /** Paymaster configuration. */\n  paymaster?:\n    | true\n    | {\n        /** Retrieves paymaster-related User Operation properties to be used for sending the User Operation. */\n        getPaymasterData?: PaymasterActions['getPaymasterData'] | undefined\n        /** Retrieves paymaster-related User Operation properties to be used for gas estimation. */\n        getPaymasterStubData?:\n          | PaymasterActions['getPaymasterStubData']\n          | undefined\n      }\n    | undefined\n  /** Paymaster context to pass to `getPaymasterData` and `getPaymasterStubData` calls. */\n  paymasterContext?: unknown\n  /** User Operation configuration. */\n  userOperation?:\n    | {\n        /** Prepares fee properties for the User Operation request. */\n        estimateFeesPerGas?:\n          | ((parameters: {\n              account: account | SmartAccount\n              bundlerClient: Client\n              userOperation: UserOperationRequest\n            }) => Promise<EstimateFeesPerGasReturnType<'eip1559'>>)\n          | undefined\n      }\n    | undefined\n}\n\nexport type BundlerClient<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n  client extends Client | undefined = Client | undefined,\n  rpcSchema extends RpcSchema | undefined = undefined,\n> = Prettify<\n  Client<\n    transport,\n    chain extends Chain\n      ? chain\n      : client extends Client<any, infer chain>\n        ? chain\n        : undefined,\n    account,\n    rpcSchema extends RpcSchema\n      ? [...BundlerRpcSchema, ...rpcSchema]\n      : BundlerRpcSchema,\n    BundlerActions<account>\n  >\n> & {\n  client: client\n  paymaster: BundlerClientConfig['paymaster'] | undefined\n  paymasterContext: BundlerClientConfig['paymasterContext'] | undefined\n  userOperation: BundlerClientConfig['userOperation'] | undefined\n}\n\nexport type CreateBundlerClientErrorType = CreateClientErrorType | ErrorType\n\n/**\n * Creates a Bundler Client with a given [Transport](https://viem.sh/docs/clients/intro) configured for a [Chain](https://viem.sh/docs/clients/chains).\n *\n * - Docs: https://viem.sh/account-abstraction/clients/bundler\n *\n * @param config - {@link BundlerClientConfig}\n * @returns A Bundler Client. {@link BundlerClient}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { createBundlerClient } from 'viem/account-abstraction'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const bundlerClient = createBundlerClient({\n *   client,\n *   transport: http('https://public.pimlico.io/v2/1/rpc'),\n * })\n */\nexport function createBundlerClient<\n  transport extends Transport,\n  chain extends Chain | undefined = undefined,\n  account extends SmartAccount | undefined = undefined,\n  client extends Client | undefined = undefined,\n  rpcSchema extends RpcSchema | undefined = undefined,\n>(\n  parameters: BundlerClientConfig<transport, chain, account, client, rpcSchema>,\n): BundlerClient<transport, chain, account, client, rpcSchema>\n\nexport function createBundlerClient(\n  parameters: BundlerClientConfig,\n): BundlerClient {\n  const {\n    client: client_,\n    key = 'bundler',\n    name = 'Bundler Client',\n    paymaster,\n    paymasterContext,\n    transport,\n    userOperation,\n  } = parameters\n  const client = Object.assign(\n    createClient({\n      ...parameters,\n      chain: parameters.chain ?? client_?.chain,\n      key,\n      name,\n      transport,\n      type: 'bundlerClient',\n    }),\n    { client: client_, paymaster, paymasterContext, userOperation },\n  )\n  return client.extend(bundlerActions) as any\n}\n", "import {\n  type GetChainIdReturnType,\n  getChainId,\n} from '../../../actions/public/getChainId.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type { SmartAccount } from '../../accounts/types.js'\nimport {\n  type EstimateUserOperationGasParameters,\n  type EstimateUserOperationGasReturnType,\n  estimateUserOperationGas,\n} from '../../actions/bundler/estimateUserOperationGas.js'\nimport {\n  type GetSupportedEntryPointsReturnType,\n  getSupportedEntryPoints,\n} from '../../actions/bundler/getSupportedEntryPoints.js'\nimport {\n  type GetUserOperationParameters,\n  type GetUserOperationReturnType,\n  getUserOperation,\n} from '../../actions/bundler/getUserOperation.js'\nimport {\n  type GetUserOperationReceiptParameters,\n  type GetUserOperationReceiptReturnType,\n  getUserOperationReceipt,\n} from '../../actions/bundler/getUserOperationReceipt.js'\nimport {\n  type PrepareUserOperationParameters,\n  type PrepareUserOperationRequest,\n  type PrepareUserOperationReturnType,\n  prepareUserOperation,\n} from '../../actions/bundler/prepareUserOperation.js'\nimport {\n  type SendUserOperationParameters,\n  type SendUserOperationReturnType,\n  sendUserOperation,\n} from '../../actions/bundler/sendUserOperation.js'\nimport {\n  type WaitForUserOperationReceiptParameters,\n  type WaitForUserOperationReceiptReturnType,\n  waitForUserOperationReceipt,\n} from '../../actions/bundler/waitForUserOperationReceipt.js'\n\nexport type BundlerActions<\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n> = {\n  /**\n   * Returns an estimate of gas values necessary to execute the User Operation.\n   *\n   * - Docs: https://viem.sh/actions/bundler/estimateUserOperationGas\n   *\n   * @param client - Client to use\n   * @param parameters - {@link EstimateUserOperationGasParameters}\n   * @returns The gas estimate (in wei). {@link EstimateUserOperationGasReturnType}\n   *\n   * @example\n   * import { createBundlerClient, http, parseEther } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { toSmartAccount } from 'viem/accounts'\n   *\n   * const account = await toSmartAccount({ ... })\n   *\n   * const bundlerClient = createBundlerClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   *\n   * const values = await bundlerClient.estimateUserOperationGas({\n   *   account,\n   *   calls: [{ to: '0x...', value: parseEther('1') }],\n   * })\n   */\n  estimateUserOperationGas: <\n    const calls extends readonly unknown[],\n    accountOverride extends SmartAccount | undefined = undefined,\n  >(\n    parameters: EstimateUserOperationGasParameters<\n      account,\n      accountOverride,\n      calls\n    >,\n  ) => Promise<EstimateUserOperationGasReturnType<account, accountOverride>>\n  /**\n   * Returns the chain ID associated with the bundler.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/getChainId\n   * - JSON-RPC Methods: [`eth_chainId`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_chainid)\n   *\n   * @returns The current chain ID. {@link GetChainIdReturnType}\n   *\n   * @example\n   * import { http } from 'viem'\n   * import { createBundlerClient, mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const chainId = await client.getChainId()\n   * // 1\n   */\n  getChainId: () => Promise<GetChainIdReturnType>\n  /**\n   * Returns the EntryPoints that the bundler supports.\n   *\n   * - Docs: https://viem.sh/actions/bundler/getSupportedEntryPoints\n   *\n   * @param client - Client to use\n   * @param parameters - {@link GetSupportedEntryPointsParameters}\n   * @returns Supported Entry Points. {@link GetSupportedEntryPointsReturnType}\n   *\n   * @example\n   * import { createBundlerClient, http, parseEther } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const bundlerClient = createBundlerClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   *\n   * const addresses = await bundlerClient.getSupportedEntryPoints()\n   */\n  getSupportedEntryPoints: () => Promise<GetSupportedEntryPointsReturnType>\n  /**\n   * Returns the information about a User Operation given a hash.\n   *\n   * - Docs: https://viem.sh/docs/actions/bundler/getUserOperation\n   *\n   * @param client - Client to use\n   * @param parameters - {@link GetUserOperationParameters}\n   * @returns The receipt. {@link GetUserOperationReturnType}\n   *\n   * @example\n   * import { createBundlerClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createBundlerClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   *\n   * const receipt = await client.getUserOperation({\n   *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n   * })\n   */\n  getUserOperation: (\n    parameters: GetUserOperationParameters,\n  ) => Promise<GetUserOperationReturnType>\n  /**\n   * Returns the User Operation Receipt given a User Operation hash.\n   *\n   * - Docs: https://viem.sh/docs/actions/bundler/getUserOperationReceipt\n   *\n   * @param client - Client to use\n   * @param parameters - {@link GetUserOperationReceiptParameters}\n   * @returns The receipt. {@link GetUserOperationReceiptReturnType}\n   *\n   * @example\n   * import { createBundlerClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createBundlerClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   *\n   * const receipt = await client.getUserOperationReceipt({\n   *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n   * })\n   */\n  getUserOperationReceipt: (\n    parameters: GetUserOperationReceiptParameters,\n  ) => Promise<GetUserOperationReceiptReturnType>\n  /**\n   * Prepares a User Operation and fills in missing properties.\n   *\n   * - Docs: https://viem.sh/actions/bundler/prepareUserOperation\n   *\n   * @param args - {@link PrepareUserOperationParameters}\n   * @returns The User Operation. {@link PrepareUserOperationReturnType}\n   *\n   * @example\n   * import { createBundlerClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { toSmartAccount } from 'viem/accounts'\n   *\n   * const account = await toSmartAccount({ ... })\n   *\n   * const client = createBundlerClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   *\n   * const request = await client.prepareUserOperation({\n   *   account,\n   *   calls: [{ to: '0x...', value: parseEther('1') }],\n   * })\n   */\n  prepareUserOperation: <\n    const calls extends readonly unknown[],\n    const request extends PrepareUserOperationRequest<\n      account,\n      accountOverride,\n      calls\n    >,\n    accountOverride extends SmartAccount | undefined = undefined,\n  >(\n    parameters: PrepareUserOperationParameters<\n      account,\n      accountOverride,\n      calls,\n      request\n    >,\n  ) => Promise<\n    PrepareUserOperationReturnType<account, accountOverride, calls, request>\n  >\n  /**\n   * Broadcasts a User Operation to the Bundler.\n   *\n   * - Docs: https://viem.sh/actions/bundler/sendUserOperation\n   *\n   * @param client - Client to use\n   * @param parameters - {@link SendUserOperationParameters}\n   * @returns The User Operation hash. {@link SendUserOperationReturnType}\n   *\n   * @example\n   * import { createBundlerClient, http, parseEther } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { toSmartAccount } from 'viem/accounts'\n   *\n   * const account = toSmartAccount({ ... })\n   *\n   * const bundlerClient = createBundlerClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   *\n   * const values = await bundlerClient.sendUserOperation({\n   *   account,\n   *   calls: [{ to: '0x...', value: parseEther('1') }],\n   * })\n   */\n  sendUserOperation: <\n    const calls extends readonly unknown[],\n    accountOverride extends SmartAccount | undefined = undefined,\n  >(\n    parameters: SendUserOperationParameters<account, accountOverride, calls>,\n  ) => Promise<SendUserOperationReturnType>\n  /**\n   * Waits for the User Operation to be included on a [Block](https://viem.sh/docs/glossary/terms#block) (one confirmation), and then returns the User Operation receipt.\n   *\n   * - Docs: https://viem.sh/docs/actions/bundler/waitForUserOperationReceipt\n   *\n   * @param client - Client to use\n   * @param parameters - {@link WaitForUserOperationReceiptParameters}\n   * @returns The receipt. {@link WaitForUserOperationReceiptReturnType}\n   *\n   * @example\n   * import { createBundlerClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createBundlerClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   *\n   * const receipt = await client.waitForUserOperationReceipt({\n   *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n   * })\n   */\n  waitForUserOperationReceipt: (\n    parameters: WaitForUserOperationReceiptParameters,\n  ) => Promise<WaitForUserOperationReceiptReturnType>\n}\n\nexport function bundlerActions<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n>(client: Client<transport, chain, account>): BundlerActions<account> {\n  return {\n    estimateUserOperationGas: (parameters) =>\n      estimateUserOperationGas(client, parameters),\n    getChainId: () => getChainId(client),\n    getSupportedEntryPoints: () => getSupportedEntryPoints(client),\n    getUserOperation: (parameters) => getUserOperation(client, parameters),\n    getUserOperationReceipt: (parameters) =>\n      getUserOperationReceipt(client, parameters),\n    prepareUserOperation: (parameters) =>\n      prepareUserOperation(client, parameters),\n    sendUserOperation: (parameters) => sendUserOperation(client, parameters),\n    waitForUserOperationReceipt: (parameters) =>\n      waitForUserOperationReceipt(client, parameters),\n  }\n}\n", "import type { Address, Narrow } from 'abitype'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport { AccountNotFoundError } from '../../../errors/account.js'\nimport type { BaseError } from '../../../errors/base.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Calls } from '../../../types/calls.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type { Hex } from '../../../types/misc.js'\nimport type { StateOverride } from '../../../types/stateOverride.js'\nimport type {\n  Assign,\n  MaybeRequired,\n  OneOf,\n  Prettify,\n} from '../../../types/utils.js'\nimport type { RequestErrorType } from '../../../utils/buildRequest.js'\nimport { getAction } from '../../../utils/getAction.js'\nimport { serializeStateOverride } from '../../../utils/stateOverride.js'\nimport type { SmartAccount } from '../../accounts/types.js'\nimport type { PaymasterActions } from '../../clients/decorators/paymaster.js'\nimport type {\n  DeriveSmartAccount,\n  GetSmartAccountParameter,\n} from '../../types/account.js'\nimport type {\n  DeriveEntryPointVersion,\n  EntryPointVersion,\n} from '../../types/entryPointVersion.js'\nimport type {\n  EstimateUserOperationGasReturnType as EstimateUserOperationGasReturnType_,\n  UserOperation,\n  UserOperationRequest,\n} from '../../types/userOperation.js'\nimport { getUserOperationError } from '../../utils/errors/getUserOperationError.js'\nimport {\n  type FormatUserOperationGasErrorType,\n  formatUserOperationGas,\n} from '../../utils/formatters/userOperationGas.js'\nimport {\n  type FormatUserOperationRequestErrorType,\n  formatUserOperationRequest,\n} from '../../utils/formatters/userOperationRequest.js'\nimport {\n  type PrepareUserOperationErrorType,\n  type PrepareUserOperationParameters,\n  prepareUserOperation,\n} from './prepareUserOperation.js'\n\nexport type EstimateUserOperationGasParameters<\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = SmartAccount | undefined,\n  calls extends readonly unknown[] = readonly unknown[],\n  //\n  _derivedAccount extends SmartAccount | undefined = DeriveSmartAccount<\n    account,\n    accountOverride\n  >,\n  _derivedVersion extends\n    EntryPointVersion = DeriveEntryPointVersion<_derivedAccount>,\n> = GetSmartAccountParameter<account, accountOverride, false> &\n  (\n    | UserOperation // Accept a full-formed User Operation.\n    | Assign<\n        // Accept a partially-formed User Operation (UserOperationRequest) to be filled.\n        UserOperationRequest<_derivedVersion>,\n        OneOf<{ calls: Calls<Narrow<calls>> } | { callData: Hex }> & {\n          paymaster?:\n            | Address\n            | true\n            | {\n                /** Retrieves paymaster-related User Operation properties to be used for sending the User Operation. */\n                getPaymasterData?:\n                  | PaymasterActions['getPaymasterData']\n                  | undefined\n                /** Retrieves paymaster-related User Operation properties to be used for gas estimation. */\n                getPaymasterStubData?:\n                  | PaymasterActions['getPaymasterStubData']\n                  | undefined\n              }\n            | undefined\n          /** Paymaster context to pass to `getPaymasterData` and `getPaymasterStubData` calls. */\n          paymasterContext?: unknown | undefined\n        }\n      >\n  ) &\n  // Allow the EntryPoint address to be overridden, if no Account is provided, it will need to be required.\n  MaybeRequired<\n    { entryPointAddress?: Address },\n    _derivedAccount extends undefined ? true : false\n  > & {\n    /** State overrides for the User Operation call. */\n    stateOverride?: StateOverride | undefined\n  }\n\nexport type EstimateUserOperationGasReturnType<\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = SmartAccount | undefined,\n  //\n  _derivedAccount extends SmartAccount | undefined = DeriveSmartAccount<\n    account,\n    accountOverride\n  >,\n  _derivedVersion extends\n    EntryPointVersion = DeriveEntryPointVersion<_derivedAccount>,\n> = Prettify<EstimateUserOperationGasReturnType_<_derivedVersion>>\n\nexport type EstimateUserOperationGasErrorType =\n  | ParseAccountErrorType\n  | PrepareUserOperationErrorType\n  | FormatUserOperationRequestErrorType\n  | FormatUserOperationGasErrorType\n  | RequestErrorType\n  | ErrorType\n\n/**\n * Returns an estimate of gas values necessary to execute the User Operation.\n *\n * - Docs: https://viem.sh/actions/bundler/estimateUserOperationGas\n *\n * @param client - Client to use\n * @param parameters - {@link EstimateUserOperationGasParameters}\n * @returns The gas estimate (in wei). {@link EstimateUserOperationGasReturnType}\n *\n * @example\n * import { createBundlerClient, http, parseEther } from 'viem'\n * import { toSmartAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { estimateUserOperationGas } from 'viem/actions'\n *\n * const account = await toSmartAccount({ ... })\n *\n * const bundlerClient = createBundlerClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const values = await estimateUserOperationGas(bundlerClient, {\n *   account,\n *   calls: [{ to: '0x...', value: parseEther('1') }],\n * })\n */\nexport async function estimateUserOperationGas<\n  const calls extends readonly unknown[],\n  account extends SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = undefined,\n>(\n  client: Client<Transport, Chain | undefined, account>,\n  parameters: EstimateUserOperationGasParameters<\n    account,\n    accountOverride,\n    calls\n  >,\n): Promise<EstimateUserOperationGasReturnType<account, accountOverride>> {\n  const {\n    account: account_ = client.account,\n    entryPointAddress,\n    stateOverride,\n  } = parameters\n\n  if (!account_ && !parameters.sender) throw new AccountNotFoundError()\n  const account = account_ ? parseAccount(account_) : undefined\n\n  const rpcStateOverride = serializeStateOverride(stateOverride)\n\n  const request = account\n    ? await getAction(\n        client,\n        prepareUserOperation,\n        'prepareUserOperation',\n      )({\n        ...parameters,\n        parameters: [\n          'authorization',\n          'factory',\n          'nonce',\n          'paymaster',\n          'signature',\n        ],\n      } as unknown as PrepareUserOperationParameters)\n    : parameters\n\n  try {\n    const params = [\n      formatUserOperationRequest(request as UserOperation),\n      (entryPointAddress ?? account?.entryPoint?.address)!,\n    ] as const\n\n    const result = await client.request({\n      method: 'eth_estimateUserOperationGas',\n      params: rpcStateOverride ? [...params, rpcStateOverride] : [...params],\n    })\n    return formatUserOperationGas(result) as EstimateUserOperationGasReturnType<\n      account,\n      accountOverride\n    >\n  } catch (error) {\n    const calls = (parameters as any).calls\n    throw getUserOperationError(error as BaseError, {\n      ...(request as UserOperation),\n      ...(calls ? { calls } : {}),\n    })\n  }\n}\n", "import type { Abi, Address } from 'abitype'\nimport { BaseError } from '../../../errors/base.js'\nimport {\n  ContractFunctionExecutionError,\n  ContractFunctionRevertedError,\n  ContractFunctionZeroDataError,\n} from '../../../errors/contract.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Call } from '../../../types/calls.js'\nimport type { Hex } from '../../../types/misc.js'\nimport { decodeErrorResult } from '../../../utils/abi/decodeErrorResult.js'\nimport type { GetContractErrorReturnType } from '../../../utils/errors/getContractError.js'\nimport { ExecutionRevertedError } from '../../errors/bundler.js'\nimport {\n  UserOperationExecutionError,\n  type UserOperationExecutionErrorType,\n} from '../../errors/userOperation.js'\nimport type { UserOperation } from '../../types/userOperation.js'\nimport {\n  type GetBundlerErrorParameters,\n  getBundlerError,\n} from './getBundlerError.js'\n\ntype GetNodeErrorReturnType = ErrorType\n\nexport type GetUserOperationErrorParameters = UserOperation & {\n  calls?: readonly unknown[] | undefined\n  docsPath?: string | undefined\n}\n\nexport type GetUserOperationErrorReturnType<cause = ErrorType> = Omit<\n  UserOperationExecutionErrorType,\n  'cause'\n> & { cause: cause | GetNodeErrorReturnType }\n\nexport type GetUserOperationErrorErrorType = ErrorType\n\nexport function getUserOperationError<err extends ErrorType<string>>(\n  err: err,\n  { calls, docsPath, ...args }: GetUserOperationErrorParameters,\n): GetUserOperationErrorReturnType<err> {\n  const cause = (() => {\n    const cause = getBundlerError(\n      err as {} as BaseError,\n      args as GetBundlerErrorParameters,\n    )\n    if (calls && cause instanceof ExecutionRevertedError) {\n      const revertData = getRevertData(cause)\n      const contractCalls = calls?.filter(\n        (call: any) => call.abi,\n      ) as readonly Call[]\n      if (revertData && contractCalls.length > 0)\n        return getContractError({ calls: contractCalls, revertData })\n    }\n    return cause\n  })()\n  return new UserOperationExecutionError(cause, {\n    docsPath,\n    ...args,\n  }) as GetUserOperationErrorReturnType<err>\n}\n\n/////////////////////////////////////////////////////////////////////////////////\n\nfunction getRevertData(error: BaseError) {\n  let revertData: Hex | undefined\n  error.walk((e) => {\n    const error = e as any\n    if (\n      typeof error.data === 'string' ||\n      typeof error.data?.revertData === 'string' ||\n      (!(error instanceof BaseError) && typeof error.message === 'string')\n    ) {\n      const match = (\n        error.data?.revertData ||\n        error.data ||\n        error.message\n      ).match?.(/(0x[A-Za-z0-9]*)/)\n      if (match) {\n        revertData = match[1]\n        return true\n      }\n    }\n    return false\n  })\n  return revertData\n}\n\nfunction getContractError(parameters: {\n  calls: readonly Call[]\n  revertData: Hex\n}) {\n  const { calls, revertData } = parameters\n\n  const { abi, functionName, args, to } = (() => {\n    const contractCalls = calls?.filter((call) =>\n      Boolean(call.abi),\n    ) as readonly Call[]\n\n    if (contractCalls.length === 1) return contractCalls[0]\n\n    const compatContractCalls = contractCalls.filter((call) => {\n      try {\n        return Boolean(\n          decodeErrorResult({\n            abi: call.abi,\n            data: revertData,\n          }),\n        )\n      } catch {\n        return false\n      }\n    })\n    if (compatContractCalls.length === 1) return compatContractCalls[0]\n\n    return {\n      abi: [],\n      functionName: contractCalls.reduce(\n        (acc, call) => `${acc ? `${acc} | ` : ''}${call.functionName}`,\n        '',\n      ),\n      args: undefined,\n      to: undefined,\n    }\n  })() as {\n    abi: Abi\n    functionName: string\n    args: unknown[]\n    to: Address\n  }\n\n  const cause = (() => {\n    if (revertData === '0x')\n      return new ContractFunctionZeroDataError({ functionName })\n    return new ContractFunctionRevertedError({\n      abi,\n      data: revertData,\n      functionName,\n    })\n  })()\n  return new ContractFunctionExecutionError(cause as BaseError, {\n    abi,\n    args,\n    contractAddress: to,\n    functionName,\n  }) as GetContractErrorReturnType\n}\n", "import type { Address } from 'abitype'\nimport { BaseError } from '../../errors/base.js'\nimport type { Hex } from '../../types/misc.js'\n\nexport type AccountNotDeployedErrorType = AccountNotDeployedError & {\n  name: 'AccountNotDeployedError'\n}\nexport class AccountNotDeployedError extends BaseError {\n  static message = /aa20/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Smart Account is not deployed.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- No `factory`/`factoryData` or `initCode` properties are provided for Smart Account deployment.',\n        '- An incorrect `sender` address is provided.',\n      ],\n      name: 'AccountNotDeployedError',\n    })\n  }\n}\n\nexport type ExecutionRevertedErrorType = ExecutionRevertedError & {\n  code: -32521\n  name: 'ExecutionRevertedError'\n}\nexport class ExecutionRevertedError extends BaseError {\n  static code = -32521\n  static message = /execution reverted/\n\n  data?: { revertData?: Hex } | undefined\n\n  constructor({\n    cause,\n    data,\n    message,\n  }: {\n    cause?: BaseError | undefined\n    data?: { revertData?: Hex } | undefined\n    message?: string | undefined\n  } = {}) {\n    const reason = message\n      ?.replace('execution reverted: ', '')\n      ?.replace('execution reverted', '')\n    super(\n      `Execution reverted ${\n        reason ? `with reason: ${reason}` : 'for an unknown reason'\n      }.`,\n      {\n        cause,\n        name: 'ExecutionRevertedError',\n      },\n    )\n\n    this.data = data\n  }\n}\n\nexport type FailedToSendToBeneficiaryErrorType =\n  FailedToSendToBeneficiaryError & {\n    name: 'FailedToSendToBeneficiaryError'\n  }\nexport class FailedToSendToBeneficiaryError extends BaseError {\n  static message = /aa91/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Failed to send funds to beneficiary.', {\n      cause,\n      name: 'FailedToSendToBeneficiaryError',\n    })\n  }\n}\n\nexport type GasValuesOverflowErrorType = GasValuesOverflowError & {\n  name: 'GasValuesOverflowError'\n}\nexport class GasValuesOverflowError extends BaseError {\n  static message = /aa94/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Gas value overflowed.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- one of the gas values exceeded 2**120 (uint120)',\n      ].filter(Boolean) as string[],\n      name: 'GasValuesOverflowError',\n    })\n  }\n}\n\nexport type HandleOpsOutOfGasErrorType = HandleOpsOutOfGasError & {\n  name: 'HandleOpsOutOfGasError'\n}\nexport class HandleOpsOutOfGasError extends BaseError {\n  static message = /aa95/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super(\n      'The `handleOps` function was called by the Bundler with a gas limit too low.',\n      {\n        cause,\n        name: 'HandleOpsOutOfGasError',\n      },\n    )\n  }\n}\n\nexport type InitCodeFailedErrorType = InitCodeFailedError & {\n  name: 'InitCodeFailedError'\n}\nexport class InitCodeFailedError extends BaseError {\n  static message = /aa13/\n  constructor({\n    cause,\n    factory,\n    factoryData,\n    initCode,\n  }: {\n    cause?: BaseError | undefined\n    factory?: Address | undefined\n    factoryData?: Hex | undefined\n    initCode?: Hex | undefined\n  }) {\n    super('Failed to simulate deployment for Smart Account.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- Invalid `factory`/`factoryData` or `initCode` properties are present',\n        '- Smart Account deployment execution ran out of gas (low `verificationGasLimit` value)',\n        '- Smart Account deployment execution reverted with an error\\n',\n        factory && `factory: ${factory}`,\n        factoryData && `factoryData: ${factoryData}`,\n        initCode && `initCode: ${initCode}`,\n      ].filter(Boolean) as string[],\n      name: 'InitCodeFailedError',\n    })\n  }\n}\n\nexport type InitCodeMustCreateSenderErrorType =\n  InitCodeMustCreateSenderError & {\n    name: 'InitCodeMustCreateSenderError'\n  }\nexport class InitCodeMustCreateSenderError extends BaseError {\n  static message = /aa15/\n  constructor({\n    cause,\n    factory,\n    factoryData,\n    initCode,\n  }: {\n    cause?: BaseError | undefined\n    factory?: Address | undefined\n    factoryData?: Hex | undefined\n    initCode?: Hex | undefined\n  }) {\n    super(\n      'Smart Account initialization implementation did not create an account.',\n      {\n        cause,\n        metaMessages: [\n          'This could arise when:',\n          '- `factory`/`factoryData` or `initCode` properties are invalid',\n          '- Smart Account initialization implementation is incorrect\\n',\n          factory && `factory: ${factory}`,\n          factoryData && `factoryData: ${factoryData}`,\n          initCode && `initCode: ${initCode}`,\n        ].filter(Boolean) as string[],\n        name: 'InitCodeMustCreateSenderError',\n      },\n    )\n  }\n}\n\nexport type InitCodeMustReturnSenderErrorType =\n  InitCodeMustReturnSenderError & {\n    name: 'InitCodeMustReturnSenderError'\n  }\nexport class InitCodeMustReturnSenderError extends BaseError {\n  static message = /aa14/\n  constructor({\n    cause,\n    factory,\n    factoryData,\n    initCode,\n    sender,\n  }: {\n    cause?: BaseError | undefined\n    factory?: Address | undefined\n    factoryData?: Hex | undefined\n    initCode?: Hex | undefined\n    sender?: Address | undefined\n  }) {\n    super(\n      'Smart Account initialization implementation does not return the expected sender.',\n      {\n        cause,\n        metaMessages: [\n          'This could arise when:',\n          'Smart Account initialization implementation does not return a sender address\\n',\n          factory && `factory: ${factory}`,\n          factoryData && `factoryData: ${factoryData}`,\n          initCode && `initCode: ${initCode}`,\n          sender && `sender: ${sender}`,\n        ].filter(Boolean) as string[],\n        name: 'InitCodeMustReturnSenderError',\n      },\n    )\n  }\n}\n\nexport type InsufficientPrefundErrorType = InsufficientPrefundError & {\n  name: 'InsufficientPrefundError'\n}\nexport class InsufficientPrefundError extends BaseError {\n  static message = /aa21/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super(\n      'Smart Account does not have sufficient funds to execute the User Operation.',\n      {\n        cause,\n        metaMessages: [\n          'This could arise when:',\n          '- the Smart Account does not have sufficient funds to cover the required prefund, or',\n          '- a Paymaster was not provided',\n        ].filter(Boolean) as string[],\n        name: 'InsufficientPrefundError',\n      },\n    )\n  }\n}\n\nexport type InternalCallOnlyErrorType = InternalCallOnlyError & {\n  name: 'InternalCallOnlyError'\n}\nexport class InternalCallOnlyError extends BaseError {\n  static message = /aa92/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Bundler attempted to call an invalid function on the EntryPoint.', {\n      cause,\n      name: 'InternalCallOnlyError',\n    })\n  }\n}\n\nexport type InvalidAggregatorErrorType = InvalidAggregatorError & {\n  name: 'InvalidAggregatorError'\n}\nexport class InvalidAggregatorError extends BaseError {\n  static message = /aa96/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super(\n      'Bundler used an invalid aggregator for handling aggregated User Operations.',\n      {\n        cause,\n        name: 'InvalidAggregatorError',\n      },\n    )\n  }\n}\n\nexport type InvalidAccountNonceErrorType = InvalidAccountNonceError & {\n  name: 'InvalidAccountNonceError'\n}\nexport class InvalidAccountNonceError extends BaseError {\n  static message = /aa25/\n  constructor({\n    cause,\n    nonce,\n  }: {\n    cause?: BaseError | undefined\n    nonce?: bigint | undefined\n  }) {\n    super('Invalid Smart Account nonce used for User Operation.', {\n      cause,\n      metaMessages: [nonce && `nonce: ${nonce}`].filter(Boolean) as string[],\n      name: 'InvalidAccountNonceError',\n    })\n  }\n}\n\nexport type InvalidBeneficiaryErrorType = InvalidBeneficiaryError & {\n  name: 'InvalidBeneficiaryError'\n}\nexport class InvalidBeneficiaryError extends BaseError {\n  static message = /aa90/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Bundler has not set a beneficiary address.', {\n      cause,\n      name: 'InvalidBeneficiaryError',\n    })\n  }\n}\n\nexport type InvalidFieldsErrorType = InvalidFieldsError & {\n  name: 'InvalidFieldsError'\n}\nexport class InvalidFieldsError extends BaseError {\n  static code = -32602\n\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Invalid fields set on User Operation.', {\n      cause,\n      name: 'InvalidFieldsError',\n    })\n  }\n}\n\nexport type InvalidPaymasterAndDataErrorType = InvalidPaymasterAndDataError & {\n  name: 'InvalidPaymasterAndDataError'\n}\nexport class InvalidPaymasterAndDataError extends BaseError {\n  static message = /aa93/\n  constructor({\n    cause,\n    paymasterAndData,\n  }: {\n    cause?: BaseError | undefined\n    paymasterAndData?: Hex | undefined\n  }) {\n    super('Paymaster properties provided are invalid.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- the `paymasterAndData` property is of an incorrect length\\n',\n        paymasterAndData && `paymasterAndData: ${paymasterAndData}`,\n      ].filter(Boolean) as string[],\n      name: 'InvalidPaymasterAndDataError',\n    })\n  }\n}\n\nexport type PaymasterDepositTooLowErrorType = PaymasterDepositTooLowError & {\n  code: -32508\n  name: 'PaymasterDepositTooLowError'\n}\nexport class PaymasterDepositTooLowError extends BaseError {\n  static code = -32508\n  static message = /aa31/\n\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Paymaster deposit for the User Operation is too low.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- the Paymaster has deposited less than the expected amount via the `deposit` function',\n      ].filter(Boolean) as string[],\n      name: 'PaymasterDepositTooLowError',\n    })\n  }\n}\n\nexport type PaymasterFunctionRevertedErrorType =\n  PaymasterFunctionRevertedError & {\n    name: 'PaymasterFunctionRevertedError'\n  }\nexport class PaymasterFunctionRevertedError extends BaseError {\n  static message = /aa33/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('The `validatePaymasterUserOp` function on the Paymaster reverted.', {\n      cause,\n      name: 'PaymasterFunctionRevertedError',\n    })\n  }\n}\n\nexport type PaymasterNotDeployedErrorType = PaymasterNotDeployedError & {\n  name: 'PaymasterNotDeployedError'\n}\nexport class PaymasterNotDeployedError extends BaseError {\n  static message = /aa30/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('The Paymaster contract has not been deployed.', {\n      cause,\n      name: 'PaymasterNotDeployedError',\n    })\n  }\n}\n\nexport type PaymasterRateLimitErrorType = PaymasterRateLimitError & {\n  code: -32504\n  name: 'PaymasterRateLimitError'\n}\nexport class PaymasterRateLimitError extends BaseError {\n  static code = -32504\n\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super(\n      'UserOperation rejected because paymaster (or signature aggregator) is throttled/banned.',\n      {\n        cause,\n        name: 'PaymasterRateLimitError',\n      },\n    )\n  }\n}\n\nexport type PaymasterStakeTooLowErrorType = PaymasterStakeTooLowError & {\n  code: -32505\n  name: 'PaymasterStakeTooLowError'\n}\nexport class PaymasterStakeTooLowError extends BaseError {\n  static code = -32505\n\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super(\n      'UserOperation rejected because paymaster (or signature aggregator) is throttled/banned.',\n      {\n        cause,\n        name: 'PaymasterStakeTooLowError',\n      },\n    )\n  }\n}\n\nexport type PaymasterPostOpFunctionRevertedErrorType =\n  PaymasterPostOpFunctionRevertedError & {\n    name: 'PaymasterPostOpFunctionRevertedError'\n  }\nexport class PaymasterPostOpFunctionRevertedError extends BaseError {\n  static message = /aa50/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Paymaster `postOp` function reverted.', {\n      cause,\n      name: 'PaymasterPostOpFunctionRevertedError',\n    })\n  }\n}\n\nexport type SenderAlreadyConstructedErrorType =\n  SenderAlreadyConstructedError & {\n    name: 'SenderAlreadyConstructedError'\n  }\nexport class SenderAlreadyConstructedError extends BaseError {\n  static message = /aa10/\n  constructor({\n    cause,\n    factory,\n    factoryData,\n    initCode,\n  }: {\n    cause?: BaseError | undefined\n    factory?: Address | undefined\n    factoryData?: Hex | undefined\n    initCode?: Hex | undefined\n  }) {\n    super('Smart Account has already been deployed.', {\n      cause,\n      metaMessages: [\n        'Remove the following properties and try again:',\n        factory && '`factory`',\n        factoryData && '`factoryData`',\n        initCode && '`initCode`',\n      ].filter(Boolean) as string[],\n      name: 'SenderAlreadyConstructedError',\n    })\n  }\n}\n\nexport type SignatureCheckFailedErrorType = SignatureCheckFailedError & {\n  code: -32507\n  name: 'SignatureCheckFailedError'\n}\nexport class SignatureCheckFailedError extends BaseError {\n  static code = -32507\n\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super(\n      'UserOperation rejected because account signature check failed (or paymaster signature, if the paymaster uses its data as signature).',\n      {\n        cause,\n        name: 'SignatureCheckFailedError',\n      },\n    )\n  }\n}\n\nexport type SmartAccountFunctionRevertedErrorType =\n  SmartAccountFunctionRevertedError & {\n    name: 'SmartAccountFunctionRevertedError'\n  }\nexport class SmartAccountFunctionRevertedError extends BaseError {\n  static message = /aa23/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('The `validateUserOp` function on the Smart Account reverted.', {\n      cause,\n      name: 'SmartAccountFunctionRevertedError',\n    })\n  }\n}\n\nexport type UnsupportedSignatureAggregatorErrorType =\n  UnsupportedSignatureAggregatorError & {\n    code: -32506\n    name: 'UnsupportedSignatureAggregatorError'\n  }\nexport class UnsupportedSignatureAggregatorError extends BaseError {\n  static code = -32506\n\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super(\n      'UserOperation rejected because account specified unsupported signature aggregator.',\n      {\n        cause,\n        name: 'UnsupportedSignatureAggregatorError',\n      },\n    )\n  }\n}\n\nexport type UserOperationExpiredErrorType = UserOperationExpiredError & {\n  name: 'UserOperationExpiredError'\n}\nexport class UserOperationExpiredError extends BaseError {\n  static message = /aa22/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('User Operation expired.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- the `validAfter` or `validUntil` values returned from `validateUserOp` on the Smart Account are not satisfied',\n      ].filter(Boolean) as string[],\n      name: 'UserOperationExpiredError',\n    })\n  }\n}\n\nexport type UserOperationPaymasterExpiredErrorType =\n  UserOperationPaymasterExpiredError & {\n    name: 'UserOperationPaymasterExpiredError'\n  }\nexport class UserOperationPaymasterExpiredError extends BaseError {\n  static message = /aa32/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Paymaster for User Operation expired.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- the `validAfter` or `validUntil` values returned from `validatePaymasterUserOp` on the Paymaster are not satisfied',\n      ].filter(Boolean) as string[],\n      name: 'UserOperationPaymasterExpiredError',\n    })\n  }\n}\n\nexport type UserOperationSignatureErrorType = UserOperationSignatureError & {\n  name: 'UserOperationSignatureError'\n}\nexport class UserOperationSignatureError extends BaseError {\n  static message = /aa24/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Signature provided for the User Operation is invalid.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- the `signature` for the User Operation is incorrectly computed, and unable to be verified by the Smart Account',\n      ].filter(Boolean) as string[],\n      name: 'UserOperationSignatureError',\n    })\n  }\n}\n\nexport type UserOperationPaymasterSignatureErrorType =\n  UserOperationPaymasterSignatureError & {\n    name: 'UserOperationPaymasterSignatureError'\n  }\nexport class UserOperationPaymasterSignatureError extends BaseError {\n  static message = /aa34/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Signature provided for the User Operation is invalid.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- the `signature` for the User Operation is incorrectly computed, and unable to be verified by the Paymaster',\n      ].filter(Boolean) as string[],\n      name: 'UserOperationPaymasterSignatureError',\n    })\n  }\n}\n\nexport type UserOperationRejectedByEntryPointErrorType =\n  UserOperationRejectedByEntryPointError & {\n    code: -32500\n    name: 'UserOperationRejectedByEntryPointError'\n  }\nexport class UserOperationRejectedByEntryPointError extends BaseError {\n  static code = -32500\n\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super(\n      \"User Operation rejected by EntryPoint's `simulateValidation` during account creation or validation.\",\n      {\n        cause,\n        name: 'UserOperationRejectedByEntryPointError',\n      },\n    )\n  }\n}\n\nexport type UserOperationRejectedByPaymasterErrorType =\n  UserOperationRejectedByPaymasterError & {\n    code: -32501\n    name: 'UserOperationRejectedByPaymasterError'\n  }\nexport class UserOperationRejectedByPaymasterError extends BaseError {\n  static code = -32501\n\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super(\"User Operation rejected by Paymaster's `validatePaymasterUserOp`.\", {\n      cause,\n      name: 'UserOperationRejectedByPaymasterError',\n    })\n  }\n}\n\nexport type UserOperationRejectedByOpCodeErrorType =\n  UserOperationRejectedByOpCodeError & {\n    code: -32502\n    name: 'UserOperationRejectedByOpCodeError'\n  }\nexport class UserOperationRejectedByOpCodeError extends BaseError {\n  static code = -32502\n\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super('User Operation rejected with op code validation error.', {\n      cause,\n      name: 'UserOperationRejectedByOpCodeError',\n    })\n  }\n}\n\nexport type UserOperationOutOfTimeRangeErrorType =\n  UserOperationOutOfTimeRangeError & {\n    code: -32503\n    name: 'UserOperationOutOfTimeRangeError'\n  }\nexport class UserOperationOutOfTimeRangeError extends BaseError {\n  static code = -32503\n\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super(\n      'UserOperation out of time-range: either wallet or paymaster returned a time-range, and it is already expired (or will expire soon).',\n      {\n        cause,\n        name: 'UserOperationOutOfTimeRangeError',\n      },\n    )\n  }\n}\n\nexport type UnknownBundlerErrorType = UnknownBundlerError & {\n  name: 'UnknownBundlerError'\n}\nexport class UnknownBundlerError extends BaseError {\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super(\n      `An error occurred while executing user operation: ${cause?.shortMessage}`,\n      {\n        cause,\n        name: 'UnknownBundlerError',\n      },\n    )\n  }\n}\n\nexport type VerificationGasLimitExceededErrorType =\n  VerificationGasLimitExceededError & {\n    name: 'VerificationGasLimitExceededError'\n  }\nexport class VerificationGasLimitExceededError extends BaseError {\n  static message = /aa40/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('User Operation verification gas limit exceeded.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- the gas used for verification exceeded the `verificationGasLimit`',\n      ].filter(Boolean) as string[],\n      name: 'VerificationGasLimitExceededError',\n    })\n  }\n}\n\nexport type VerificationGasLimitTooLowErrorType =\n  VerificationGasLimitTooLowError & {\n    name: 'VerificationGasLimitTooLowError'\n  }\nexport class VerificationGasLimitTooLowError extends BaseError {\n  static message = /aa41/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('User Operation verification gas limit is too low.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- the `verificationGasLimit` is too low to verify the User Operation',\n      ].filter(Boolean) as string[],\n      name: 'VerificationGasLimitTooLowError',\n    })\n  }\n}\n", "import { BaseError } from '../../errors/base.js'\nimport { prettyPrint } from '../../errors/transaction.js'\nimport type { Hash } from '../../types/misc.js'\nimport { formatGwei } from '../../utils/index.js'\nimport type { UserOperation } from '../types/userOperation.js'\n\nexport type UserOperationExecutionErrorType = UserOperationExecutionError & {\n  name: 'UserOperationExecutionError'\n}\nexport class UserOperationExecutionError extends BaseError {\n  override cause: BaseError\n\n  constructor(\n    cause: BaseError,\n    {\n      callData,\n      callGasLimit,\n      docsPath,\n      factory,\n      factoryData,\n      initCode,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      paymaster,\n      paymasterAndData,\n      paymasterData,\n      paymasterPostOpGasLimit,\n      paymasterVerificationGasLimit,\n      preVerificationGas,\n      sender,\n      signature,\n      verificationGasLimit,\n    }: UserOperation & {\n      docsPath?: string | undefined\n    },\n  ) {\n    const prettyArgs = prettyPrint({\n      callData,\n      callGasLimit,\n      factory,\n      factoryData,\n      initCode,\n      maxFeePerGas:\n        typeof maxFeePerGas !== 'undefined' &&\n        `${formatGwei(maxFeePerGas)} gwei`,\n      maxPriorityFeePerGas:\n        typeof maxPriorityFeePerGas !== 'undefined' &&\n        `${formatGwei(maxPriorityFeePerGas)} gwei`,\n      nonce,\n      paymaster,\n      paymasterAndData,\n      paymasterData,\n      paymasterPostOpGasLimit,\n      paymasterVerificationGasLimit,\n      preVerificationGas,\n      sender,\n      signature,\n      verificationGasLimit,\n    })\n\n    super(cause.shortMessage, {\n      cause,\n      docsPath,\n      metaMessages: [\n        ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),\n        'Request Arguments:',\n        prettyArgs,\n      ].filter(Boolean) as string[],\n      name: 'UserOperationExecutionError',\n    })\n    this.cause = cause\n  }\n}\n\nexport type UserOperationReceiptNotFoundErrorType =\n  UserOperationReceiptNotFoundError & {\n    name: 'UserOperationReceiptNotFoundError'\n  }\nexport class UserOperationReceiptNotFoundError extends BaseError {\n  constructor({ hash }: { hash: Hash }) {\n    super(\n      `User Operation receipt with hash \"${hash}\" could not be found. The User Operation may not have been processed yet.`,\n      { name: 'UserOperationReceiptNotFoundError' },\n    )\n  }\n}\n\nexport type UserOperationNotFoundErrorType = UserOperationNotFoundError & {\n  name: 'UserOperationNotFoundError'\n}\nexport class UserOperationNotFoundError extends BaseError {\n  constructor({ hash }: { hash: Hash }) {\n    super(`User Operation with hash \"${hash}\" could not be found.`, {\n      name: 'UserOperationNotFoundError',\n    })\n  }\n}\n\nexport type WaitForUserOperationReceiptTimeoutErrorType =\n  WaitForUserOperationReceiptTimeoutError & {\n    name: 'WaitForUserOperationReceiptTimeoutError'\n  }\nexport class WaitForUserOperationReceiptTimeoutError extends BaseError {\n  constructor({ hash }: { hash: Hash }) {\n    super(\n      `Timed out while waiting for User Operation with hash \"${hash}\" to be confirmed.`,\n      { name: 'WaitForUserOperationReceiptTimeoutError' },\n    )\n  }\n}\n", "import type { BaseError } from '../../../errors/base.js'\nimport type { ExactPartial } from '../../../types/utils.js'\nimport {\n  AccountNotDeployedError,\n  type AccountNotDeployedErrorType,\n  ExecutionRevertedError,\n  type ExecutionRevertedErrorType,\n  FailedToSendToBeneficiaryError,\n  type FailedToSendToBeneficiaryErrorType,\n  GasValuesOverflowError,\n  type GasValuesOverflowErrorType,\n  HandleOpsOutOfGasError,\n  type HandleOpsOutOfGasErrorType,\n  InitCodeFailedError,\n  type InitCodeFailedErrorType,\n  InitCodeMustCreateSenderError,\n  type InitCodeMustCreateSenderErrorType,\n  InitCodeMustReturnSenderError,\n  type InitCodeMustReturnSenderErrorType,\n  InsufficientPrefundError,\n  type InsufficientPrefundErrorType,\n  InternalCallOnlyError,\n  type InternalCallOnlyErrorType,\n  InvalidAccountNonceError,\n  type InvalidAccountNonceErrorType,\n  InvalidAggregatorError,\n  type InvalidAggregatorErrorType,\n  InvalidBeneficiaryError,\n  type InvalidBeneficiaryErrorType,\n  InvalidFieldsError,\n  type InvalidFieldsErrorType,\n  InvalidPaymasterAndDataError,\n  type InvalidPaymasterAndDataErrorType,\n  PaymasterDepositTooLowError,\n  type PaymasterDepositTooLowErrorType,\n  PaymasterFunctionRevertedError,\n  type PaymasterFunctionRevertedErrorType,\n  PaymasterNotDeployedError,\n  type PaymasterNotDeployedErrorType,\n  PaymasterPostOpFunctionRevertedError,\n  type PaymasterPostOpFunctionRevertedErrorType,\n  PaymasterRateLimitError,\n  type PaymasterRateLimitErrorType,\n  PaymasterStakeTooLowError,\n  type PaymasterStakeTooLowErrorType,\n  SenderAlreadyConstructedError,\n  type SenderAlreadyConstructedErrorType,\n  SignatureCheckFailedError,\n  type SignatureCheckFailedErrorType,\n  SmartAccountFunctionRevertedError,\n  type SmartAccountFunctionRevertedErrorType,\n  UnknownBundlerError,\n  type UnknownBundlerErrorType,\n  UnsupportedSignatureAggregatorError,\n  type UnsupportedSignatureAggregatorErrorType,\n  UserOperationExpiredError,\n  type UserOperationExpiredErrorType,\n  UserOperationOutOfTimeRangeError,\n  type UserOperationOutOfTimeRangeErrorType,\n  UserOperationPaymasterExpiredError,\n  type UserOperationPaymasterExpiredErrorType,\n  UserOperationPaymasterSignatureError,\n  type UserOperationPaymasterSignatureErrorType,\n  UserOperationRejectedByEntryPointError,\n  type UserOperationRejectedByEntryPointErrorType,\n  UserOperationRejectedByOpCodeError,\n  type UserOperationRejectedByOpCodeErrorType,\n  UserOperationRejectedByPaymasterError,\n  type UserOperationRejectedByPaymasterErrorType,\n  UserOperationSignatureError,\n  type UserOperationSignatureErrorType,\n  VerificationGasLimitExceededError,\n  type VerificationGasLimitExceededErrorType,\n  VerificationGasLimitTooLowError,\n  type VerificationGasLimitTooLowErrorType,\n} from '../../errors/bundler.js'\nimport type { UserOperation } from '../../types/userOperation.js'\n\nconst bundlerErrors = [\n  ExecutionRevertedError,\n  InvalidFieldsError,\n  PaymasterDepositTooLowError,\n  PaymasterRateLimitError,\n  PaymasterStakeTooLowError,\n  SignatureCheckFailedError,\n  UnsupportedSignatureAggregatorError,\n  UserOperationOutOfTimeRangeError,\n  UserOperationRejectedByEntryPointError,\n  UserOperationRejectedByPaymasterError,\n  UserOperationRejectedByOpCodeError,\n]\n\nexport type GetBundlerErrorParameters = ExactPartial<UserOperation>\n\nexport type GetBundlerErrorReturnType =\n  | AccountNotDeployedErrorType\n  | ExecutionRevertedErrorType\n  | FailedToSendToBeneficiaryErrorType\n  | GasValuesOverflowErrorType\n  | HandleOpsOutOfGasErrorType\n  | InitCodeFailedErrorType\n  | InitCodeMustCreateSenderErrorType\n  | InitCodeMustReturnSenderErrorType\n  | InsufficientPrefundErrorType\n  | InternalCallOnlyErrorType\n  | InvalidAccountNonceErrorType\n  | InvalidAggregatorErrorType\n  | InvalidBeneficiaryErrorType\n  | InvalidFieldsErrorType\n  | InvalidPaymasterAndDataErrorType\n  | PaymasterDepositTooLowErrorType\n  | PaymasterFunctionRevertedErrorType\n  | PaymasterNotDeployedErrorType\n  | PaymasterPostOpFunctionRevertedErrorType\n  | PaymasterRateLimitErrorType\n  | PaymasterStakeTooLowErrorType\n  | SignatureCheckFailedErrorType\n  | SenderAlreadyConstructedErrorType\n  | SmartAccountFunctionRevertedErrorType\n  | UnsupportedSignatureAggregatorErrorType\n  | UserOperationOutOfTimeRangeErrorType\n  | UserOperationRejectedByEntryPointErrorType\n  | UserOperationRejectedByOpCodeErrorType\n  | UserOperationRejectedByPaymasterErrorType\n  | UnknownBundlerErrorType\n  | UserOperationExpiredErrorType\n  | UserOperationPaymasterExpiredErrorType\n  | UserOperationPaymasterSignatureErrorType\n  | UserOperationSignatureErrorType\n  | VerificationGasLimitExceededErrorType\n  | VerificationGasLimitTooLowErrorType\n\nexport function getBundlerError(\n  err: BaseError,\n  args: GetBundlerErrorParameters,\n): GetBundlerErrorReturnType {\n  const message = (err.details || '').toLowerCase()\n\n  if (AccountNotDeployedError.message.test(message))\n    return new AccountNotDeployedError({\n      cause: err,\n    }) as any\n  if (FailedToSendToBeneficiaryError.message.test(message))\n    return new FailedToSendToBeneficiaryError({\n      cause: err,\n    }) as any\n  if (GasValuesOverflowError.message.test(message))\n    return new GasValuesOverflowError({\n      cause: err,\n    }) as any\n  if (HandleOpsOutOfGasError.message.test(message))\n    return new HandleOpsOutOfGasError({\n      cause: err,\n    }) as any\n  if (InitCodeFailedError.message.test(message))\n    return new InitCodeFailedError({\n      cause: err,\n      factory: args.factory,\n      factoryData: args.factoryData,\n      initCode: args.initCode,\n    }) as any\n  if (InitCodeMustCreateSenderError.message.test(message))\n    return new InitCodeMustCreateSenderError({\n      cause: err,\n      factory: args.factory,\n      factoryData: args.factoryData,\n      initCode: args.initCode,\n    }) as any\n  if (InitCodeMustReturnSenderError.message.test(message))\n    return new InitCodeMustReturnSenderError({\n      cause: err,\n      factory: args.factory,\n      factoryData: args.factoryData,\n      initCode: args.initCode,\n      sender: args.sender,\n    }) as any\n  if (InsufficientPrefundError.message.test(message))\n    return new InsufficientPrefundError({\n      cause: err,\n    }) as any\n  if (InternalCallOnlyError.message.test(message))\n    return new InternalCallOnlyError({\n      cause: err,\n    }) as any\n  if (InvalidAccountNonceError.message.test(message))\n    return new InvalidAccountNonceError({\n      cause: err,\n      nonce: args.nonce,\n    }) as any\n  if (InvalidAggregatorError.message.test(message))\n    return new InvalidAggregatorError({\n      cause: err,\n    }) as any\n  if (InvalidBeneficiaryError.message.test(message))\n    return new InvalidBeneficiaryError({\n      cause: err,\n    }) as any\n  if (InvalidPaymasterAndDataError.message.test(message))\n    return new InvalidPaymasterAndDataError({\n      cause: err,\n    }) as any\n  if (PaymasterDepositTooLowError.message.test(message))\n    return new PaymasterDepositTooLowError({\n      cause: err,\n    }) as any\n  if (PaymasterFunctionRevertedError.message.test(message))\n    return new PaymasterFunctionRevertedError({\n      cause: err,\n    }) as any\n  if (PaymasterNotDeployedError.message.test(message))\n    return new PaymasterNotDeployedError({\n      cause: err,\n    }) as any\n  if (PaymasterPostOpFunctionRevertedError.message.test(message))\n    return new PaymasterPostOpFunctionRevertedError({\n      cause: err,\n    }) as any\n  if (SmartAccountFunctionRevertedError.message.test(message))\n    return new SmartAccountFunctionRevertedError({\n      cause: err,\n    }) as any\n  if (SenderAlreadyConstructedError.message.test(message))\n    return new SenderAlreadyConstructedError({\n      cause: err,\n      factory: args.factory,\n      factoryData: args.factoryData,\n      initCode: args.initCode,\n    }) as any\n  if (UserOperationExpiredError.message.test(message))\n    return new UserOperationExpiredError({\n      cause: err,\n    }) as any\n  if (UserOperationPaymasterExpiredError.message.test(message))\n    return new UserOperationPaymasterExpiredError({\n      cause: err,\n    }) as any\n  if (UserOperationPaymasterSignatureError.message.test(message))\n    return new UserOperationPaymasterSignatureError({\n      cause: err,\n    }) as any\n  if (UserOperationSignatureError.message.test(message))\n    return new UserOperationSignatureError({\n      cause: err,\n    }) as any\n  if (VerificationGasLimitExceededError.message.test(message))\n    return new VerificationGasLimitExceededError({\n      cause: err,\n    }) as any\n  if (VerificationGasLimitTooLowError.message.test(message))\n    return new VerificationGasLimitTooLowError({\n      cause: err,\n    }) as any\n\n  const error = err.walk((e) =>\n    bundlerErrors.some((error) => error.code === (e as { code: number }).code),\n  ) as BaseError & { code: number; data: any }\n\n  if (error) {\n    if (error.code === ExecutionRevertedError.code)\n      return new ExecutionRevertedError({\n        cause: err,\n        data: error.data,\n        message: error.details,\n      }) as any\n    if (error.code === InvalidFieldsError.code)\n      return new InvalidFieldsError({\n        cause: err,\n      }) as any\n    if (error.code === PaymasterDepositTooLowError.code)\n      return new PaymasterDepositTooLowError({\n        cause: err,\n      }) as any\n    if (error.code === PaymasterRateLimitError.code)\n      return new PaymasterRateLimitError({\n        cause: err,\n      }) as any\n    if (error.code === PaymasterStakeTooLowError.code)\n      return new PaymasterStakeTooLowError({\n        cause: err,\n      }) as any\n    if (error.code === SignatureCheckFailedError.code)\n      return new SignatureCheckFailedError({\n        cause: err,\n      }) as any\n    if (error.code === UnsupportedSignatureAggregatorError.code)\n      return new UnsupportedSignatureAggregatorError({\n        cause: err,\n      }) as any\n    if (error.code === UserOperationOutOfTimeRangeError.code)\n      return new UserOperationOutOfTimeRangeError({\n        cause: err,\n      }) as any\n    if (error.code === UserOperationRejectedByEntryPointError.code)\n      return new UserOperationRejectedByEntryPointError({\n        cause: err,\n      }) as any\n    if (error.code === UserOperationRejectedByPaymasterError.code)\n      return new UserOperationRejectedByPaymasterError({\n        cause: err,\n      }) as any\n    if (error.code === UserOperationRejectedByOpCodeError.code)\n      return new UserOperationRejectedByOpCodeError({\n        cause: err,\n      }) as any\n  }\n\n  return new UnknownBundlerError({\n    cause: err,\n  }) as any\n}\n", "import type { ErrorType } from '../../../errors/utils.js'\nimport type { RpcEstimateUserOperationGasReturnType } from '../../types/rpc.js'\nimport type { EstimateUserOperationGasReturnType } from '../../types/userOperation.js'\n\nexport type FormatUserOperationGasErrorType = ErrorType\n\nexport function formatUserOperationGas(\n  parameters: RpcEstimateUserOperationGasReturnType,\n): EstimateUserOperationGasReturnType {\n  const gas = {} as EstimateUserOperationGasReturnType\n\n  if (parameters.callGasLimit)\n    gas.callGasLimit = BigInt(parameters.callGasLimit)\n  if (parameters.preVerificationGas)\n    gas.preVerificationGas = BigInt(parameters.preVerificationGas)\n  if (parameters.verificationGasLimit)\n    gas.verificationGasLimit = BigInt(parameters.verificationGasLimit)\n  if (parameters.paymasterPostOpGasLimit)\n    gas.paymasterPostOpGasLimit = BigInt(parameters.paymasterPostOpGasLimit)\n  if (parameters.paymasterVerificationGasLimit)\n    gas.paymasterVerificationGasLimit = BigInt(\n      parameters.paymasterVerificationGasLimit,\n    )\n\n  return gas\n}\n", "import type { ErrorType } from '../../../errors/utils.js'\nimport type { SignedAuthorization } from '../../../types/authorization.js'\nimport type { ExactPartial } from '../../../types/utils.js'\nimport { numberToHex } from '../../../utils/encoding/toHex.js'\nimport { pad } from '../../../utils/index.js'\nimport type { RpcUserOperation } from '../../types/rpc.js'\nimport type { UserOperation } from '../../types/userOperation.js'\n\nexport type FormatUserOperationRequestErrorType = ErrorType\n\nexport function formatUserOperationRequest(\n  request: ExactPartial<UserOperation>,\n) {\n  const rpcRequest = {} as RpcUserOperation\n\n  if (typeof request.callData !== 'undefined')\n    rpcRequest.callData = request.callData\n  if (typeof request.callGasLimit !== 'undefined')\n    rpcRequest.callGasLimit = numberToHex(request.callGasLimit)\n  if (typeof request.factory !== 'undefined')\n    rpcRequest.factory = request.factory\n  if (typeof request.factoryData !== 'undefined')\n    rpcRequest.factoryData = request.factoryData\n  if (typeof request.initCode !== 'undefined')\n    rpcRequest.initCode = request.initCode\n  if (typeof request.maxFeePerGas !== 'undefined')\n    rpcRequest.maxFeePerGas = numberToHex(request.maxFeePerGas)\n  if (typeof request.maxPriorityFeePerGas !== 'undefined')\n    rpcRequest.maxPriorityFeePerGas = numberToHex(request.maxPriorityFeePerGas)\n  if (typeof request.nonce !== 'undefined')\n    rpcRequest.nonce = numberToHex(request.nonce)\n  if (typeof request.paymaster !== 'undefined')\n    rpcRequest.paymaster = request.paymaster\n  if (typeof request.paymasterAndData !== 'undefined')\n    rpcRequest.paymasterAndData = request.paymasterAndData || '0x'\n  if (typeof request.paymasterData !== 'undefined')\n    rpcRequest.paymasterData = request.paymasterData\n  if (typeof request.paymasterPostOpGasLimit !== 'undefined')\n    rpcRequest.paymasterPostOpGasLimit = numberToHex(\n      request.paymasterPostOpGasLimit,\n    )\n  if (typeof request.paymasterVerificationGasLimit !== 'undefined')\n    rpcRequest.paymasterVerificationGasLimit = numberToHex(\n      request.paymasterVerificationGasLimit,\n    )\n  if (typeof request.preVerificationGas !== 'undefined')\n    rpcRequest.preVerificationGas = numberToHex(request.preVerificationGas)\n  if (typeof request.sender !== 'undefined') rpcRequest.sender = request.sender\n  if (typeof request.signature !== 'undefined')\n    rpcRequest.signature = request.signature\n  if (typeof request.verificationGasLimit !== 'undefined')\n    rpcRequest.verificationGasLimit = numberToHex(request.verificationGasLimit)\n  if (typeof request.authorization !== 'undefined')\n    rpcRequest.eip7702Auth = formatAuthorization(request.authorization)\n\n  return rpcRequest\n}\n\nfunction formatAuthorization(authorization: SignedAuthorization) {\n  return {\n    address: authorization.address,\n    chainId: numberToHex(authorization.chainId),\n    nonce: numberToHex(authorization.nonce),\n    r: authorization.r\n      ? numberToHex(BigInt(authorization.r), { size: 32 })\n      : pad('0x', { size: 32 }),\n    s: authorization.s\n      ? numberToHex(BigInt(authorization.s), { size: 32 })\n      : pad('0x', { size: 32 }),\n    yParity: authorization.yParity\n      ? numberToHex(authorization.yParity, { size: 1 })\n      : pad('0x', { size: 32 }),\n  }\n}\n", "import type { Address, Narrow } from 'abitype'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../../accounts/utils/parseAccount.js'\nimport { prepareAuthorization } from '../../../actions/index.js'\nimport {\n  type EstimateFeesPerGasErrorType,\n  estimateFeesPerGas,\n} from '../../../actions/public/estimateFeesPerGas.js'\nimport { getChainId as getChainId_ } from '../../../actions/public/getChainId.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport { AccountNotFoundError } from '../../../errors/account.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { SignedAuthorization } from '../../../types/authorization.js'\nimport type { Call, Calls } from '../../../types/calls.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type { Hex } from '../../../types/misc.js'\nimport type { StateOverride } from '../../../types/stateOverride.js'\nimport type {\n  Assign,\n  OneOf,\n  Prettify,\n  UnionOmit,\n} from '../../../types/utils.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../../utils/abi/encodeFunctionData.js'\nimport { type ConcatErrorType, concat } from '../../../utils/data/concat.js'\nimport { getAction } from '../../../utils/getAction.js'\nimport type { SmartAccount } from '../../accounts/types.js'\nimport type { BundlerClient } from '../../clients/createBundlerClient.js'\nimport type { PaymasterActions } from '../../clients/decorators/paymaster.js'\nimport type {\n  DeriveSmartAccount,\n  GetSmartAccountParameter,\n} from '../../types/account.js'\nimport type {\n  DeriveEntryPointVersion,\n  EntryPointVersion,\n} from '../../types/entryPointVersion.js'\nimport type {\n  UserOperation,\n  UserOperationRequest,\n} from '../../types/userOperation.js'\nimport {\n  type GetPaymasterDataErrorType,\n  getPaymasterData as getPaymasterData_,\n} from '../paymaster/getPaymasterData.js'\nimport {\n  type GetPaymasterStubDataErrorType,\n  getPaymasterStubData as getPaymasterStubData_,\n} from '../paymaster/getPaymasterStubData.js'\nimport {\n  type EstimateUserOperationGasParameters,\n  estimateUserOperationGas,\n} from './estimateUserOperationGas.js'\n\nconst defaultParameters = [\n  'factory',\n  'fees',\n  'gas',\n  'paymaster',\n  'nonce',\n  'signature',\n  'authorization',\n] as const\n\nexport type PrepareUserOperationParameterType =\n  | 'factory'\n  | 'fees'\n  | 'gas'\n  | 'paymaster'\n  | 'nonce'\n  | 'signature'\n  | 'authorization'\n\ntype FactoryProperties<\n  entryPointVersion extends EntryPointVersion = EntryPointVersion,\n> =\n  | (entryPointVersion extends '0.8'\n      ? {\n          factory: UserOperation['factory']\n          factoryData: UserOperation['factoryData']\n        }\n      : never)\n  | (entryPointVersion extends '0.7'\n      ? {\n          factory: UserOperation['factory']\n          factoryData: UserOperation['factoryData']\n        }\n      : never)\n  | (entryPointVersion extends '0.6'\n      ? {\n          initCode: UserOperation['initCode']\n        }\n      : never)\n\ntype GasProperties<\n  entryPointVersion extends EntryPointVersion = EntryPointVersion,\n> =\n  | (entryPointVersion extends '0.8'\n      ? {\n          callGasLimit: UserOperation['callGasLimit']\n          preVerificationGas: UserOperation['preVerificationGas']\n          verificationGasLimit: UserOperation['verificationGasLimit']\n          paymasterPostOpGasLimit: UserOperation['paymasterPostOpGasLimit']\n          paymasterVerificationGasLimit: UserOperation['paymasterVerificationGasLimit']\n        }\n      : never)\n  | (entryPointVersion extends '0.7'\n      ? {\n          callGasLimit: UserOperation['callGasLimit']\n          preVerificationGas: UserOperation['preVerificationGas']\n          verificationGasLimit: UserOperation['verificationGasLimit']\n          paymasterPostOpGasLimit: UserOperation['paymasterPostOpGasLimit']\n          paymasterVerificationGasLimit: UserOperation['paymasterVerificationGasLimit']\n        }\n      : never)\n  | (entryPointVersion extends '0.6'\n      ? {\n          callGasLimit: UserOperation['callGasLimit']\n          preVerificationGas: UserOperation['preVerificationGas']\n          verificationGasLimit: UserOperation['verificationGasLimit']\n        }\n      : never)\n\ntype FeeProperties = {\n  maxFeePerGas: UserOperation['maxFeePerGas']\n  maxPriorityFeePerGas: UserOperation['maxPriorityFeePerGas']\n}\n\ntype NonceProperties = {\n  nonce: UserOperation['nonce']\n}\n\ntype PaymasterProperties<\n  entryPointVersion extends EntryPointVersion = EntryPointVersion,\n> =\n  | (entryPointVersion extends '0.8'\n      ? {\n          paymaster: UserOperation['paymaster']\n          paymasterData: UserOperation['paymasterData']\n          paymasterPostOpGasLimit: UserOperation['paymasterPostOpGasLimit']\n          paymasterVerificationGasLimit: UserOperation['paymasterVerificationGasLimit']\n        }\n      : never)\n  | (entryPointVersion extends '0.7'\n      ? {\n          paymaster: UserOperation['paymaster']\n          paymasterData: UserOperation['paymasterData']\n          paymasterPostOpGasLimit: UserOperation['paymasterPostOpGasLimit']\n          paymasterVerificationGasLimit: UserOperation['paymasterVerificationGasLimit']\n        }\n      : never)\n  | (entryPointVersion extends '0.6'\n      ? {\n          paymasterAndData: UserOperation['paymasterAndData']\n        }\n      : never)\n\ntype SignatureProperties = {\n  signature: UserOperation['signature']\n}\n\ntype AuthorizationProperties = {\n  authorization: UserOperation['authorization']\n}\n\nexport type PrepareUserOperationRequest<\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = SmartAccount | undefined,\n  calls extends readonly unknown[] = readonly unknown[],\n  //\n  _derivedAccount extends SmartAccount | undefined = DeriveSmartAccount<\n    account,\n    accountOverride\n  >,\n  _derivedVersion extends\n    EntryPointVersion = DeriveEntryPointVersion<_derivedAccount>,\n> = Assign<\n  UserOperationRequest<_derivedVersion>,\n  OneOf<{ calls: Calls<Narrow<calls>> } | { callData: Hex }> & {\n    parameters?: readonly PrepareUserOperationParameterType[] | undefined\n    paymaster?:\n      | Address\n      | true\n      | {\n          /** Retrieves paymaster-related User Operation properties to be used for sending the User Operation. */\n          getPaymasterData?: PaymasterActions['getPaymasterData'] | undefined\n          /** Retrieves paymaster-related User Operation properties to be used for gas estimation. */\n          getPaymasterStubData?:\n            | PaymasterActions['getPaymasterStubData']\n            | undefined\n        }\n      | undefined\n    /** Paymaster context to pass to `getPaymasterData` and `getPaymasterStubData` calls. */\n    paymasterContext?: unknown | undefined\n    /** State overrides for the User Operation call. */\n    stateOverride?: StateOverride | undefined\n  }\n>\n\nexport type PrepareUserOperationParameters<\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = SmartAccount | undefined,\n  calls extends readonly unknown[] = readonly unknown[],\n  request extends PrepareUserOperationRequest<\n    account,\n    accountOverride,\n    calls\n  > = PrepareUserOperationRequest<account, accountOverride, calls>,\n> = request & GetSmartAccountParameter<account, accountOverride>\n\nexport type PrepareUserOperationReturnType<\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = SmartAccount | undefined,\n  calls extends readonly unknown[] = readonly unknown[],\n  request extends PrepareUserOperationRequest<\n    account,\n    accountOverride,\n    calls\n  > = PrepareUserOperationRequest<account, accountOverride, calls>,\n  //\n  _parameters extends\n    PrepareUserOperationParameterType = request['parameters'] extends readonly PrepareUserOperationParameterType[]\n    ? request['parameters'][number]\n    : (typeof defaultParameters)[number],\n  _derivedAccount extends SmartAccount | undefined = DeriveSmartAccount<\n    account,\n    accountOverride\n  >,\n  _derivedVersion extends\n    EntryPointVersion = DeriveEntryPointVersion<_derivedAccount>,\n> = Prettify<\n  UnionOmit<request, 'calls' | 'parameters'> & {\n    callData: Hex\n    paymasterAndData: _derivedVersion extends '0.6' ? Hex : undefined\n    sender: UserOperation['sender']\n  } & (Extract<_parameters, 'authorization'> extends never\n      ? {}\n      : AuthorizationProperties) &\n    (Extract<_parameters, 'factory'> extends never\n      ? {}\n      : FactoryProperties<_derivedVersion>) &\n    (Extract<_parameters, 'nonce'> extends never ? {} : NonceProperties) &\n    (Extract<_parameters, 'fees'> extends never ? {} : FeeProperties) &\n    (Extract<_parameters, 'gas'> extends never\n      ? {}\n      : GasProperties<_derivedVersion>) &\n    (Extract<_parameters, 'paymaster'> extends never\n      ? {}\n      : PaymasterProperties<_derivedVersion>) &\n    (Extract<_parameters, 'signature'> extends never ? {} : SignatureProperties)\n>\n\nexport type PrepareUserOperationErrorType =\n  | ParseAccountErrorType\n  | GetPaymasterStubDataErrorType\n  | GetPaymasterDataErrorType\n  | EncodeFunctionDataErrorType\n  | ConcatErrorType\n  | EstimateFeesPerGasErrorType\n  | ErrorType\n\n/**\n * Prepares a User Operation and fills in missing properties.\n *\n * - Docs: https://viem.sh/actions/bundler/prepareUserOperation\n *\n * @param args - {@link PrepareUserOperationParameters}\n * @returns The User Operation. {@link PrepareUserOperationReturnType}\n *\n * @example\n * import { createBundlerClient, http } from 'viem'\n * import { toSmartAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { prepareUserOperation } from 'viem/actions'\n *\n * const account = await toSmartAccount({ ... })\n *\n * const client = createBundlerClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const request = await prepareUserOperation(client, {\n *   account,\n *   calls: [{ to: '0x...', value: parseEther('1') }],\n * })\n */\nexport async function prepareUserOperation<\n  account extends SmartAccount | undefined,\n  const calls extends readonly unknown[],\n  const request extends PrepareUserOperationRequest<\n    account,\n    accountOverride,\n    calls\n  >,\n  accountOverride extends SmartAccount | undefined = undefined,\n>(\n  client: Client<Transport, Chain | undefined, account>,\n  parameters_: PrepareUserOperationParameters<\n    account,\n    accountOverride,\n    calls,\n    request\n  >,\n): Promise<\n  PrepareUserOperationReturnType<account, accountOverride, calls, request>\n> {\n  const parameters = parameters_ as PrepareUserOperationParameters\n  const {\n    account: account_ = client.account,\n    parameters: properties = defaultParameters,\n    stateOverride,\n  } = parameters\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Assert that an Account is defined.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  if (!account_) throw new AccountNotFoundError()\n  const account = parseAccount(account_)\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Declare typed Bundler Client.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  const bundlerClient = client as unknown as BundlerClient\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Declare Paymaster properties.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  const paymaster = parameters.paymaster ?? bundlerClient?.paymaster\n  const paymasterAddress = typeof paymaster === 'string' ? paymaster : undefined\n  const { getPaymasterStubData, getPaymasterData } = (() => {\n    // If `paymaster: true`, we will assume the Bundler Client supports Paymaster Actions.\n    if (paymaster === true)\n      return {\n        getPaymasterStubData: (parameters: any) =>\n          getAction(\n            bundlerClient,\n            getPaymasterStubData_,\n            'getPaymasterStubData',\n          )(parameters),\n        getPaymasterData: (parameters: any) =>\n          getAction(\n            bundlerClient,\n            getPaymasterData_,\n            'getPaymasterData',\n          )(parameters),\n      }\n\n    // If Actions are passed to `paymaster` (via Paymaster Client or directly), we will use them.\n    if (typeof paymaster === 'object') {\n      const { getPaymasterStubData, getPaymasterData } = paymaster\n      return {\n        getPaymasterStubData: (getPaymasterData && getPaymasterStubData\n          ? getPaymasterStubData\n          : getPaymasterData) as typeof getPaymasterStubData,\n        getPaymasterData:\n          getPaymasterData && getPaymasterStubData\n            ? getPaymasterData\n            : undefined,\n      }\n    }\n\n    // No Paymaster functions.\n    return {\n      getPaymasterStubData: undefined,\n      getPaymasterData: undefined,\n    }\n  })()\n  const paymasterContext = parameters.paymasterContext\n    ? parameters.paymasterContext\n    : bundlerClient?.paymasterContext\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Set up the User Operation request.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  let request = {\n    ...parameters,\n    paymaster: paymasterAddress,\n    sender: account.address,\n  } as PrepareUserOperationRequest\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Concurrently prepare properties required to fill the User Operation.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  const [callData, factory, fees, nonce, authorization] = await Promise.all([\n    (async () => {\n      if (parameters.calls)\n        return account.encodeCalls(\n          parameters.calls.map((call_) => {\n            const call = call_ as Call\n            if (call.abi)\n              return {\n                data: encodeFunctionData(call),\n                to: call.to,\n                value: call.value,\n              } as Call\n            return call as Call\n          }),\n        )\n      return parameters.callData\n    })(),\n    (async () => {\n      if (!properties.includes('factory')) return undefined\n      if (parameters.initCode) return { initCode: parameters.initCode }\n      if (parameters.factory && parameters.factoryData) {\n        return {\n          factory: parameters.factory,\n          factoryData: parameters.factoryData,\n        }\n      }\n\n      const { factory, factoryData } = await account.getFactoryArgs()\n\n      if (account.entryPoint.version === '0.6')\n        return {\n          initCode:\n            factory && factoryData ? concat([factory, factoryData]) : undefined,\n        }\n      return {\n        factory,\n        factoryData,\n      }\n    })(),\n    (async () => {\n      if (!properties.includes('fees')) return undefined\n\n      // If we have sufficient properties for fees, return them.\n      if (\n        typeof parameters.maxFeePerGas === 'bigint' &&\n        typeof parameters.maxPriorityFeePerGas === 'bigint'\n      )\n        return request\n\n      // If the Bundler Client has a `estimateFeesPerGas` hook, run it.\n      if (bundlerClient?.userOperation?.estimateFeesPerGas) {\n        const fees = await bundlerClient.userOperation.estimateFeesPerGas({\n          account,\n          bundlerClient,\n          userOperation: request as UserOperation,\n        })\n        return {\n          ...request,\n          ...fees,\n        }\n      }\n\n      // Otherwise, we will need to estimate the fees to fill the fee properties.\n      try {\n        const client_ = bundlerClient.client ?? client\n        const fees = await getAction(\n          client_,\n          estimateFeesPerGas,\n          'estimateFeesPerGas',\n        )({\n          chain: client_.chain,\n          type: 'eip1559',\n        })\n        return {\n          maxFeePerGas:\n            typeof parameters.maxFeePerGas === 'bigint'\n              ? parameters.maxFeePerGas\n              : BigInt(\n                  // Bundlers unfortunately have strict rules on fee prechecks  we will need to set a generous buffer.\n                  2n * fees.maxFeePerGas,\n                ),\n          maxPriorityFeePerGas:\n            typeof parameters.maxPriorityFeePerGas === 'bigint'\n              ? parameters.maxPriorityFeePerGas\n              : BigInt(\n                  // Bundlers unfortunately have strict rules on fee prechecks  we will need to set a generous buffer.\n                  2n * fees.maxPriorityFeePerGas,\n                ),\n        }\n      } catch {\n        return undefined\n      }\n    })(),\n    (async () => {\n      if (!properties.includes('nonce')) return undefined\n      if (typeof parameters.nonce === 'bigint') return parameters.nonce\n      return account.getNonce()\n    })(),\n    (async () => {\n      if (!properties.includes('authorization')) return undefined\n      if (typeof parameters.authorization === 'object')\n        return parameters.authorization\n      if (account.authorization && !(await account.isDeployed())) {\n        const authorization = await prepareAuthorization(\n          account.client,\n          account.authorization,\n        )\n        return {\n          ...authorization,\n          r: '0xfffffffffffffffffffffffffffffff000000000000000000000000000000000',\n          s: '0x7aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',\n          yParity: 1,\n        } satisfies SignedAuthorization\n      }\n      return undefined\n    })(),\n  ])\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Fill User Operation with the prepared properties from above.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  if (typeof callData !== 'undefined') request.callData = callData\n  if (typeof factory !== 'undefined')\n    request = { ...request, ...(factory as any) }\n  if (typeof fees !== 'undefined') request = { ...request, ...(fees as any) }\n  if (typeof nonce !== 'undefined') request.nonce = nonce\n  if (typeof authorization !== 'undefined')\n    request.authorization = authorization\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Fill User Operation with the `signature` property.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  if (properties.includes('signature')) {\n    if (typeof parameters.signature !== 'undefined')\n      request.signature = parameters.signature\n    else\n      request.signature = await account.getStubSignature(\n        request as UserOperation,\n      )\n  }\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // `initCode` is required to be filled with EntryPoint 0.6.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  // If no `initCode` is provided, we use an empty bytes string.\n  if (account.entryPoint.version === '0.6' && !request.initCode)\n    request.initCode = '0x'\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Fill User Operation with paymaster-related properties for **gas estimation**.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  let chainId: number | undefined\n  async function getChainId(): Promise<number> {\n    if (chainId) return chainId\n    if (client.chain) return client.chain.id\n    const chainId_ = await getAction(client, getChainId_, 'getChainId')({})\n    chainId = chainId_\n    return chainId\n  }\n\n  // If the User Operation is intended to be sponsored, we will need to fill the paymaster-related\n  // User Operation properties required to estimate the User Operation gas.\n  let isPaymasterPopulated = false\n  if (\n    properties.includes('paymaster') &&\n    getPaymasterStubData &&\n    !paymasterAddress &&\n    !parameters.paymasterAndData\n  ) {\n    const {\n      isFinal = false,\n      sponsor: _,\n      ...paymasterArgs\n    } = await getPaymasterStubData({\n      chainId: await getChainId(),\n      entryPointAddress: account.entryPoint.address,\n      context: paymasterContext,\n      ...(request as UserOperation),\n    })\n    isPaymasterPopulated = isFinal\n    request = {\n      ...request,\n      ...paymasterArgs,\n    } as PrepareUserOperationRequest\n  }\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // `paymasterAndData` is required to be filled with EntryPoint 0.6.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  // If no `paymasterAndData` is provided, we use an empty bytes string.\n  if (account.entryPoint.version === '0.6' && !request.paymasterAndData)\n    request.paymasterAndData = '0x'\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Fill User Operation with gas-related properties.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  if (properties.includes('gas')) {\n    // If the Account has opinionated gas estimation logic, run the `estimateGas` hook and\n    // fill the request with the prepared gas properties.\n    if (account.userOperation?.estimateGas) {\n      const gas = await account.userOperation.estimateGas(\n        request as UserOperation,\n      )\n      request = {\n        ...request,\n        ...gas,\n      } as PrepareUserOperationRequest\n    }\n\n    // If not all the gas properties are already populated, we will need to estimate the gas\n    // to fill the gas properties.\n    if (\n      typeof request.callGasLimit === 'undefined' ||\n      typeof request.preVerificationGas === 'undefined' ||\n      typeof request.verificationGasLimit === 'undefined' ||\n      (request.paymaster &&\n        typeof request.paymasterPostOpGasLimit === 'undefined') ||\n      (request.paymaster &&\n        typeof request.paymasterVerificationGasLimit === 'undefined')\n    ) {\n      const gas = await getAction(\n        bundlerClient,\n        estimateUserOperationGas,\n        'estimateUserOperationGas',\n      )({\n        account,\n        // Some Bundlers fail if nullish gas values are provided for gas estimation :') \n        // so we will need to set a default zeroish value.\n        callGasLimit: 0n,\n        preVerificationGas: 0n,\n        verificationGasLimit: 0n,\n        stateOverride,\n        ...(request.paymaster\n          ? {\n              paymasterPostOpGasLimit: 0n,\n              paymasterVerificationGasLimit: 0n,\n            }\n          : {}),\n        ...request,\n      } as EstimateUserOperationGasParameters)\n      request = {\n        ...request,\n        callGasLimit: request.callGasLimit ?? gas.callGasLimit,\n        preVerificationGas:\n          request.preVerificationGas ?? gas.preVerificationGas,\n        verificationGasLimit:\n          request.verificationGasLimit ?? gas.verificationGasLimit,\n        paymasterPostOpGasLimit:\n          request.paymasterPostOpGasLimit ?? gas.paymasterPostOpGasLimit,\n        paymasterVerificationGasLimit:\n          request.paymasterVerificationGasLimit ??\n          gas.paymasterVerificationGasLimit,\n      } as PrepareUserOperationRequest\n    }\n  }\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Fill User Operation with paymaster-related properties for **sending** the User Operation.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  // If the User Operation is intended to be sponsored, we will need to fill the paymaster-related\n  // User Operation properties required to send the User Operation.\n  if (\n    properties.includes('paymaster') &&\n    getPaymasterData &&\n    !paymasterAddress &&\n    !parameters.paymasterAndData &&\n    !isPaymasterPopulated\n  ) {\n    // Retrieve paymaster-related User Operation properties to be used for **sending** the User Operation.\n    const paymaster = await getPaymasterData({\n      chainId: await getChainId(),\n      entryPointAddress: account.entryPoint.address,\n      context: paymasterContext,\n      ...(request as UserOperation),\n    })\n    request = {\n      ...request,\n      ...paymaster,\n    } as PrepareUserOperationRequest\n  }\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Remove redundant properties that do not conform to the User Operation schema.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  delete request.calls\n  delete request.parameters\n  delete request.paymasterContext\n  if (typeof request.paymaster !== 'string') delete request.paymaster\n\n  ////////////////////////////////////////////////////////////////////////////////\n\n  return request as unknown as PrepareUserOperationReturnType<\n    account,\n    accountOverride,\n    calls,\n    request\n  >\n}\n", "import type { Address } from 'abitype'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Hex } from '../../../types/misc.js'\nimport type { OneOf, PartialBy, Prettify } from '../../../types/utils.js'\nimport { hexToBigInt } from '../../../utils/encoding/fromHex.js'\nimport { numberToHex } from '../../../utils/encoding/toHex.js'\nimport type { UserOperation } from '../../types/userOperation.js'\nimport {\n  type FormatUserOperationRequestErrorType,\n  formatUserOperationRequest,\n} from '../../utils/formatters/userOperationRequest.js'\n\nexport type GetPaymasterDataParameters = OneOf<\n  | PartialBy<\n      Pick<\n        UserOperation<'0.6'>,\n        | 'callData'\n        | 'callGasLimit'\n        | 'initCode'\n        | 'maxFeePerGas'\n        | 'maxPriorityFeePerGas'\n        | 'nonce'\n        | 'sender'\n        | 'preVerificationGas'\n        | 'verificationGasLimit'\n      >,\n      | 'callGasLimit'\n      | 'initCode'\n      | 'maxFeePerGas'\n      | 'maxPriorityFeePerGas'\n      | 'preVerificationGas'\n      | 'verificationGasLimit'\n    >\n  | PartialBy<\n      Pick<\n        UserOperation<'0.7'>,\n        | 'callData'\n        | 'callGasLimit'\n        | 'factory'\n        | 'factoryData'\n        | 'maxFeePerGas'\n        | 'maxPriorityFeePerGas'\n        | 'nonce'\n        | 'sender'\n        | 'preVerificationGas'\n        | 'verificationGasLimit'\n        | 'paymasterPostOpGasLimit'\n        | 'paymasterVerificationGasLimit'\n      >,\n      | 'callGasLimit'\n      | 'factory'\n      | 'factoryData'\n      | 'maxFeePerGas'\n      | 'maxPriorityFeePerGas'\n      | 'preVerificationGas'\n      | 'verificationGasLimit'\n    >\n  | PartialBy<\n      Pick<\n        UserOperation<'0.8'>,\n        | 'callData'\n        | 'callGasLimit'\n        | 'factory'\n        | 'factoryData'\n        | 'maxFeePerGas'\n        | 'maxPriorityFeePerGas'\n        | 'nonce'\n        | 'sender'\n        | 'preVerificationGas'\n        | 'verificationGasLimit'\n        | 'paymasterPostOpGasLimit'\n        | 'paymasterVerificationGasLimit'\n      >,\n      | 'callGasLimit'\n      | 'factory'\n      | 'factoryData'\n      | 'maxFeePerGas'\n      | 'maxPriorityFeePerGas'\n      | 'preVerificationGas'\n      | 'verificationGasLimit'\n    >\n> & {\n  context?: unknown | undefined\n  chainId: number\n  entryPointAddress: Address\n}\n\nexport type GetPaymasterDataReturnType = Prettify<\n  OneOf<\n    | { paymasterAndData: Hex }\n    | {\n        paymaster: Address\n        paymasterData: Hex\n        paymasterPostOpGasLimit?: bigint | undefined\n        paymasterVerificationGasLimit?: bigint | undefined\n      }\n  >\n>\n\nexport type GetPaymasterDataErrorType =\n  | FormatUserOperationRequestErrorType\n  | ErrorType\n\n/**\n * Retrieves paymaster-related User Operation properties to be used for sending the User Operation.\n *\n * - Docs: https://viem.sh/account-abstraction/actions/paymaster/getPaymasterData\n *\n * @param client - Client to use\n * @param parameters - {@link GetPaymasterDataParameters}\n * @returns Paymaster-related User Operation properties. {@link GetPaymasterDataReturnType}\n *\n * @example\n * import { http } from 'viem'\n * import { createPaymasterClient, getPaymasterData } from 'viem/account-abstraction'\n *\n * const paymasterClient = createPaymasterClient({\n *   transport: http('https://...'),\n * })\n *\n * const userOperation = { ... }\n *\n * const values = await getPaymasterData(paymasterClient, {\n *   chainId: 1,\n *   entryPointAddress: '0x...',\n *   ...userOperation,\n * })\n */\nexport async function getPaymasterData(\n  client: Client<Transport>,\n  parameters: GetPaymasterDataParameters,\n): Promise<GetPaymasterDataReturnType> {\n  const { chainId, entryPointAddress, context, ...userOperation } = parameters\n  const request = formatUserOperationRequest(userOperation)\n  const { paymasterPostOpGasLimit, paymasterVerificationGasLimit, ...rest } =\n    await client.request({\n      method: 'pm_getPaymasterData',\n      params: [\n        {\n          ...request,\n          callGasLimit: request.callGasLimit ?? '0x0',\n          verificationGasLimit: request.verificationGasLimit ?? '0x0',\n          preVerificationGas: request.preVerificationGas ?? '0x0',\n        },\n        entryPointAddress,\n        numberToHex(chainId),\n        context,\n      ],\n    })\n  return {\n    ...rest,\n    ...(paymasterPostOpGasLimit && {\n      paymasterPostOpGasLimit: hexToBigInt(paymasterPostOpGasLimit),\n    }),\n    ...(paymasterVerificationGasLimit && {\n      paymasterVerificationGasLimit: hexToBigInt(paymasterVerificationGasLimit),\n    }),\n  } as unknown as GetPaymasterDataReturnType\n}\n", "import type { Address } from 'abitype'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Hex } from '../../../types/misc.js'\nimport type { OneOf, PartialBy, Prettify } from '../../../types/utils.js'\nimport { hexToBigInt } from '../../../utils/encoding/fromHex.js'\nimport { numberToHex } from '../../../utils/encoding/toHex.js'\nimport type { UserOperation } from '../../types/userOperation.js'\nimport {\n  type FormatUserOperationRequestErrorType,\n  formatUserOperationRequest,\n} from '../../utils/formatters/userOperationRequest.js'\n\nexport type GetPaymasterStubDataParameters = OneOf<\n  | PartialBy<\n      Pick<\n        UserOperation<'0.6'>,\n        | 'callData'\n        | 'callGasLimit'\n        | 'initCode'\n        | 'maxFeePerGas'\n        | 'maxPriorityFeePerGas'\n        | 'nonce'\n        | 'sender'\n        | 'preVerificationGas'\n        | 'verificationGasLimit'\n      >,\n      | 'callGasLimit'\n      | 'initCode'\n      | 'maxFeePerGas'\n      | 'maxPriorityFeePerGas'\n      | 'preVerificationGas'\n      | 'verificationGasLimit'\n    >\n  | PartialBy<\n      Pick<\n        UserOperation<'0.7'>,\n        | 'callData'\n        | 'callGasLimit'\n        | 'factory'\n        | 'factoryData'\n        | 'maxFeePerGas'\n        | 'maxPriorityFeePerGas'\n        | 'nonce'\n        | 'sender'\n        | 'preVerificationGas'\n        | 'verificationGasLimit'\n      >,\n      | 'callGasLimit'\n      | 'factory'\n      | 'factoryData'\n      | 'maxFeePerGas'\n      | 'maxPriorityFeePerGas'\n      | 'preVerificationGas'\n      | 'verificationGasLimit'\n    >\n> & {\n  context?: unknown | undefined\n  chainId: number\n  entryPointAddress: Address\n}\n\nexport type GetPaymasterStubDataReturnType = Prettify<\n  OneOf<\n    | { paymasterAndData: Hex }\n    | {\n        paymaster: Address\n        paymasterData: Hex\n        paymasterVerificationGasLimit?: bigint | undefined\n        paymasterPostOpGasLimit: bigint\n      }\n  > & {\n    sponsor?: { name: string; icon?: string | undefined } | undefined\n    isFinal?: boolean | undefined\n  }\n>\n\nexport type GetPaymasterStubDataErrorType =\n  | FormatUserOperationRequestErrorType\n  | ErrorType\n\n/**\n * Retrieves paymaster-related User Operation properties to be used for gas estimation.\n *\n * - Docs: https://viem.sh/account-abstraction/actions/paymaster/getPaymasterStubData\n *\n * @param client - Client to use\n * @param parameters - {@link GetPaymasterStubDataParameters}\n * @returns Paymaster-related User Operation properties. {@link GetPaymasterStubDataReturnType}\n *\n * @example\n * import { http } from 'viem'\n * import { createPaymasterClient, getPaymasterStubData } from 'viem/account-abstraction'\n *\n * const paymasterClient = createPaymasterClient({\n *   transport: http('https://...'),\n * })\n *\n * const userOperation = { ... }\n *\n * const values = await getPaymasterStubData(paymasterClient, {\n *   chainId: 1,\n *   entryPointAddress: '0x...',\n *   ...userOperation,\n * })\n */\nexport async function getPaymasterStubData(\n  client: Client<Transport>,\n  parameters: GetPaymasterStubDataParameters,\n): Promise<GetPaymasterStubDataReturnType> {\n  const { chainId, entryPointAddress, context, ...userOperation } = parameters\n  const request = formatUserOperationRequest(userOperation)\n  const { paymasterPostOpGasLimit, paymasterVerificationGasLimit, ...rest } =\n    await client.request({\n      method: 'pm_getPaymasterStubData',\n      params: [\n        {\n          ...request,\n          callGasLimit: request.callGasLimit ?? '0x0',\n          verificationGasLimit: request.verificationGasLimit ?? '0x0',\n          preVerificationGas: request.preVerificationGas ?? '0x0',\n        },\n        entryPointAddress,\n        numberToHex(chainId),\n        context,\n      ],\n    })\n  return {\n    ...rest,\n    ...(paymasterPostOpGasLimit && {\n      paymasterPostOpGasLimit: hexToBigInt(paymasterPostOpGasLimit),\n    }),\n    ...(paymasterVerificationGasLimit && {\n      paymasterVerificationGasLimit: hexToBigInt(paymasterVerificationGasLimit),\n    }),\n  } as unknown as GetPaymasterStubDataReturnType\n}\n", "import type { Address } from 'abitype'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { RequestErrorType } from '../../../utils/buildRequest.js'\n\nexport type GetSupportedEntryPointsReturnType = readonly Address[]\nexport type GetSupportedEntryPointsErrorType = RequestErrorType | ErrorType\n\n/**\n * Returns the EntryPoints that the bundler supports.\n *\n * - Docs: https://viem.sh/actions/bundler/getSupportedEntryPoints\n *\n * @param client - Client to use\n * @param parameters - {@link GetSupportedEntryPointsParameters}\n * @returns Supported Entry Points. {@link GetSupportedEntryPointsReturnType}\n *\n * @example\n * import { createBundlerClient, http, parseEther } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getSupportedEntryPoints } from 'viem/actions'\n *\n * const bundlerClient = createBundlerClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const addresses = await getSupportedEntryPoints(bundlerClient)\n */\nexport function getSupportedEntryPoints(client: Client<Transport>) {\n  return client.request({ method: 'eth_supportedEntryPoints' })\n}\n", "import type { Address } from 'abitype'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Hash } from '../../../types/misc.js'\nimport type { Prettify } from '../../../types/utils.js'\nimport type { RequestErrorType } from '../../../utils/buildRequest.js'\nimport {\n  UserOperationNotFoundError,\n  type UserOperationNotFoundErrorType,\n} from '../../errors/userOperation.js'\nimport type { UserOperation } from '../../types/userOperation.js'\nimport { formatUserOperation } from '../../utils/formatters/userOperation.js'\n\nexport type GetUserOperationParameters = {\n  /** The hash of the User Operation. */\n  hash: Hash\n}\n\nexport type GetUserOperationReturnType = Prettify<{\n  /** The block hash the User Operation was included on. */\n  blockHash: Hash\n  /** The block number the User Operation was included on. */\n  blockNumber: bigint\n  /** The EntryPoint which handled the User Operation. */\n  entryPoint: Address\n  /** The hash of the transaction which included the User Operation. */\n  transactionHash: Hash\n  /** The User Operation. */\n  userOperation: UserOperation\n}>\n\nexport type GetUserOperationErrorType =\n  | RequestErrorType\n  | UserOperationNotFoundErrorType\n  | ErrorType\n\n/**\n * Retrieves information about a User Operation given a hash.\n *\n * - Docs: https://viem.sh/account-abstraction/actions/bundler/getUserOperation\n *\n * @param client - Client to use\n * @param parameters - {@link GetUserOperationParameters}\n * @returns The receipt. {@link GetUserOperationReturnType}\n *\n * @example\n * import { createBundlerClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getUserOperation } from 'viem/actions\n *\n * const client = createBundlerClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const receipt = await getUserOperation(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport async function getUserOperation(\n  client: Client<Transport>,\n  { hash }: GetUserOperationParameters,\n) {\n  const result = await client.request(\n    {\n      method: 'eth_getUserOperationByHash',\n      params: [hash],\n    },\n    { dedupe: true },\n  )\n\n  if (!result) throw new UserOperationNotFoundError({ hash })\n\n  const { blockHash, blockNumber, entryPoint, transactionHash, userOperation } =\n    result\n\n  return {\n    blockHash,\n    blockNumber: BigInt(blockNumber),\n    entryPoint,\n    transactionHash,\n    userOperation: formatUserOperation(userOperation),\n  }\n}\n", "import type { ErrorType } from '../../../errors/utils.js'\nimport type { RpcUserOperation } from '../../types/rpc.js'\nimport type { UserOperation } from '../../types/userOperation.js'\n\nexport type FormatUserOperationErrorType = ErrorType\n\nexport function formatUserOperation(parameters: RpcUserOperation) {\n  const userOperation = { ...parameters } as unknown as UserOperation\n\n  if (parameters.callGasLimit)\n    userOperation.callGasLimit = BigInt(parameters.callGasLimit)\n  if (parameters.maxFeePerGas)\n    userOperation.maxFeePerGas = BigInt(parameters.maxFeePerGas)\n  if (parameters.maxPriorityFeePerGas)\n    userOperation.maxPriorityFeePerGas = BigInt(parameters.maxPriorityFeePerGas)\n  if (parameters.nonce) userOperation.nonce = BigInt(parameters.nonce)\n  if (parameters.paymasterPostOpGasLimit)\n    userOperation.paymasterPostOpGasLimit = BigInt(\n      parameters.paymasterPostOpGasLimit,\n    )\n  if (parameters.paymasterVerificationGasLimit)\n    userOperation.paymasterVerificationGasLimit = BigInt(\n      parameters.paymasterVerificationGasLimit,\n    )\n  if (parameters.preVerificationGas)\n    userOperation.preVerificationGas = BigInt(parameters.preVerificationGas)\n  if (parameters.verificationGasLimit)\n    userOperation.verificationGasLimit = BigInt(parameters.verificationGasLimit)\n\n  return userOperation\n}\n", "import type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Hash } from '../../../types/misc.js'\nimport type { Prettify } from '../../../types/utils.js'\nimport type { RequestErrorType } from '../../../utils/buildRequest.js'\nimport {\n  UserOperationReceiptNotFoundError,\n  type UserOperationReceiptNotFoundErrorType,\n} from '../../errors/userOperation.js'\nimport type { UserOperationReceipt } from '../../types/userOperation.js'\nimport { formatUserOperationReceipt } from '../../utils/formatters/userOperationReceipt.js'\n\nexport type GetUserOperationReceiptParameters = {\n  /** The hash of the User Operation. */\n  hash: Hash\n}\n\nexport type GetUserOperationReceiptReturnType = Prettify<UserOperationReceipt>\n\nexport type GetUserOperationReceiptErrorType =\n  | RequestErrorType\n  | UserOperationReceiptNotFoundErrorType\n  | ErrorType\n\n/**\n * Returns the User Operation Receipt given a User Operation hash.\n *\n * - Docs: https://viem.sh/docs/actions/bundler/getUserOperationReceipt\n *\n * @param client - Client to use\n * @param parameters - {@link GetUserOperationReceiptParameters}\n * @returns The receipt. {@link GetUserOperationReceiptReturnType}\n *\n * @example\n * import { createBundlerClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getUserOperationReceipt } from 'viem/actions\n *\n * const client = createBundlerClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const receipt = await getUserOperationReceipt(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport async function getUserOperationReceipt(\n  client: Client<Transport>,\n  { hash }: GetUserOperationReceiptParameters,\n) {\n  const receipt = await client.request(\n    {\n      method: 'eth_getUserOperationReceipt',\n      params: [hash],\n    },\n    { dedupe: true },\n  )\n\n  if (!receipt) throw new UserOperationReceiptNotFoundError({ hash })\n\n  return formatUserOperationReceipt(receipt)\n}\n", "import type { ErrorType } from '../../../errors/utils.js'\nimport { formatLog } from '../../../utils/formatters/log.js'\nimport { formatTransactionReceipt } from '../../../utils/formatters/transactionReceipt.js'\nimport type { RpcUserOperationReceipt } from '../../types/rpc.js'\nimport type { UserOperationReceipt } from '../../types/userOperation.js'\n\nexport type FormatUserOperationReceiptErrorType = ErrorType\n\nexport function formatUserOperationReceipt(\n  parameters: RpcUserOperationReceipt,\n) {\n  const receipt = { ...parameters } as unknown as UserOperationReceipt\n\n  if (parameters.actualGasCost)\n    receipt.actualGasCost = BigInt(parameters.actualGasCost)\n  if (parameters.actualGasUsed)\n    receipt.actualGasUsed = BigInt(parameters.actualGasUsed)\n  if (parameters.logs)\n    receipt.logs = parameters.logs.map((log) => formatLog(log)) as any\n  if (parameters.receipt)\n    receipt.receipt = formatTransactionReceipt(receipt.receipt as any)\n\n  return receipt\n}\n", "import type { Address, Narrow } from 'abitype'\nimport { parseAccount } from '../../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport { AccountNotFoundError } from '../../../errors/account.js'\nimport type { BaseError } from '../../../errors/base.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Calls } from '../../../types/calls.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type { Hex } from '../../../types/misc.js'\nimport type { Assign, MaybeRequired, OneOf } from '../../../types/utils.js'\nimport type { RequestErrorType } from '../../../utils/buildRequest.js'\nimport { getAction } from '../../../utils/getAction.js'\nimport type { SmartAccount } from '../../accounts/types.js'\nimport type { PaymasterActions } from '../../clients/decorators/paymaster.js'\nimport type {\n  DeriveSmartAccount,\n  GetSmartAccountParameter,\n} from '../../types/account.js'\nimport type {\n  DeriveEntryPointVersion,\n  EntryPointVersion,\n} from '../../types/entryPointVersion.js'\nimport type {\n  UserOperation,\n  UserOperationRequest,\n} from '../../types/userOperation.js'\nimport { getUserOperationError } from '../../utils/errors/getUserOperationError.js'\nimport {\n  type FormatUserOperationRequestErrorType,\n  formatUserOperationRequest,\n} from '../../utils/formatters/userOperationRequest.js'\nimport {\n  type PrepareUserOperationErrorType,\n  type PrepareUserOperationParameters,\n  prepareUserOperation,\n} from './prepareUserOperation.js'\n\nexport type SendUserOperationParameters<\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = SmartAccount | undefined,\n  calls extends readonly unknown[] = readonly unknown[],\n  //\n  _derivedAccount extends SmartAccount | undefined = DeriveSmartAccount<\n    account,\n    accountOverride\n  >,\n  _derivedVersion extends\n    EntryPointVersion = DeriveEntryPointVersion<_derivedAccount>,\n> = GetSmartAccountParameter<account, accountOverride, false> &\n  (\n    | UserOperation // Accept a full-formed User Operation.\n    | Assign<\n        // Accept a partially-formed User Operation (UserOperationRequest) to be filled.\n        UserOperationRequest<_derivedVersion>,\n        OneOf<{ calls: Calls<Narrow<calls>> } | { callData: Hex }> & {\n          paymaster?:\n            | Address\n            | true\n            | {\n                /** Retrieves paymaster-related User Operation properties to be used for sending the User Operation. */\n                getPaymasterData?:\n                  | PaymasterActions['getPaymasterData']\n                  | undefined\n                /** Retrieves paymaster-related User Operation properties to be used for gas estimation. */\n                getPaymasterStubData?:\n                  | PaymasterActions['getPaymasterStubData']\n                  | undefined\n              }\n            | undefined\n          /** Paymaster context to pass to `getPaymasterData` and `getPaymasterStubData` calls. */\n          paymasterContext?: unknown | undefined\n        }\n      >\n  ) &\n  // Allow the EntryPoint address to be overridden, if no Account is provided, it will need to be required.\n  MaybeRequired<\n    { entryPointAddress?: Address },\n    _derivedAccount extends undefined ? true : false\n  >\nexport type SendUserOperationReturnType = Hex\n\nexport type SendUserOperationErrorType =\n  | FormatUserOperationRequestErrorType\n  | PrepareUserOperationErrorType\n  | RequestErrorType\n  | ErrorType\n\n/**\n * Broadcasts a User Operation to the Bundler.\n *\n * - Docs: https://viem.sh/actions/bundler/sendUserOperation\n *\n * @param client - Client to use\n * @param parameters - {@link SendUserOperationParameters}\n * @returns The User Operation hash. {@link SendUserOperationReturnType}\n *\n * @example\n * import { createBundlerClient, http, parseEther } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { toSmartAccount } from 'viem/accounts'\n * import { sendUserOperation } from 'viem/actions'\n *\n * const account = await toSmartAccount({ ... })\n *\n * const bundlerClient = createBundlerClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const values = await sendUserOperation(bundlerClient, {\n *   account,\n *   calls: [{ to: '0x...', value: parseEther('1') }],\n * })\n */\nexport async function sendUserOperation<\n  const calls extends readonly unknown[],\n  account extends SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = undefined,\n>(\n  client: Client<Transport, Chain | undefined, account>,\n  parameters: SendUserOperationParameters<account, accountOverride, calls>,\n) {\n  const { account: account_ = client.account, entryPointAddress } = parameters\n\n  if (!account_ && !parameters.sender) throw new AccountNotFoundError()\n  const account = account_ ? parseAccount(account_) : undefined\n\n  const request = account\n    ? await getAction(\n        client,\n        prepareUserOperation,\n        'prepareUserOperation',\n      )(parameters as unknown as PrepareUserOperationParameters)\n    : parameters\n\n  const signature = (parameters.signature ||\n    (await account?.signUserOperation?.(request as UserOperation)))!\n\n  const rpcParameters = formatUserOperationRequest({\n    ...request,\n    signature,\n  } as UserOperation)\n\n  try {\n    return await client.request(\n      {\n        method: 'eth_sendUserOperation',\n        params: [\n          rpcParameters,\n          (entryPointAddress ?? account?.entryPoint?.address)!,\n        ],\n      },\n      { retryCount: 0 },\n    )\n  } catch (error) {\n    const calls = (parameters as any).calls\n    throw getUserOperationError(error as BaseError, {\n      ...(request as UserOperation),\n      ...(calls ? { calls } : {}),\n      signature,\n    })\n  }\n}\n", "import type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Hash } from '../../../types/misc.js'\nimport type { Prettify } from '../../../types/utils.js'\nimport { getAction } from '../../../utils/getAction.js'\nimport { type ObserveErrorType, observe } from '../../../utils/observe.js'\nimport { type PollErrorType, poll } from '../../../utils/poll.js'\nimport { stringify } from '../../../utils/stringify.js'\nimport {\n  WaitForUserOperationReceiptTimeoutError,\n  type WaitForUserOperationReceiptTimeoutErrorType,\n} from '../../errors/userOperation.js'\nimport type { UserOperationReceipt } from '../../types/userOperation.js'\nimport {\n  type GetUserOperationReceiptErrorType,\n  getUserOperationReceipt,\n} from './getUserOperationReceipt.js'\n\nexport type WaitForUserOperationReceiptParameters = {\n  /** The hash of the User Operation. */\n  hash: Hash\n  /**\n   * Polling frequency (in ms). Defaults to the client's pollingInterval config.\n   * @default client.pollingInterval\n   */\n  pollingInterval?: number | undefined\n  /**\n   * The number of times to retry.\n   * @default 6\n   */\n  retryCount?: number | undefined\n  /** Optional timeout (in ms) to wait before stopping polling. */\n  timeout?: number | undefined\n}\n\nexport type WaitForUserOperationReceiptReturnType =\n  Prettify<UserOperationReceipt>\n\nexport type WaitForUserOperationReceiptErrorType =\n  | WaitForUserOperationReceiptTimeoutErrorType\n  | PollErrorType\n  | ObserveErrorType\n  | ErrorType\n\n/**\n * Waits for the User Operation to be included on a [Block](https://viem.sh/docs/glossary/terms#block) (one confirmation), and then returns the User Operation receipt.\n *\n * - Docs: https://viem.sh/docs/actions/bundler/waitForUserOperationReceipt\n *\n * @param client - Client to use\n * @param parameters - {@link WaitForUserOperationReceiptParameters}\n * @returns The receipt. {@link WaitForUserOperationReceiptReturnType}\n *\n * @example\n * import { createBundlerClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { waitForUserOperationReceipt } from 'viem/actions'\n *\n * const client = createBundlerClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const receipt = await waitForUserOperationReceipt(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport function waitForUserOperationReceipt(\n  client: Client<Transport>,\n  parameters: WaitForUserOperationReceiptParameters,\n): Promise<WaitForUserOperationReceiptReturnType> {\n  const {\n    hash,\n    pollingInterval = client.pollingInterval,\n    retryCount,\n    timeout = 120_000,\n  } = parameters\n\n  let count = 0\n  const observerId = stringify([\n    'waitForUserOperationReceipt',\n    client.uid,\n    hash,\n  ])\n\n  return new Promise((resolve, reject) => {\n    const unobserve = observe(observerId, { resolve, reject }, (emit) => {\n      const done = (fn: () => void) => {\n        unpoll()\n        fn()\n        unobserve()\n      }\n\n      const timeoutId = timeout\n        ? setTimeout(\n            () =>\n              done(() =>\n                emit.reject(\n                  new WaitForUserOperationReceiptTimeoutError({ hash }),\n                ),\n              ),\n            timeout,\n          )\n        : undefined\n\n      const unpoll = poll(\n        async () => {\n          if (retryCount && count >= retryCount) {\n            clearTimeout(timeoutId)\n            done(() =>\n              emit.reject(\n                new WaitForUserOperationReceiptTimeoutError({ hash }),\n              ),\n            )\n          }\n\n          try {\n            const receipt = await getAction(\n              client,\n              getUserOperationReceipt,\n              'getUserOperationReceipt',\n            )({ hash })\n            done(() => emit.resolve(receipt))\n          } catch (err) {\n            const error = err as GetUserOperationReceiptErrorType\n            if (error.name !== 'UserOperationReceiptNotFoundError')\n              done(() => emit.reject(error))\n          } finally {\n            clearTimeout(timeoutId)\n          }\n\n          count++\n        },\n        {\n          emitOnBegin: true,\n          interval: pollingInterval,\n        },\n      )\n\n      return unpoll\n    })\n  })\n}\n", "// biome-ignore lint/performance/noBarrelFile: entrypoint\nexport {\n  type CreateWebAuthnCredentialParameters,\n  type CreateWebAuthnCredentialReturnType,\n  createWebAuthnCredential,\n  type P256Credential,\n} from './accounts/createWebAuthnCredential.js'\nexport {\n  type CoinbaseSmartAccountImplementation,\n  type ToCoinbaseSmartAccountParameters,\n  type ToCoinbaseSmartAccountReturnType,\n  toCoinbaseSmartAccount,\n} from './accounts/implementations/toCoinbaseSmartAccount.js'\nexport {\n  type Simple7702SmartAccountImplementation,\n  type ToSimple7702SmartAccountParameters,\n  type ToSimple7702SmartAccountReturnType,\n  toSimple7702SmartAccount,\n} from './accounts/implementations/toSimple7702SmartAccount.js'\nexport {\n  type SoladySmartAccountImplementation,\n  type ToSoladySmartAccountParameters,\n  type ToSoladySmartAccountReturnType,\n  toSoladySmartAccount,\n} from './accounts/implementations/toSoladySmartAccount.js'\nexport {\n  type ToSmartAccountParameters,\n  type ToSmartAccountReturnType,\n  toSmartAccount,\n} from './accounts/toSmartAccount.js'\nexport {\n  type ToWebAuthnAccountErrorType,\n  type ToWebAuthnAccountParameters,\n  type ToWebAuthnAccountReturnType,\n  toWebAuthnAccount,\n} from './accounts/toWebAuthnAccount.js'\nexport type {\n  SmartAccount,\n  SmartAccountImplementation,\n  WebAuthnAccount,\n  WebAuthnSignReturnType,\n} from './accounts/types.js'\n\nexport {\n  type EstimateUserOperationGasErrorType,\n  type EstimateUserOperationGasParameters,\n  type EstimateUserOperationGasReturnType,\n  estimateUserOperationGas,\n} from './actions/bundler/estimateUserOperationGas.js'\nexport {\n  type GetSupportedEntryPointsErrorType,\n  type GetSupportedEntryPointsReturnType,\n  getSupportedEntryPoints,\n} from './actions/bundler/getSupportedEntryPoints.js'\nexport {\n  type GetUserOperationErrorType,\n  type GetUserOperationParameters,\n  type GetUserOperationReturnType,\n  getUserOperation,\n} from './actions/bundler/getUserOperation.js'\nexport {\n  type GetUserOperationReceiptErrorType,\n  type GetUserOperationReceiptParameters,\n  type GetUserOperationReceiptReturnType,\n  getUserOperationReceipt,\n} from './actions/bundler/getUserOperationReceipt.js'\nexport {\n  type PrepareUserOperationErrorType,\n  type PrepareUserOperationParameters,\n  type PrepareUserOperationParameterType,\n  type PrepareUserOperationRequest,\n  type PrepareUserOperationReturnType,\n  prepareUserOperation,\n} from './actions/bundler/prepareUserOperation.js'\nexport {\n  type SendUserOperationErrorType,\n  type SendUserOperationParameters,\n  type SendUserOperationReturnType,\n  sendUserOperation,\n} from './actions/bundler/sendUserOperation.js'\nexport {\n  type WaitForUserOperationReceiptErrorType,\n  type WaitForUserOperationReceiptParameters,\n  type WaitForUserOperationReceiptReturnType,\n  waitForUserOperationReceipt,\n} from './actions/bundler/waitForUserOperationReceipt.js'\n\nexport {\n  type GetPaymasterDataErrorType,\n  type GetPaymasterDataParameters,\n  type GetPaymasterDataReturnType,\n  getPaymasterData,\n} from './actions/paymaster/getPaymasterData.js'\nexport {\n  type GetPaymasterStubDataErrorType,\n  type GetPaymasterStubDataParameters,\n  type GetPaymasterStubDataReturnType,\n  getPaymasterStubData,\n} from './actions/paymaster/getPaymasterStubData.js'\nexport {\n  type BundlerClient,\n  type BundlerClientConfig,\n  type CreateBundlerClientErrorType,\n  createBundlerClient,\n} from './clients/createBundlerClient.js'\nexport {\n  type CreatePaymasterClientErrorType,\n  createPaymasterClient,\n  type PaymasterClient,\n  type PaymasterClientConfig,\n} from './clients/createPaymasterClient.js'\nexport {\n  type BundlerActions,\n  bundlerActions,\n} from './clients/decorators/bundler.js'\nexport {\n  type PaymasterActions,\n  paymasterActions,\n} from './clients/decorators/paymaster.js'\n\nexport {\n  entryPoint06Abi,\n  entryPoint07Abi,\n  entryPoint08Abi,\n} from './constants/abis.js'\nexport {\n  entryPoint06Address,\n  entryPoint07Address,\n  entryPoint08Address,\n} from './constants/address.js'\n\nexport {\n  AccountNotDeployedError,\n  type AccountNotDeployedErrorType,\n  FailedToSendToBeneficiaryError,\n  type FailedToSendToBeneficiaryErrorType,\n  GasValuesOverflowError,\n  type GasValuesOverflowErrorType,\n  HandleOpsOutOfGasError,\n  type HandleOpsOutOfGasErrorType,\n  InitCodeFailedError,\n  type InitCodeFailedErrorType,\n  InitCodeMustCreateSenderError,\n  type InitCodeMustCreateSenderErrorType,\n  InitCodeMustReturnSenderError,\n  type InitCodeMustReturnSenderErrorType,\n  InsufficientPrefundError,\n  type InsufficientPrefundErrorType,\n  InternalCallOnlyError,\n  type InternalCallOnlyErrorType,\n  InvalidAggregatorError,\n  type InvalidAggregatorErrorType,\n  InvalidBeneficiaryError,\n  type InvalidBeneficiaryErrorType,\n  InvalidPaymasterAndDataError,\n  type InvalidPaymasterAndDataErrorType,\n  PaymasterDepositTooLowError,\n  type PaymasterDepositTooLowErrorType,\n  PaymasterFunctionRevertedError,\n  type PaymasterFunctionRevertedErrorType,\n  PaymasterNotDeployedError,\n  type PaymasterNotDeployedErrorType,\n  PaymasterPostOpFunctionRevertedError,\n  type PaymasterPostOpFunctionRevertedErrorType,\n  SenderAlreadyConstructedError,\n  type SenderAlreadyConstructedErrorType,\n  SmartAccountFunctionRevertedError,\n  type SmartAccountFunctionRevertedErrorType,\n  UnknownBundlerError,\n  type UnknownBundlerErrorType,\n  UserOperationExpiredError,\n  type UserOperationExpiredErrorType,\n  UserOperationPaymasterExpiredError,\n  type UserOperationPaymasterExpiredErrorType,\n  UserOperationPaymasterSignatureError,\n  type UserOperationPaymasterSignatureErrorType,\n  UserOperationSignatureError,\n  type UserOperationSignatureErrorType,\n  VerificationGasLimitExceededError,\n  type VerificationGasLimitExceededErrorType,\n  VerificationGasLimitTooLowError,\n  type VerificationGasLimitTooLowErrorType,\n} from './errors/bundler.js'\nexport {\n  UserOperationExecutionError,\n  type UserOperationExecutionErrorType,\n  UserOperationNotFoundError,\n  type UserOperationNotFoundErrorType,\n  UserOperationReceiptNotFoundError,\n  type UserOperationReceiptNotFoundErrorType,\n  WaitForUserOperationReceiptTimeoutError,\n  type WaitForUserOperationReceiptTimeoutErrorType,\n} from './errors/userOperation.js'\n\nexport type {\n  DeriveSmartAccount,\n  GetSmartAccountParameter,\n} from './types/account.js'\nexport type {\n  DeriveEntryPointVersion,\n  EntryPointVersion,\n  GetEntryPointVersionParameter,\n} from './types/entryPointVersion.js'\nexport type {\n  RpcEstimateUserOperationGasReturnType,\n  RpcGetUserOperationByHashReturnType,\n  RpcUserOperation,\n  RpcUserOperationReceipt,\n  RpcUserOperationRequest,\n} from './types/rpc.js'\nexport type {\n  PackedUserOperation,\n  UserOperation,\n  UserOperationReceipt,\n  UserOperationRequest,\n} from './types/userOperation.js'\n\nexport {\n  type GetBundlerErrorParameters,\n  type GetBundlerErrorReturnType,\n  getBundlerError,\n} from './utils/errors/getBundlerError.js'\nexport {\n  type GetUserOperationErrorErrorType,\n  type GetUserOperationErrorParameters,\n  type GetUserOperationErrorReturnType,\n  getUserOperationError,\n} from './utils/errors/getUserOperationError.js'\nexport {\n  type FormatUserOperationErrorType,\n  formatUserOperation,\n} from './utils/formatters/userOperation.js'\nexport {\n  type FormatUserOperationGasErrorType,\n  formatUserOperationGas,\n} from './utils/formatters/userOperationGas.js'\nexport {\n  type FormatUserOperationReceiptErrorType,\n  formatUserOperationReceipt,\n} from './utils/formatters/userOperationReceipt.js'\nexport {\n  type FormatUserOperationRequestErrorType,\n  formatUserOperationRequest,\n} from './utils/formatters/userOperationRequest.js'\nexport {\n  type GetUserOperationHashParameters,\n  type GetUserOperationHashReturnType,\n  getUserOperationHash,\n} from './utils/userOperation/getUserOperationHash.js'\nexport {\n  type GetUserOperationTypedDataParameters,\n  type GetUserOperationTypedDataReturnType,\n  getUserOperationTypedData,\n} from './utils/userOperation/getUserOperationTypedData.js'\nexport { toPackedUserOperation } from './utils/userOperation/toPackedUserOperation.js'\nexport { toUserOperation } from './utils/userOperation/toUserOperation.js'\n", "// TODO(v3): Remove this in favor of `ox/WebAuthnP256` entirely.\nimport * as PublicKey from 'ox/PublicKey'\nimport * as WebAuthnP256 from 'ox/WebAuthnP256'\n\nimport type { Hex } from '../../types/misc.js'\n\nexport type P256Credential = {\n  id: WebAuthnP256.P256Credential['id']\n  publicKey: Hex\n  raw: WebAuthnP256.P256Credential['raw']\n}\n\nexport type CreateWebAuthnCredentialParameters =\n  WebAuthnP256.createCredential.Options\n\nexport type CreateWebAuthnCredentialReturnType = P256Credential\n\nexport async function createWebAuthnCredential(\n  parameters: CreateWebAuthnCredentialParameters,\n): Promise<CreateWebAuthnCredentialReturnType> {\n  const credential = await WebAuthnP256.createCredential(parameters)\n  return {\n    id: credential.id,\n    publicKey: PublicKey.toHex(credential.publicKey, { includePrefix: false }),\n    raw: credential.raw,\n  }\n}\n", "import type { Address, TypedData } from 'abitype'\nimport * as Signature from 'ox/Signature'\nimport type * as WebAuthnP256 from 'ox/WebAuthnP256'\n\nimport type { LocalAccount } from '../../../accounts/types.js'\nimport { readContract } from '../../../actions/public/readContract.js'\nimport { entryPoint06Address } from '../../../constants/address.js'\nimport { BaseError } from '../../../errors/base.js'\nimport type { Hash, Hex } from '../../../types/misc.js'\nimport type { TypedDataDefinition } from '../../../types/typedData.js'\nimport type { Assign, OneOf, Prettify } from '../../../types/utils.js'\nimport { decodeFunctionData } from '../../../utils/abi/decodeFunctionData.js'\nimport { encodeAbiParameters } from '../../../utils/abi/encodeAbiParameters.js'\nimport { encodeFunctionData } from '../../../utils/abi/encodeFunctionData.js'\nimport { encodePacked } from '../../../utils/abi/encodePacked.js'\nimport { pad } from '../../../utils/data/pad.js'\nimport { size } from '../../../utils/data/size.js'\nimport { stringToHex } from '../../../utils/encoding/toHex.js'\nimport { hashMessage } from '../../../utils/signature/hashMessage.js'\nimport { hashTypedData } from '../../../utils/signature/hashTypedData.js'\nimport { parseSignature } from '../../../utils/signature/parseSignature.js'\nimport { entryPoint06Abi } from '../../constants/abis.js'\nimport type { UserOperation } from '../../types/userOperation.js'\nimport { getUserOperationHash } from '../../utils/userOperation/getUserOperationHash.js'\nimport { toSmartAccount } from '../toSmartAccount.js'\nimport type {\n  SmartAccount,\n  SmartAccountImplementation,\n  WebAuthnAccount,\n} from '../types.js'\n\nexport type ToCoinbaseSmartAccountParameters = {\n  address?: Address | undefined\n  client: CoinbaseSmartAccountImplementation['client']\n  ownerIndex?: number | undefined\n  owners: readonly (Address | OneOf<LocalAccount | WebAuthnAccount>)[]\n  nonce?: bigint | undefined\n  version: '1.1' | '1'\n}\n\nexport type ToCoinbaseSmartAccountReturnType = Prettify<\n  SmartAccount<CoinbaseSmartAccountImplementation>\n>\n\nexport type CoinbaseSmartAccountImplementation = Assign<\n  SmartAccountImplementation<\n    typeof entryPoint06Abi,\n    '0.6',\n    { abi: typeof abi; factory: { abi: typeof factoryAbi; address: Address } }\n  >,\n  {\n    decodeCalls: NonNullable<SmartAccountImplementation['decodeCalls']>\n    sign: NonNullable<SmartAccountImplementation['sign']>\n  }\n>\n\nconst factoryAddress = {\n  '1.1': '0xba5ed110efdba3d005bfc882d75358acbbb85842',\n  '1': '0x0ba5ed0c6aa8c49038f819e587e2633c4a9f428a',\n} as const\n\n/**\n * @description Create a Coinbase Smart Account.\n *\n * @param parameters - {@link ToCoinbaseSmartAccountParameters}\n * @returns Coinbase Smart Account. {@link ToCoinbaseSmartAccountReturnType}\n *\n * @example\n * import { toCoinbaseSmartAccount } from 'viem/account-abstraction'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { client } from './client.js'\n *\n * const account = toCoinbaseSmartAccount({\n *   client,\n *   owners: [privateKeyToAccount('0x...')],\n *   version: '1.1',\n * })\n */\nexport async function toCoinbaseSmartAccount(\n  parameters: ToCoinbaseSmartAccountParameters,\n): Promise<ToCoinbaseSmartAccountReturnType> {\n  const {\n    client,\n    ownerIndex = 0,\n    owners,\n    nonce = 0n,\n    version = '1',\n  } = parameters\n\n  let address = parameters.address\n\n  const entryPoint = {\n    abi: entryPoint06Abi,\n    address: entryPoint06Address,\n    version: '0.6',\n  } as const\n  const factory = {\n    abi: factoryAbi,\n    address: factoryAddress[version],\n  } as const\n\n  const owners_bytes = owners.map((owner) => {\n    if (typeof owner === 'string') return pad(owner)\n    if (owner.type === 'webAuthn') return owner.publicKey\n    if (owner.type === 'local') return pad(owner.address)\n    throw new BaseError('invalid owner type')\n  })\n\n  const owner = (() => {\n    const owner = owners[ownerIndex] ?? owners[0]\n    if (typeof owner === 'string')\n      return { address: owner, type: 'address' } as const\n    return owner\n  })()\n\n  return toSmartAccount({\n    client,\n    entryPoint,\n\n    extend: { abi, factory },\n\n    async decodeCalls(data) {\n      const result = decodeFunctionData({\n        abi,\n        data,\n      })\n\n      if (result.functionName === 'execute')\n        return [\n          { to: result.args[0], value: result.args[1], data: result.args[2] },\n        ]\n      if (result.functionName === 'executeBatch')\n        return result.args[0].map((arg) => ({\n          to: arg.target,\n          value: arg.value,\n          data: arg.data,\n        }))\n      throw new BaseError(`unable to decode calls for \"${result.functionName}\"`)\n    },\n\n    async encodeCalls(calls) {\n      if (calls.length === 1)\n        return encodeFunctionData({\n          abi,\n          functionName: 'execute',\n          args: [calls[0].to, calls[0].value ?? 0n, calls[0].data ?? '0x'],\n        })\n      return encodeFunctionData({\n        abi,\n        functionName: 'executeBatch',\n        args: [\n          calls.map((call) => ({\n            data: call.data ?? '0x',\n            target: call.to,\n            value: call.value ?? 0n,\n          })),\n        ],\n      })\n    },\n\n    async getAddress() {\n      address ??= await readContract(client, {\n        ...factory,\n        functionName: 'getAddress',\n        args: [owners_bytes, nonce],\n      })\n      return address\n    },\n\n    async getFactoryArgs() {\n      const factoryData = encodeFunctionData({\n        abi: factory.abi,\n        functionName: 'createAccount',\n        args: [owners_bytes, nonce],\n      })\n      return { factory: factory.address, factoryData }\n    },\n\n    async getStubSignature() {\n      if (owner.type === 'webAuthn')\n        return '0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000170000000000000000000000000000000000000000000000000000000000000001949fc7c88032b9fcb5f6efc7a7b8c63668eae9871b765e23123bb473ff57aa831a7c0d9276168ebcc29f2875a0239cffdf2a9cd1c2007c5c77c071db9264df1d000000000000000000000000000000000000000000000000000000000000002549960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d97630500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008a7b2274797065223a22776562617574686e2e676574222c226368616c6c656e6765223a2273496a396e6164474850596759334b7156384f7a4a666c726275504b474f716d59576f4d57516869467773222c226f726967696e223a2268747470733a2f2f7369676e2e636f696e626173652e636f6d222c2263726f73734f726967696e223a66616c73657d00000000000000000000000000000000000000000000'\n      return wrapSignature({\n        ownerIndex,\n        signature:\n          '0xfffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c',\n      })\n    },\n\n    async sign(parameters) {\n      const address = await this.getAddress()\n\n      const typedData = toReplaySafeTypedData({\n        address,\n        chainId: client.chain!.id,\n        hash: parameters.hash,\n      })\n\n      if (owner.type === 'address') throw new Error('owner cannot sign')\n      const signature = await signTypedData({ owner, typedData })\n\n      return wrapSignature({\n        ownerIndex,\n        signature,\n      })\n    },\n\n    async signMessage(parameters) {\n      const { message } = parameters\n      const address = await this.getAddress()\n\n      const typedData = toReplaySafeTypedData({\n        address,\n        chainId: client.chain!.id,\n        hash: hashMessage(message),\n      })\n\n      if (owner.type === 'address') throw new Error('owner cannot sign')\n      const signature = await signTypedData({ owner, typedData })\n\n      return wrapSignature({\n        ownerIndex,\n        signature,\n      })\n    },\n\n    async signTypedData(parameters) {\n      const { domain, types, primaryType, message } =\n        parameters as TypedDataDefinition<TypedData, string>\n      const address = await this.getAddress()\n\n      const typedData = toReplaySafeTypedData({\n        address,\n        chainId: client.chain!.id,\n        hash: hashTypedData({\n          domain,\n          message,\n          primaryType,\n          types,\n        }),\n      })\n\n      if (owner.type === 'address') throw new Error('owner cannot sign')\n      const signature = await signTypedData({ owner, typedData })\n\n      return wrapSignature({\n        ownerIndex,\n        signature,\n      })\n    },\n\n    async signUserOperation(parameters) {\n      const { chainId = client.chain!.id, ...userOperation } = parameters\n\n      const address = await this.getAddress()\n      const hash = getUserOperationHash({\n        chainId,\n        entryPointAddress: entryPoint.address,\n        entryPointVersion: entryPoint.version,\n        userOperation: {\n          ...(userOperation as unknown as UserOperation),\n          sender: address,\n        },\n      })\n\n      if (owner.type === 'address') throw new Error('owner cannot sign')\n      const signature = await sign({ hash, owner })\n\n      return wrapSignature({\n        ownerIndex,\n        signature,\n      })\n    },\n\n    userOperation: {\n      async estimateGas(userOperation) {\n        if (owner.type !== 'webAuthn') return\n\n        // Accounts with WebAuthn owner require a minimum verification gas limit of 800,000.\n        return {\n          verificationGasLimit: BigInt(\n            Math.max(Number(userOperation.verificationGasLimit ?? 0n), 800_000),\n          ),\n        }\n      },\n    },\n  })\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////\n// Utilities\n/////////////////////////////////////////////////////////////////////////////////////////////\n\n/** @internal */\nexport async function signTypedData({\n  typedData,\n  owner,\n}: {\n  typedData: TypedDataDefinition\n  owner: OneOf<LocalAccount | WebAuthnAccount>\n}) {\n  if (owner.type === 'local' && owner.signTypedData)\n    return owner.signTypedData(typedData)\n\n  const hash = hashTypedData(typedData)\n  return sign({ hash, owner })\n}\n\n/** @internal */\nexport async function sign({\n  hash,\n  owner,\n}: {\n  hash: Hash\n  owner: OneOf<LocalAccount | WebAuthnAccount>\n}) {\n  // WebAuthn Account (Passkey)\n  if (owner.type === 'webAuthn') {\n    const { signature, webauthn } = await owner.sign({\n      hash,\n    })\n    return toWebAuthnSignature({ signature, webauthn })\n  }\n\n  if (owner.sign) return owner.sign({ hash })\n\n  throw new BaseError('`owner` does not support raw sign.')\n}\n\n/** @internal */\nexport function toReplaySafeTypedData({\n  address,\n  chainId,\n  hash,\n}: {\n  address: Address\n  chainId: number\n  hash: Hash\n}) {\n  return {\n    domain: {\n      chainId,\n      name: 'Coinbase Smart Wallet',\n      verifyingContract: address,\n      version: '1',\n    },\n    types: {\n      CoinbaseSmartWalletMessage: [\n        {\n          name: 'hash',\n          type: 'bytes32',\n        },\n      ],\n    },\n    primaryType: 'CoinbaseSmartWalletMessage',\n    message: {\n      hash,\n    },\n  } as const\n}\n\n/** @internal */\nexport function toWebAuthnSignature({\n  webauthn,\n  signature,\n}: {\n  webauthn: WebAuthnP256.SignMetadata\n  signature: Hex\n}) {\n  const { r, s } = Signature.fromHex(signature)\n  return encodeAbiParameters(\n    [\n      {\n        components: [\n          {\n            name: 'authenticatorData',\n            type: 'bytes',\n          },\n          { name: 'clientDataJSON', type: 'bytes' },\n          { name: 'challengeIndex', type: 'uint256' },\n          { name: 'typeIndex', type: 'uint256' },\n          {\n            name: 'r',\n            type: 'uint256',\n          },\n          {\n            name: 's',\n            type: 'uint256',\n          },\n        ],\n        type: 'tuple',\n      },\n    ],\n    [\n      {\n        authenticatorData: webauthn.authenticatorData,\n        clientDataJSON: stringToHex(webauthn.clientDataJSON),\n        challengeIndex: BigInt(webauthn.challengeIndex),\n        typeIndex: BigInt(webauthn.typeIndex),\n        r,\n        s,\n      },\n    ],\n  )\n}\n\n/** @internal */\nexport function wrapSignature(parameters: {\n  ownerIndex?: number | undefined\n  signature: Hex\n}) {\n  const { ownerIndex = 0 } = parameters\n  const signatureData = (() => {\n    if (size(parameters.signature) !== 65) return parameters.signature\n    const signature = parseSignature(parameters.signature)\n    return encodePacked(\n      ['bytes32', 'bytes32', 'uint8'],\n      [signature.r, signature.s, signature.yParity === 0 ? 27 : 28],\n    )\n  })()\n  return encodeAbiParameters(\n    [\n      {\n        components: [\n          {\n            name: 'ownerIndex',\n            type: 'uint8',\n          },\n          {\n            name: 'signatureData',\n            type: 'bytes',\n          },\n        ],\n        type: 'tuple',\n      },\n    ],\n    [\n      {\n        ownerIndex,\n        signatureData,\n      },\n    ],\n  )\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////\n// Constants\n/////////////////////////////////////////////////////////////////////////////////////////////\n\nconst abi = [\n  { inputs: [], stateMutability: 'nonpayable', type: 'constructor' },\n  {\n    inputs: [{ name: 'owner', type: 'bytes' }],\n    name: 'AlreadyOwner',\n    type: 'error',\n  },\n  { inputs: [], name: 'Initialized', type: 'error' },\n  {\n    inputs: [{ name: 'owner', type: 'bytes' }],\n    name: 'InvalidEthereumAddressOwner',\n    type: 'error',\n  },\n  {\n    inputs: [{ name: 'key', type: 'uint256' }],\n    name: 'InvalidNonceKey',\n    type: 'error',\n  },\n  {\n    inputs: [{ name: 'owner', type: 'bytes' }],\n    name: 'InvalidOwnerBytesLength',\n    type: 'error',\n  },\n  { inputs: [], name: 'LastOwner', type: 'error' },\n  {\n    inputs: [{ name: 'index', type: 'uint256' }],\n    name: 'NoOwnerAtIndex',\n    type: 'error',\n  },\n  {\n    inputs: [{ name: 'ownersRemaining', type: 'uint256' }],\n    name: 'NotLastOwner',\n    type: 'error',\n  },\n  {\n    inputs: [{ name: 'selector', type: 'bytes4' }],\n    name: 'SelectorNotAllowed',\n    type: 'error',\n  },\n  { inputs: [], name: 'Unauthorized', type: 'error' },\n  { inputs: [], name: 'UnauthorizedCallContext', type: 'error' },\n  { inputs: [], name: 'UpgradeFailed', type: 'error' },\n  {\n    inputs: [\n      { name: 'index', type: 'uint256' },\n      { name: 'expectedOwner', type: 'bytes' },\n      { name: 'actualOwner', type: 'bytes' },\n    ],\n    name: 'WrongOwnerAtIndex',\n    type: 'error',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'index',\n        type: 'uint256',\n      },\n      { indexed: false, name: 'owner', type: 'bytes' },\n    ],\n    name: 'AddOwner',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'index',\n        type: 'uint256',\n      },\n      { indexed: false, name: 'owner', type: 'bytes' },\n    ],\n    name: 'RemoveOwner',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'implementation',\n        type: 'address',\n      },\n    ],\n    name: 'Upgraded',\n    type: 'event',\n  },\n  { stateMutability: 'payable', type: 'fallback' },\n  {\n    inputs: [],\n    name: 'REPLAYABLE_NONCE_KEY',\n    outputs: [{ name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'owner', type: 'address' }],\n    name: 'addOwnerAddress',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: 'x', type: 'bytes32' },\n      { name: 'y', type: 'bytes32' },\n    ],\n    name: 'addOwnerPublicKey',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'functionSelector', type: 'bytes4' }],\n    name: 'canSkipChainIdValidation',\n    outputs: [{ name: '', type: 'bool' }],\n    stateMutability: 'pure',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'domainSeparator',\n    outputs: [{ name: '', type: 'bytes32' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'eip712Domain',\n    outputs: [\n      { name: 'fields', type: 'bytes1' },\n      { name: 'name', type: 'string' },\n      { name: 'version', type: 'string' },\n      { name: 'chainId', type: 'uint256' },\n      { name: 'verifyingContract', type: 'address' },\n      { name: 'salt', type: 'bytes32' },\n      { name: 'extensions', type: 'uint256[]' },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'entryPoint',\n    outputs: [{ name: '', type: 'address' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: 'target', type: 'address' },\n      { name: 'value', type: 'uint256' },\n      { name: 'data', type: 'bytes' },\n    ],\n    name: 'execute',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'target', type: 'address' },\n          { name: 'value', type: 'uint256' },\n          { name: 'data', type: 'bytes' },\n        ],\n\n        name: 'calls',\n        type: 'tuple[]',\n      },\n    ],\n    name: 'executeBatch',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'calls', type: 'bytes[]' }],\n    name: 'executeWithoutChainIdValidation',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'sender', type: 'address' },\n          { name: 'nonce', type: 'uint256' },\n          { name: 'initCode', type: 'bytes' },\n          { name: 'callData', type: 'bytes' },\n          { name: 'callGasLimit', type: 'uint256' },\n          {\n            name: 'verificationGasLimit',\n            type: 'uint256',\n          },\n          {\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { name: 'maxFeePerGas', type: 'uint256' },\n          {\n            name: 'maxPriorityFeePerGas',\n            type: 'uint256',\n          },\n          { name: 'paymasterAndData', type: 'bytes' },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'userOp',\n        type: 'tuple',\n      },\n    ],\n    name: 'getUserOpHashWithoutChainId',\n    outputs: [{ name: '', type: 'bytes32' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'implementation',\n    outputs: [{ name: '$', type: 'address' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'owners', type: 'bytes[]' }],\n    name: 'initialize',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'account', type: 'address' }],\n    name: 'isOwnerAddress',\n    outputs: [{ name: '', type: 'bool' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'account', type: 'bytes' }],\n    name: 'isOwnerBytes',\n    outputs: [{ name: '', type: 'bool' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: 'x', type: 'bytes32' },\n      { name: 'y', type: 'bytes32' },\n    ],\n    name: 'isOwnerPublicKey',\n    outputs: [{ name: '', type: 'bool' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: 'hash', type: 'bytes32' },\n      { name: 'signature', type: 'bytes' },\n    ],\n    name: 'isValidSignature',\n    outputs: [{ name: 'result', type: 'bytes4' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'nextOwnerIndex',\n    outputs: [{ name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'index', type: 'uint256' }],\n    name: 'ownerAtIndex',\n    outputs: [{ name: '', type: 'bytes' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'ownerCount',\n    outputs: [{ name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'proxiableUUID',\n    outputs: [{ name: '', type: 'bytes32' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: 'index', type: 'uint256' },\n      { name: 'owner', type: 'bytes' },\n    ],\n    name: 'removeLastOwner',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: 'index', type: 'uint256' },\n      { name: 'owner', type: 'bytes' },\n    ],\n    name: 'removeOwnerAtIndex',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'removedOwnersCount',\n    outputs: [{ name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'hash', type: 'bytes32' }],\n    name: 'replaySafeHash',\n    outputs: [{ name: '', type: 'bytes32' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: 'newImplementation', type: 'address' },\n      { name: 'data', type: 'bytes' },\n    ],\n    name: 'upgradeToAndCall',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'sender', type: 'address' },\n          { name: 'nonce', type: 'uint256' },\n          { name: 'initCode', type: 'bytes' },\n          { name: 'callData', type: 'bytes' },\n          { name: 'callGasLimit', type: 'uint256' },\n          {\n            name: 'verificationGasLimit',\n            type: 'uint256',\n          },\n          {\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { name: 'maxFeePerGas', type: 'uint256' },\n          {\n            name: 'maxPriorityFeePerGas',\n            type: 'uint256',\n          },\n          { name: 'paymasterAndData', type: 'bytes' },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'userOp',\n        type: 'tuple',\n      },\n      { name: 'userOpHash', type: 'bytes32' },\n      { name: 'missingAccountFunds', type: 'uint256' },\n    ],\n    name: 'validateUserOp',\n    outputs: [{ name: 'validationData', type: 'uint256' }],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  { stateMutability: 'payable', type: 'receive' },\n] as const\n\nconst factoryAbi = [\n  {\n    inputs: [{ name: 'implementation_', type: 'address' }],\n    stateMutability: 'payable',\n    type: 'constructor',\n  },\n  { inputs: [], name: 'OwnerRequired', type: 'error' },\n  {\n    inputs: [\n      { name: 'owners', type: 'bytes[]' },\n      { name: 'nonce', type: 'uint256' },\n    ],\n    name: 'createAccount',\n    outputs: [\n      {\n        name: 'account',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: 'owners', type: 'bytes[]' },\n      { name: 'nonce', type: 'uint256' },\n    ],\n    name: 'getAddress',\n    outputs: [{ name: '', type: 'address' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'implementation',\n    outputs: [{ name: '', type: 'address' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'initCodeHash',\n    outputs: [{ name: '', type: 'bytes32' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n] as const\n", "export const entryPoint06Abi = [\n  {\n    inputs: [\n      { name: 'preOpGas', type: 'uint256' },\n      { name: 'paid', type: 'uint256' },\n      { name: 'validAfter', type: 'uint48' },\n      { name: 'validUntil', type: 'uint48' },\n      { name: 'targetSuccess', type: 'bool' },\n      { name: 'targetResult', type: 'bytes' },\n    ],\n    name: 'ExecutionResult',\n    type: 'error',\n  },\n  {\n    inputs: [\n      { name: 'opIndex', type: 'uint256' },\n      { name: 'reason', type: 'string' },\n    ],\n    name: 'FailedOp',\n    type: 'error',\n  },\n  {\n    inputs: [{ name: 'sender', type: 'address' }],\n    name: 'SenderAddressResult',\n    type: 'error',\n  },\n  {\n    inputs: [{ name: 'aggregator', type: 'address' }],\n    name: 'SignatureValidationFailed',\n    type: 'error',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'preOpGas', type: 'uint256' },\n          { name: 'prefund', type: 'uint256' },\n          { name: 'sigFailed', type: 'bool' },\n          { name: 'validAfter', type: 'uint48' },\n          { name: 'validUntil', type: 'uint48' },\n          { name: 'paymasterContext', type: 'bytes' },\n        ],\n\n        name: 'returnInfo',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { name: 'stake', type: 'uint256' },\n          { name: 'unstakeDelaySec', type: 'uint256' },\n        ],\n\n        name: 'senderInfo',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { name: 'stake', type: 'uint256' },\n          { name: 'unstakeDelaySec', type: 'uint256' },\n        ],\n\n        name: 'factoryInfo',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { name: 'stake', type: 'uint256' },\n          { name: 'unstakeDelaySec', type: 'uint256' },\n        ],\n\n        name: 'paymasterInfo',\n        type: 'tuple',\n      },\n    ],\n    name: 'ValidationResult',\n    type: 'error',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'preOpGas', type: 'uint256' },\n          { name: 'prefund', type: 'uint256' },\n          { name: 'sigFailed', type: 'bool' },\n          { name: 'validAfter', type: 'uint48' },\n          { name: 'validUntil', type: 'uint48' },\n          { name: 'paymasterContext', type: 'bytes' },\n        ],\n\n        name: 'returnInfo',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { name: 'stake', type: 'uint256' },\n          { name: 'unstakeDelaySec', type: 'uint256' },\n        ],\n\n        name: 'senderInfo',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { name: 'stake', type: 'uint256' },\n          { name: 'unstakeDelaySec', type: 'uint256' },\n        ],\n\n        name: 'factoryInfo',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { name: 'stake', type: 'uint256' },\n          { name: 'unstakeDelaySec', type: 'uint256' },\n        ],\n\n        name: 'paymasterInfo',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { name: 'aggregator', type: 'address' },\n          {\n            components: [\n              { name: 'stake', type: 'uint256' },\n              {\n                name: 'unstakeDelaySec',\n                type: 'uint256',\n              },\n            ],\n\n            name: 'stakeInfo',\n            type: 'tuple',\n          },\n        ],\n\n        name: 'aggregatorInfo',\n        type: 'tuple',\n      },\n    ],\n    name: 'ValidationResultWithAggregation',\n    type: 'error',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'factory',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'paymaster',\n        type: 'address',\n      },\n    ],\n    name: 'AccountDeployed',\n    type: 'event',\n  },\n  { anonymous: false, inputs: [], name: 'BeforeExecution', type: 'event' },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'totalDeposit',\n        type: 'uint256',\n      },\n    ],\n    name: 'Deposited',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'aggregator',\n        type: 'address',\n      },\n    ],\n    name: 'SignatureAggregatorChanged',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'totalStaked',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n\n        name: 'unstakeDelaySec',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeLocked',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'withdrawTime',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeUnlocked',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeWithdrawn',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: true,\n\n        name: 'paymaster',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'nonce',\n        type: 'uint256',\n      },\n      { indexed: false, name: 'success', type: 'bool' },\n      {\n        indexed: false,\n\n        name: 'actualGasCost',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n\n        name: 'actualGasUsed',\n        type: 'uint256',\n      },\n    ],\n    name: 'UserOperationEvent',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'nonce',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n\n        name: 'revertReason',\n        type: 'bytes',\n      },\n    ],\n    name: 'UserOperationRevertReason',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'Withdrawn',\n    type: 'event',\n  },\n  {\n    inputs: [],\n    name: 'SIG_VALIDATION_FAILED',\n    outputs: [{ name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: 'initCode', type: 'bytes' },\n      { name: 'sender', type: 'address' },\n      { name: 'paymasterAndData', type: 'bytes' },\n    ],\n    name: '_validateSenderAndPaymaster',\n    outputs: [],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'unstakeDelaySec', type: 'uint32' }],\n    name: 'addStake',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'account', type: 'address' }],\n    name: 'balanceOf',\n    outputs: [{ name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'account', type: 'address' }],\n    name: 'depositTo',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: '', type: 'address' }],\n    name: 'deposits',\n    outputs: [\n      { name: 'deposit', type: 'uint112' },\n      { name: 'staked', type: 'bool' },\n      { name: 'stake', type: 'uint112' },\n      { name: 'unstakeDelaySec', type: 'uint32' },\n      { name: 'withdrawTime', type: 'uint48' },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'account', type: 'address' }],\n    name: 'getDepositInfo',\n    outputs: [\n      {\n        components: [\n          { name: 'deposit', type: 'uint112' },\n          { name: 'staked', type: 'bool' },\n          { name: 'stake', type: 'uint112' },\n          { name: 'unstakeDelaySec', type: 'uint32' },\n          { name: 'withdrawTime', type: 'uint48' },\n        ],\n\n        name: 'info',\n        type: 'tuple',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: 'sender', type: 'address' },\n      { name: 'key', type: 'uint192' },\n    ],\n    name: 'getNonce',\n    outputs: [{ name: 'nonce', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'initCode', type: 'bytes' }],\n    name: 'getSenderAddress',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'sender', type: 'address' },\n          { name: 'nonce', type: 'uint256' },\n          { name: 'initCode', type: 'bytes' },\n          { name: 'callData', type: 'bytes' },\n          { name: 'callGasLimit', type: 'uint256' },\n          {\n            name: 'verificationGasLimit',\n            type: 'uint256',\n          },\n          {\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { name: 'maxFeePerGas', type: 'uint256' },\n          {\n            name: 'maxPriorityFeePerGas',\n            type: 'uint256',\n          },\n          { name: 'paymasterAndData', type: 'bytes' },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'userOp',\n        type: 'tuple',\n      },\n    ],\n    name: 'getUserOpHash',\n    outputs: [{ name: '', type: 'bytes32' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            components: [\n              { name: 'sender', type: 'address' },\n              { name: 'nonce', type: 'uint256' },\n              { name: 'initCode', type: 'bytes' },\n              { name: 'callData', type: 'bytes' },\n              {\n                name: 'callGasLimit',\n                type: 'uint256',\n              },\n              {\n                name: 'verificationGasLimit',\n                type: 'uint256',\n              },\n              {\n                name: 'preVerificationGas',\n                type: 'uint256',\n              },\n              {\n                name: 'maxFeePerGas',\n                type: 'uint256',\n              },\n              {\n                name: 'maxPriorityFeePerGas',\n                type: 'uint256',\n              },\n              {\n                name: 'paymasterAndData',\n                type: 'bytes',\n              },\n              { name: 'signature', type: 'bytes' },\n            ],\n\n            name: 'userOps',\n            type: 'tuple[]',\n          },\n          {\n            name: 'aggregator',\n            type: 'address',\n          },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'opsPerAggregator',\n        type: 'tuple[]',\n      },\n      { name: 'beneficiary', type: 'address' },\n    ],\n    name: 'handleAggregatedOps',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'sender', type: 'address' },\n          { name: 'nonce', type: 'uint256' },\n          { name: 'initCode', type: 'bytes' },\n          { name: 'callData', type: 'bytes' },\n          { name: 'callGasLimit', type: 'uint256' },\n          {\n            name: 'verificationGasLimit',\n            type: 'uint256',\n          },\n          {\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { name: 'maxFeePerGas', type: 'uint256' },\n          {\n            name: 'maxPriorityFeePerGas',\n            type: 'uint256',\n          },\n          { name: 'paymasterAndData', type: 'bytes' },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'ops',\n        type: 'tuple[]',\n      },\n      { name: 'beneficiary', type: 'address' },\n    ],\n    name: 'handleOps',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'key', type: 'uint192' }],\n    name: 'incrementNonce',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: 'callData', type: 'bytes' },\n      {\n        components: [\n          {\n            components: [\n              { name: 'sender', type: 'address' },\n              { name: 'nonce', type: 'uint256' },\n              {\n                name: 'callGasLimit',\n                type: 'uint256',\n              },\n              {\n                name: 'verificationGasLimit',\n                type: 'uint256',\n              },\n              {\n                name: 'preVerificationGas',\n                type: 'uint256',\n              },\n              { name: 'paymaster', type: 'address' },\n              {\n                name: 'maxFeePerGas',\n                type: 'uint256',\n              },\n              {\n                name: 'maxPriorityFeePerGas',\n                type: 'uint256',\n              },\n            ],\n\n            name: 'mUserOp',\n            type: 'tuple',\n          },\n          { name: 'userOpHash', type: 'bytes32' },\n          { name: 'prefund', type: 'uint256' },\n          { name: 'contextOffset', type: 'uint256' },\n          { name: 'preOpGas', type: 'uint256' },\n        ],\n\n        name: 'opInfo',\n        type: 'tuple',\n      },\n      { name: 'context', type: 'bytes' },\n    ],\n    name: 'innerHandleOp',\n    outputs: [{ name: 'actualGasCost', type: 'uint256' }],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: '', type: 'address' },\n      { name: '', type: 'uint192' },\n    ],\n    name: 'nonceSequenceNumber',\n    outputs: [{ name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'sender', type: 'address' },\n          { name: 'nonce', type: 'uint256' },\n          { name: 'initCode', type: 'bytes' },\n          { name: 'callData', type: 'bytes' },\n          { name: 'callGasLimit', type: 'uint256' },\n          {\n            name: 'verificationGasLimit',\n            type: 'uint256',\n          },\n          {\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { name: 'maxFeePerGas', type: 'uint256' },\n          {\n            name: 'maxPriorityFeePerGas',\n            type: 'uint256',\n          },\n          { name: 'paymasterAndData', type: 'bytes' },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'op',\n        type: 'tuple',\n      },\n      { name: 'target', type: 'address' },\n      { name: 'targetCallData', type: 'bytes' },\n    ],\n    name: 'simulateHandleOp',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'sender', type: 'address' },\n          { name: 'nonce', type: 'uint256' },\n          { name: 'initCode', type: 'bytes' },\n          { name: 'callData', type: 'bytes' },\n          { name: 'callGasLimit', type: 'uint256' },\n          {\n            name: 'verificationGasLimit',\n            type: 'uint256',\n          },\n          {\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { name: 'maxFeePerGas', type: 'uint256' },\n          {\n            name: 'maxPriorityFeePerGas',\n            type: 'uint256',\n          },\n          { name: 'paymasterAndData', type: 'bytes' },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'userOp',\n        type: 'tuple',\n      },\n    ],\n    name: 'simulateValidation',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'unlockStake',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n    ],\n    name: 'withdrawStake',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      { name: 'withdrawAmount', type: 'uint256' },\n    ],\n    name: 'withdrawTo',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  { stateMutability: 'payable', type: 'receive' },\n] as const\n\nexport const entryPoint07Abi = [\n  {\n    inputs: [\n      { name: 'success', type: 'bool' },\n      { name: 'ret', type: 'bytes' },\n    ],\n    name: 'DelegateAndRevert',\n    type: 'error',\n  },\n  {\n    inputs: [\n      { name: 'opIndex', type: 'uint256' },\n      { name: 'reason', type: 'string' },\n    ],\n    name: 'FailedOp',\n    type: 'error',\n  },\n  {\n    inputs: [\n      { name: 'opIndex', type: 'uint256' },\n      { name: 'reason', type: 'string' },\n      { name: 'inner', type: 'bytes' },\n    ],\n    name: 'FailedOpWithRevert',\n    type: 'error',\n  },\n  {\n    inputs: [{ name: 'returnData', type: 'bytes' }],\n    name: 'PostOpReverted',\n    type: 'error',\n  },\n  { inputs: [], name: 'ReentrancyGuardReentrantCall', type: 'error' },\n  {\n    inputs: [{ name: 'sender', type: 'address' }],\n    name: 'SenderAddressResult',\n    type: 'error',\n  },\n  {\n    inputs: [{ name: 'aggregator', type: 'address' }],\n    name: 'SignatureValidationFailed',\n    type: 'error',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'factory',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'paymaster',\n        type: 'address',\n      },\n    ],\n    name: 'AccountDeployed',\n    type: 'event',\n  },\n  { anonymous: false, inputs: [], name: 'BeforeExecution', type: 'event' },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'totalDeposit',\n        type: 'uint256',\n      },\n    ],\n    name: 'Deposited',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'nonce',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n\n        name: 'revertReason',\n        type: 'bytes',\n      },\n    ],\n    name: 'PostOpRevertReason',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'aggregator',\n        type: 'address',\n      },\n    ],\n    name: 'SignatureAggregatorChanged',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'totalStaked',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n\n        name: 'unstakeDelaySec',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeLocked',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'withdrawTime',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeUnlocked',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeWithdrawn',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: true,\n\n        name: 'paymaster',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'nonce',\n        type: 'uint256',\n      },\n      { indexed: false, name: 'success', type: 'bool' },\n      {\n        indexed: false,\n\n        name: 'actualGasCost',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n\n        name: 'actualGasUsed',\n        type: 'uint256',\n      },\n    ],\n    name: 'UserOperationEvent',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'nonce',\n        type: 'uint256',\n      },\n    ],\n    name: 'UserOperationPrefundTooLow',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'nonce',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n\n        name: 'revertReason',\n        type: 'bytes',\n      },\n    ],\n    name: 'UserOperationRevertReason',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'Withdrawn',\n    type: 'event',\n  },\n  {\n    inputs: [{ name: 'unstakeDelaySec', type: 'uint32' }],\n    name: 'addStake',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'account', type: 'address' }],\n    name: 'balanceOf',\n    outputs: [{ name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: 'target', type: 'address' },\n      { name: 'data', type: 'bytes' },\n    ],\n    name: 'delegateAndRevert',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'account', type: 'address' }],\n    name: 'depositTo',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: '', type: 'address' }],\n    name: 'deposits',\n    outputs: [\n      { name: 'deposit', type: 'uint256' },\n      { name: 'staked', type: 'bool' },\n      { name: 'stake', type: 'uint112' },\n      { name: 'unstakeDelaySec', type: 'uint32' },\n      { name: 'withdrawTime', type: 'uint48' },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'account', type: 'address' }],\n    name: 'getDepositInfo',\n    outputs: [\n      {\n        components: [\n          { name: 'deposit', type: 'uint256' },\n          { name: 'staked', type: 'bool' },\n          { name: 'stake', type: 'uint112' },\n          { name: 'unstakeDelaySec', type: 'uint32' },\n          { name: 'withdrawTime', type: 'uint48' },\n        ],\n\n        name: 'info',\n        type: 'tuple',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: 'sender', type: 'address' },\n      { name: 'key', type: 'uint192' },\n    ],\n    name: 'getNonce',\n    outputs: [{ name: 'nonce', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'initCode', type: 'bytes' }],\n    name: 'getSenderAddress',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'sender', type: 'address' },\n          { name: 'nonce', type: 'uint256' },\n          { name: 'initCode', type: 'bytes' },\n          { name: 'callData', type: 'bytes' },\n          {\n            name: 'accountGasLimits',\n            type: 'bytes32',\n          },\n          {\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { name: 'gasFees', type: 'bytes32' },\n          { name: 'paymasterAndData', type: 'bytes' },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'userOp',\n        type: 'tuple',\n      },\n    ],\n    name: 'getUserOpHash',\n    outputs: [{ name: '', type: 'bytes32' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            components: [\n              { name: 'sender', type: 'address' },\n              { name: 'nonce', type: 'uint256' },\n              { name: 'initCode', type: 'bytes' },\n              { name: 'callData', type: 'bytes' },\n              {\n                name: 'accountGasLimits',\n                type: 'bytes32',\n              },\n              {\n                name: 'preVerificationGas',\n                type: 'uint256',\n              },\n              { name: 'gasFees', type: 'bytes32' },\n              {\n                name: 'paymasterAndData',\n                type: 'bytes',\n              },\n              { name: 'signature', type: 'bytes' },\n            ],\n\n            name: 'userOps',\n            type: 'tuple[]',\n          },\n          {\n            name: 'aggregator',\n            type: 'address',\n          },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'opsPerAggregator',\n        type: 'tuple[]',\n      },\n      { name: 'beneficiary', type: 'address' },\n    ],\n    name: 'handleAggregatedOps',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'sender', type: 'address' },\n          { name: 'nonce', type: 'uint256' },\n          { name: 'initCode', type: 'bytes' },\n          { name: 'callData', type: 'bytes' },\n          {\n            name: 'accountGasLimits',\n            type: 'bytes32',\n          },\n          {\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { name: 'gasFees', type: 'bytes32' },\n          { name: 'paymasterAndData', type: 'bytes' },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'ops',\n        type: 'tuple[]',\n      },\n      { name: 'beneficiary', type: 'address' },\n    ],\n    name: 'handleOps',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'key', type: 'uint192' }],\n    name: 'incrementNonce',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: 'callData', type: 'bytes' },\n      {\n        components: [\n          {\n            components: [\n              { name: 'sender', type: 'address' },\n              { name: 'nonce', type: 'uint256' },\n              {\n                name: 'verificationGasLimit',\n                type: 'uint256',\n              },\n              {\n                name: 'callGasLimit',\n                type: 'uint256',\n              },\n              {\n                name: 'paymasterVerificationGasLimit',\n                type: 'uint256',\n              },\n              {\n                name: 'paymasterPostOpGasLimit',\n                type: 'uint256',\n              },\n              {\n                name: 'preVerificationGas',\n                type: 'uint256',\n              },\n              { name: 'paymaster', type: 'address' },\n              {\n                name: 'maxFeePerGas',\n                type: 'uint256',\n              },\n              {\n                name: 'maxPriorityFeePerGas',\n                type: 'uint256',\n              },\n            ],\n\n            name: 'mUserOp',\n            type: 'tuple',\n          },\n          { name: 'userOpHash', type: 'bytes32' },\n          { name: 'prefund', type: 'uint256' },\n          { name: 'contextOffset', type: 'uint256' },\n          { name: 'preOpGas', type: 'uint256' },\n        ],\n\n        name: 'opInfo',\n        type: 'tuple',\n      },\n      { name: 'context', type: 'bytes' },\n    ],\n    name: 'innerHandleOp',\n    outputs: [{ name: 'actualGasCost', type: 'uint256' }],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: '', type: 'address' },\n      { name: '', type: 'uint192' },\n    ],\n    name: 'nonceSequenceNumber',\n    outputs: [{ name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'interfaceId', type: 'bytes4' }],\n    name: 'supportsInterface',\n    outputs: [{ name: '', type: 'bool' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'unlockStake',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n    ],\n    name: 'withdrawStake',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      { name: 'withdrawAmount', type: 'uint256' },\n    ],\n    name: 'withdrawTo',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  { stateMutability: 'payable', type: 'receive' },\n] as const\n\nexport const entryPoint08Abi = [\n  { inputs: [], stateMutability: 'nonpayable', type: 'constructor' },\n  {\n    inputs: [\n      { internalType: 'bool', name: 'success', type: 'bool' },\n      { internalType: 'bytes', name: 'ret', type: 'bytes' },\n    ],\n    name: 'DelegateAndRevert',\n    type: 'error',\n  },\n  {\n    inputs: [\n      { internalType: 'uint256', name: 'opIndex', type: 'uint256' },\n      { internalType: 'string', name: 'reason', type: 'string' },\n    ],\n    name: 'FailedOp',\n    type: 'error',\n  },\n  {\n    inputs: [\n      { internalType: 'uint256', name: 'opIndex', type: 'uint256' },\n      { internalType: 'string', name: 'reason', type: 'string' },\n      { internalType: 'bytes', name: 'inner', type: 'bytes' },\n    ],\n    name: 'FailedOpWithRevert',\n    type: 'error',\n  },\n  { inputs: [], name: 'InvalidShortString', type: 'error' },\n  {\n    inputs: [{ internalType: 'bytes', name: 'returnData', type: 'bytes' }],\n    name: 'PostOpReverted',\n    type: 'error',\n  },\n  { inputs: [], name: 'ReentrancyGuardReentrantCall', type: 'error' },\n  {\n    inputs: [{ internalType: 'address', name: 'sender', type: 'address' }],\n    name: 'SenderAddressResult',\n    type: 'error',\n  },\n  {\n    inputs: [{ internalType: 'address', name: 'aggregator', type: 'address' }],\n    name: 'SignatureValidationFailed',\n    type: 'error',\n  },\n  {\n    inputs: [{ internalType: 'string', name: 'str', type: 'string' }],\n    name: 'StringTooLong',\n    type: 'error',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'address',\n        name: 'factory',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'address',\n        name: 'paymaster',\n        type: 'address',\n      },\n    ],\n    name: 'AccountDeployed',\n    type: 'event',\n  },\n  { anonymous: false, inputs: [], name: 'BeforeExecution', type: 'event' },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'totalDeposit',\n        type: 'uint256',\n      },\n    ],\n    name: 'Deposited',\n    type: 'event',\n  },\n  { anonymous: false, inputs: [], name: 'EIP712DomainChanged', type: 'event' },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'nonce',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n        internalType: 'bytes',\n        name: 'revertReason',\n        type: 'bytes',\n      },\n    ],\n    name: 'PostOpRevertReason',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'aggregator',\n        type: 'address',\n      },\n    ],\n    name: 'SignatureAggregatorChanged',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'totalStaked',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'unstakeDelaySec',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeLocked',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'withdrawTime',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeUnlocked',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'address',\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeWithdrawn',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'paymaster',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'nonce',\n        type: 'uint256',\n      },\n      { indexed: false, internalType: 'bool', name: 'success', type: 'bool' },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'actualGasCost',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'actualGasUsed',\n        type: 'uint256',\n      },\n    ],\n    name: 'UserOperationEvent',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'nonce',\n        type: 'uint256',\n      },\n    ],\n    name: 'UserOperationPrefundTooLow',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'nonce',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n        internalType: 'bytes',\n        name: 'revertReason',\n        type: 'bytes',\n      },\n    ],\n    name: 'UserOperationRevertReason',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'address',\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'Withdrawn',\n    type: 'event',\n  },\n  {\n    inputs: [\n      { internalType: 'uint32', name: 'unstakeDelaySec', type: 'uint32' },\n    ],\n    name: 'addStake',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'address', name: 'account', type: 'address' }],\n    name: 'balanceOf',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'address', name: 'target', type: 'address' },\n      { internalType: 'bytes', name: 'data', type: 'bytes' },\n    ],\n    name: 'delegateAndRevert',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'address', name: 'account', type: 'address' }],\n    name: 'depositTo',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'eip712Domain',\n    outputs: [\n      { internalType: 'bytes1', name: 'fields', type: 'bytes1' },\n      { internalType: 'string', name: 'name', type: 'string' },\n      { internalType: 'string', name: 'version', type: 'string' },\n      { internalType: 'uint256', name: 'chainId', type: 'uint256' },\n      { internalType: 'address', name: 'verifyingContract', type: 'address' },\n      { internalType: 'bytes32', name: 'salt', type: 'bytes32' },\n      { internalType: 'uint256[]', name: 'extensions', type: 'uint256[]' },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'address', name: 'account', type: 'address' }],\n    name: 'getDepositInfo',\n    outputs: [\n      {\n        components: [\n          { internalType: 'uint256', name: 'deposit', type: 'uint256' },\n          { internalType: 'bool', name: 'staked', type: 'bool' },\n          { internalType: 'uint112', name: 'stake', type: 'uint112' },\n          { internalType: 'uint32', name: 'unstakeDelaySec', type: 'uint32' },\n          { internalType: 'uint48', name: 'withdrawTime', type: 'uint48' },\n        ],\n        internalType: 'struct IStakeManager.DepositInfo',\n        name: 'info',\n        type: 'tuple',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getDomainSeparatorV4',\n    outputs: [{ internalType: 'bytes32', name: '', type: 'bytes32' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'address', name: 'sender', type: 'address' },\n      { internalType: 'uint192', name: 'key', type: 'uint192' },\n    ],\n    name: 'getNonce',\n    outputs: [{ internalType: 'uint256', name: 'nonce', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getPackedUserOpTypeHash',\n    outputs: [{ internalType: 'bytes32', name: '', type: 'bytes32' }],\n    stateMutability: 'pure',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'bytes', name: 'initCode', type: 'bytes' }],\n    name: 'getSenderAddress',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: 'address', name: 'sender', type: 'address' },\n          { internalType: 'uint256', name: 'nonce', type: 'uint256' },\n          { internalType: 'bytes', name: 'initCode', type: 'bytes' },\n          { internalType: 'bytes', name: 'callData', type: 'bytes' },\n          {\n            internalType: 'bytes32',\n            name: 'accountGasLimits',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'uint256',\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { internalType: 'bytes32', name: 'gasFees', type: 'bytes32' },\n          { internalType: 'bytes', name: 'paymasterAndData', type: 'bytes' },\n          { internalType: 'bytes', name: 'signature', type: 'bytes' },\n        ],\n        internalType: 'struct PackedUserOperation',\n        name: 'userOp',\n        type: 'tuple',\n      },\n    ],\n    name: 'getUserOpHash',\n    outputs: [{ internalType: 'bytes32', name: '', type: 'bytes32' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            components: [\n              { internalType: 'address', name: 'sender', type: 'address' },\n              { internalType: 'uint256', name: 'nonce', type: 'uint256' },\n              { internalType: 'bytes', name: 'initCode', type: 'bytes' },\n              { internalType: 'bytes', name: 'callData', type: 'bytes' },\n              {\n                internalType: 'bytes32',\n                name: 'accountGasLimits',\n                type: 'bytes32',\n              },\n              {\n                internalType: 'uint256',\n                name: 'preVerificationGas',\n                type: 'uint256',\n              },\n              { internalType: 'bytes32', name: 'gasFees', type: 'bytes32' },\n              {\n                internalType: 'bytes',\n                name: 'paymasterAndData',\n                type: 'bytes',\n              },\n              { internalType: 'bytes', name: 'signature', type: 'bytes' },\n            ],\n            internalType: 'struct PackedUserOperation[]',\n            name: 'userOps',\n            type: 'tuple[]',\n          },\n          {\n            internalType: 'contract IAggregator',\n            name: 'aggregator',\n            type: 'address',\n          },\n          { internalType: 'bytes', name: 'signature', type: 'bytes' },\n        ],\n        internalType: 'struct IEntryPoint.UserOpsPerAggregator[]',\n        name: 'opsPerAggregator',\n        type: 'tuple[]',\n      },\n      { internalType: 'address payable', name: 'beneficiary', type: 'address' },\n    ],\n    name: 'handleAggregatedOps',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: 'address', name: 'sender', type: 'address' },\n          { internalType: 'uint256', name: 'nonce', type: 'uint256' },\n          { internalType: 'bytes', name: 'initCode', type: 'bytes' },\n          { internalType: 'bytes', name: 'callData', type: 'bytes' },\n          {\n            internalType: 'bytes32',\n            name: 'accountGasLimits',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'uint256',\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { internalType: 'bytes32', name: 'gasFees', type: 'bytes32' },\n          { internalType: 'bytes', name: 'paymasterAndData', type: 'bytes' },\n          { internalType: 'bytes', name: 'signature', type: 'bytes' },\n        ],\n        internalType: 'struct PackedUserOperation[]',\n        name: 'ops',\n        type: 'tuple[]',\n      },\n      { internalType: 'address payable', name: 'beneficiary', type: 'address' },\n    ],\n    name: 'handleOps',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'uint192', name: 'key', type: 'uint192' }],\n    name: 'incrementNonce',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'bytes', name: 'callData', type: 'bytes' },\n      {\n        components: [\n          {\n            components: [\n              { internalType: 'address', name: 'sender', type: 'address' },\n              { internalType: 'uint256', name: 'nonce', type: 'uint256' },\n              {\n                internalType: 'uint256',\n                name: 'verificationGasLimit',\n                type: 'uint256',\n              },\n              {\n                internalType: 'uint256',\n                name: 'callGasLimit',\n                type: 'uint256',\n              },\n              {\n                internalType: 'uint256',\n                name: 'paymasterVerificationGasLimit',\n                type: 'uint256',\n              },\n              {\n                internalType: 'uint256',\n                name: 'paymasterPostOpGasLimit',\n                type: 'uint256',\n              },\n              {\n                internalType: 'uint256',\n                name: 'preVerificationGas',\n                type: 'uint256',\n              },\n              { internalType: 'address', name: 'paymaster', type: 'address' },\n              {\n                internalType: 'uint256',\n                name: 'maxFeePerGas',\n                type: 'uint256',\n              },\n              {\n                internalType: 'uint256',\n                name: 'maxPriorityFeePerGas',\n                type: 'uint256',\n              },\n            ],\n            internalType: 'struct EntryPoint.MemoryUserOp',\n            name: 'mUserOp',\n            type: 'tuple',\n          },\n          { internalType: 'bytes32', name: 'userOpHash', type: 'bytes32' },\n          { internalType: 'uint256', name: 'prefund', type: 'uint256' },\n          { internalType: 'uint256', name: 'contextOffset', type: 'uint256' },\n          { internalType: 'uint256', name: 'preOpGas', type: 'uint256' },\n        ],\n        internalType: 'struct EntryPoint.UserOpInfo',\n        name: 'opInfo',\n        type: 'tuple',\n      },\n      { internalType: 'bytes', name: 'context', type: 'bytes' },\n    ],\n    name: 'innerHandleOp',\n    outputs: [\n      { internalType: 'uint256', name: 'actualGasCost', type: 'uint256' },\n    ],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'address', name: '', type: 'address' },\n      { internalType: 'uint192', name: '', type: 'uint192' },\n    ],\n    name: 'nonceSequenceNumber',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'senderCreator',\n    outputs: [\n      { internalType: 'contract ISenderCreator', name: '', type: 'address' },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'bytes4', name: 'interfaceId', type: 'bytes4' }],\n    name: 'supportsInterface',\n    outputs: [{ internalType: 'bool', name: '', type: 'bool' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'unlockStake',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address payable',\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n    ],\n    name: 'withdrawStake',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address payable',\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      { internalType: 'uint256', name: 'withdrawAmount', type: 'uint256' },\n    ],\n    name: 'withdrawTo',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  { stateMutability: 'payable', type: 'receive' },\n] as const\n", "import type { Address } from 'abitype'\n\nimport type { Hash, Hex } from '../../../types/misc.js'\nimport { encodeAbiParameters } from '../../../utils/abi/encodeAbiParameters.js'\nimport { keccak256 } from '../../../utils/hash/keccak256.js'\nimport { hashTypedData } from '../../../utils/signature/hashTypedData.js'\nimport type { EntryPointVersion } from '../../types/entryPointVersion.js'\nimport type { UserOperation } from '../../types/userOperation.js'\nimport { getInitCode } from './getInitCode.js'\nimport { getUserOperationTypedData } from './getUserOperationTypedData.js'\nimport { toPackedUserOperation } from './toPackedUserOperation.js'\n\nexport type GetUserOperationHashParameters<\n  entryPointVersion extends EntryPointVersion = EntryPointVersion,\n> = {\n  chainId: number\n  entryPointAddress: Address\n  entryPointVersion: entryPointVersion | EntryPointVersion\n  userOperation: UserOperation<entryPointVersion>\n}\n\nexport type GetUserOperationHashReturnType = Hash\n\nexport function getUserOperationHash<\n  entryPointVersion extends EntryPointVersion,\n>(\n  parameters: GetUserOperationHashParameters<entryPointVersion>,\n): GetUserOperationHashReturnType {\n  const { chainId, entryPointAddress, entryPointVersion } = parameters\n  const userOperation = parameters.userOperation as UserOperation\n  const {\n    authorization,\n    callData = '0x',\n    callGasLimit,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    paymasterAndData = '0x',\n    preVerificationGas,\n    sender,\n    verificationGasLimit,\n  } = userOperation\n\n  if (entryPointVersion === '0.8')\n    return hashTypedData(\n      getUserOperationTypedData({\n        chainId,\n        entryPointAddress,\n        userOperation,\n      }),\n    )\n\n  const packedUserOp = (() => {\n    if (entryPointVersion === '0.6') {\n      const factory = userOperation.initCode?.slice(0, 42) as Hex\n      const factoryData = userOperation.initCode?.slice(42) as Hex | undefined\n      const initCode = getInitCode({\n        authorization,\n        factory,\n        factoryData,\n      })\n      return encodeAbiParameters(\n        [\n          { type: 'address' },\n          { type: 'uint256' },\n          { type: 'bytes32' },\n          { type: 'bytes32' },\n          { type: 'uint256' },\n          { type: 'uint256' },\n          { type: 'uint256' },\n          { type: 'uint256' },\n          { type: 'uint256' },\n          { type: 'bytes32' },\n        ],\n        [\n          sender,\n          nonce,\n          keccak256(initCode),\n          keccak256(callData),\n          callGasLimit,\n          verificationGasLimit,\n          preVerificationGas,\n          maxFeePerGas,\n          maxPriorityFeePerGas,\n          keccak256(paymasterAndData),\n        ],\n      )\n    }\n\n    if (entryPointVersion === '0.7') {\n      const packedUserOp = toPackedUserOperation(userOperation)\n      return encodeAbiParameters(\n        [\n          { type: 'address' },\n          { type: 'uint256' },\n          { type: 'bytes32' },\n          { type: 'bytes32' },\n          { type: 'bytes32' },\n          { type: 'uint256' },\n          { type: 'bytes32' },\n          { type: 'bytes32' },\n        ],\n        [\n          packedUserOp.sender,\n          packedUserOp.nonce,\n          keccak256(packedUserOp.initCode),\n          keccak256(packedUserOp.callData),\n          packedUserOp.accountGasLimits,\n          packedUserOp.preVerificationGas,\n          packedUserOp.gasFees,\n          keccak256(packedUserOp.paymasterAndData),\n        ],\n      )\n    }\n\n    throw new Error(`entryPointVersion \"${entryPointVersion}\" not supported.`)\n  })()\n\n  return keccak256(\n    encodeAbiParameters(\n      [{ type: 'bytes32' }, { type: 'address' }, { type: 'uint256' }],\n      [keccak256(packedUserOp), entryPointAddress, BigInt(chainId)],\n    ),\n  )\n}\n", "import { concat } from '../../../utils/data/concat.js'\nimport type { UserOperation } from '../../types/userOperation.js'\n\nexport function getInitCode(\n  userOperation: Pick<\n    UserOperation,\n    'authorization' | 'factory' | 'factoryData'\n  >,\n) {\n  const { authorization, factory, factoryData } = userOperation\n  if (\n    factory === '0x7702' ||\n    factory === '0x7702000000000000000000000000000000000000'\n  ) {\n    if (!authorization) return '0x7702000000000000000000000000000000000000'\n    const delegation = authorization.address\n    return concat([delegation, factoryData ?? '0x'])\n  }\n  if (!factory) return '0x'\n  return concat([factory, factoryData ?? '0x'])\n}\n", "import type { Address } from 'abitype'\n\nimport type { TypedDataDefinition } from '../../../types/typedData.js'\nimport type { UserOperation } from '../../types/userOperation.js'\nimport { toPackedUserOperation } from './toPackedUserOperation.js'\n\nexport type GetUserOperationTypedDataParameters = {\n  chainId: number\n  entryPointAddress: Address\n  userOperation: UserOperation<'0.8'>\n}\n\nexport type GetUserOperationTypedDataReturnType = TypedDataDefinition<\n  typeof types,\n  'PackedUserOperation'\n>\n\nconst types = {\n  PackedUserOperation: [\n    { type: 'address', name: 'sender' },\n    { type: 'uint256', name: 'nonce' },\n    { type: 'bytes', name: 'initCode' },\n    { type: 'bytes', name: 'callData' },\n    { type: 'bytes32', name: 'accountGasLimits' },\n    { type: 'uint256', name: 'preVerificationGas' },\n    { type: 'bytes32', name: 'gasFees' },\n    { type: 'bytes', name: 'paymasterAndData' },\n  ],\n} as const\n\nexport function getUserOperationTypedData(\n  parameters: GetUserOperationTypedDataParameters,\n): GetUserOperationTypedDataReturnType {\n  const { chainId, entryPointAddress, userOperation } = parameters\n\n  const packedUserOp = toPackedUserOperation(userOperation)\n\n  return {\n    types,\n    primaryType: 'PackedUserOperation',\n    domain: {\n      name: 'ERC4337',\n      version: '1',\n      chainId,\n      verifyingContract: entryPointAddress,\n    },\n    message: packedUserOp,\n  }\n}\n", "import { concat } from '../../../utils/data/concat.js'\nimport { pad } from '../../../utils/data/pad.js'\nimport { numberToHex } from '../../../utils/index.js'\nimport type {\n  PackedUserOperation,\n  UserOperation,\n} from '../../types/userOperation.js'\nimport { getInitCode } from './getInitCode.js'\n\nexport function toPackedUserOperation(\n  userOperation: UserOperation,\n): PackedUserOperation {\n  const {\n    callGasLimit,\n    callData,\n    maxPriorityFeePerGas,\n    maxFeePerGas,\n    paymaster,\n    paymasterData,\n    paymasterPostOpGasLimit,\n    paymasterVerificationGasLimit,\n    sender,\n    signature = '0x',\n    verificationGasLimit,\n  } = userOperation\n\n  const accountGasLimits = concat([\n    pad(numberToHex(verificationGasLimit || 0n), { size: 16 }),\n    pad(numberToHex(callGasLimit || 0n), { size: 16 }),\n  ])\n  const initCode = getInitCode(userOperation)\n  const gasFees = concat([\n    pad(numberToHex(maxPriorityFeePerGas || 0n), { size: 16 }),\n    pad(numberToHex(maxFeePerGas || 0n), { size: 16 }),\n  ])\n  const nonce = userOperation.nonce ?? 0n\n  const paymasterAndData = paymaster\n    ? concat([\n        paymaster,\n        pad(numberToHex(paymasterVerificationGasLimit || 0n), {\n          size: 16,\n        }),\n        pad(numberToHex(paymasterPostOpGasLimit || 0n), {\n          size: 16,\n        }),\n        paymasterData || '0x',\n      ])\n    : '0x'\n  const preVerificationGas = userOperation.preVerificationGas ?? 0n\n\n  return {\n    accountGasLimits,\n    callData,\n    initCode,\n    gasFees,\n    nonce,\n    paymasterAndData,\n    preVerificationGas,\n    sender,\n    signature,\n  }\n}\n", "import { type Abi, parseAbi } from 'abitype'\n\nimport { getCode } from '../../actions/public/getCode.js'\nimport { readContract } from '../../actions/public/readContract.js'\nimport type { Prettify } from '../../types/utils.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { createNonceManager } from '../../utils/nonceManager.js'\nimport { serializeErc6492Signature } from '../../utils/signature/serializeErc6492Signature.js'\nimport type { EntryPointVersion } from '../types/entryPointVersion.js'\nimport type { SmartAccount, SmartAccountImplementation } from './types.js'\n\nexport type ToSmartAccountParameters<\n  entryPointAbi extends Abi | readonly unknown[] = Abi,\n  entryPointVersion extends EntryPointVersion = EntryPointVersion,\n  extend extends object = object,\n> = SmartAccountImplementation<entryPointAbi, entryPointVersion, extend>\n\nexport type ToSmartAccountReturnType<\n  implementation extends\n    SmartAccountImplementation = SmartAccountImplementation,\n> = Prettify<SmartAccount<implementation>>\n\n/**\n * @description Creates a Smart Account with a provided account implementation.\n *\n * @param parameters - {@link ToSmartAccountParameters}\n * @returns A Smart Account. {@link ToSmartAccountReturnType}\n */\nexport async function toSmartAccount<\n  implementation extends SmartAccountImplementation,\n>(\n  implementation: implementation,\n): Promise<ToSmartAccountReturnType<implementation>> {\n  const {\n    extend,\n    nonceKeyManager = createNonceManager({\n      source: {\n        get() {\n          return Date.now()\n        },\n        set() {},\n      },\n    }),\n    ...rest\n  } = implementation\n\n  let deployed = false\n\n  const address = await implementation.getAddress()\n\n  return {\n    ...extend,\n    ...rest,\n    address,\n    async getFactoryArgs() {\n      if ('isDeployed' in this && (await this.isDeployed()))\n        return { factory: undefined, factoryData: undefined }\n      return implementation.getFactoryArgs()\n    },\n    async getNonce(parameters) {\n      const key =\n        parameters?.key ??\n        BigInt(\n          await nonceKeyManager.consume({\n            address,\n            chainId: implementation.client.chain!.id!,\n            client: implementation.client,\n          }),\n        )\n\n      if (implementation.getNonce)\n        return await implementation.getNonce({ ...parameters, key })\n\n      const nonce = await readContract(implementation.client, {\n        abi: parseAbi([\n          'function getNonce(address, uint192) pure returns (uint256)',\n        ]),\n        address: implementation.entryPoint.address,\n        functionName: 'getNonce',\n        args: [address, key],\n      })\n      return nonce\n    },\n    async isDeployed() {\n      if (deployed) return true\n      const code = await getAction(\n        implementation.client,\n        getCode,\n        'getCode',\n      )({\n        address,\n      })\n      deployed = Boolean(code)\n      return deployed\n    },\n    ...(implementation.sign\n      ? {\n          async sign(parameters) {\n            const [{ factory, factoryData }, signature] = await Promise.all([\n              this.getFactoryArgs(),\n              implementation.sign!(parameters),\n            ])\n            if (factory && factoryData)\n              return serializeErc6492Signature({\n                address: factory,\n                data: factoryData,\n                signature,\n              })\n            return signature\n          },\n        }\n      : {}),\n    async signMessage(parameters) {\n      const [{ factory, factoryData }, signature] = await Promise.all([\n        this.getFactoryArgs(),\n        implementation.signMessage(parameters),\n      ])\n      if (factory && factoryData && factory !== '0x7702')\n        return serializeErc6492Signature({\n          address: factory,\n          data: factoryData,\n          signature,\n        })\n      return signature\n    },\n    async signTypedData(parameters) {\n      const [{ factory, factoryData }, signature] = await Promise.all([\n        this.getFactoryArgs(),\n        implementation.signTypedData(parameters),\n      ])\n      if (factory && factoryData && factory !== '0x7702')\n        return serializeErc6492Signature({\n          address: factory,\n          data: factoryData,\n          signature,\n        })\n      return signature\n    },\n    type: 'smart',\n  } as ToSmartAccountReturnType<implementation>\n}\n", "import type { Address, TypedData } from 'abitype'\n\nimport type { PrivateKeyAccount } from '../../../accounts/types.js'\nimport { entryPoint08Address } from '../../../constants/address.js'\nimport { BaseError } from '../../../errors/base.js'\nimport type { TypedDataDefinition } from '../../../types/typedData.js'\nimport type { Prettify } from '../../../types/utils.js'\nimport { decodeFunctionData } from '../../../utils/abi/decodeFunctionData.js'\nimport { encodeFunctionData } from '../../../utils/abi/encodeFunctionData.js'\nimport { entryPoint08Abi } from '../../constants/abis.js'\nimport { getUserOperationTypedData } from '../../utils/userOperation/getUserOperationTypedData.js'\nimport { toSmartAccount } from '../toSmartAccount.js'\nimport type { SmartAccount, SmartAccountImplementation } from '../types.js'\n\nexport type ToSimple7702SmartAccountParameters = {\n  client: Simple7702SmartAccountImplementation['client']\n  implementation?: Address | undefined\n  getNonce?: SmartAccountImplementation['getNonce'] | undefined\n  owner: PrivateKeyAccount\n}\n\nexport type ToSimple7702SmartAccountReturnType = Prettify<\n  SmartAccount<Simple7702SmartAccountImplementation>\n>\n\nexport type Simple7702SmartAccountImplementation = SmartAccountImplementation<\n  typeof entryPoint08Abi,\n  '0.8',\n  { abi: typeof abi; owner: PrivateKeyAccount },\n  true\n>\n\n/**\n * @description Create a Simple7702 Smart Account  based off [eth-infinitism's `Simple7702Account.sol`](https://github.com/eth-infinitism/account-abstraction/blob/develop/contracts/accounts/Simple7702Account.sol).\n *\n * @param parameters - {@link ToSimple7702SmartAccountParameters}\n * @returns Simple7702 Smart Account. {@link ToSimple7702SmartAccountReturnType}\n *\n * @example\n * import { toSimple7702SmartAccount } from 'viem/account-abstraction'\n * import { client } from './client.js'\n *\n * const implementation = toSimple7702SmartAccount({\n *   client,\n *   owner: '0x...',\n * })\n */\nexport async function toSimple7702SmartAccount(\n  parameters: ToSimple7702SmartAccountParameters,\n): Promise<ToSimple7702SmartAccountReturnType> {\n  const {\n    client,\n    implementation = '0xe6Cae83BdE06E4c305530e199D7217f42808555B',\n    getNonce,\n    owner,\n  } = parameters\n\n  const entryPoint = {\n    abi: entryPoint08Abi,\n    address: entryPoint08Address,\n    version: '0.8',\n  } as const\n\n  return toSmartAccount({\n    authorization: { account: owner, address: implementation },\n    abi,\n    client,\n    extend: { abi, owner }, // not removing abi from here as this will be a breaking change\n    entryPoint,\n    getNonce,\n\n    async decodeCalls(data) {\n      const result = decodeFunctionData({\n        abi,\n        data,\n      })\n\n      if (result.functionName === 'execute')\n        return [\n          { to: result.args[0], value: result.args[1], data: result.args[2] },\n        ]\n      if (result.functionName === 'executeBatch')\n        return result.args[0].map((arg) => ({\n          to: arg.target,\n          value: arg.value,\n          data: arg.data,\n        }))\n      throw new BaseError(`unable to decode calls for \"${result.functionName}\"`)\n    },\n\n    async encodeCalls(calls) {\n      if (calls.length === 1)\n        return encodeFunctionData({\n          abi,\n          functionName: 'execute',\n          args: [calls[0].to, calls[0].value ?? 0n, calls[0].data ?? '0x'],\n        })\n      return encodeFunctionData({\n        abi,\n        functionName: 'executeBatch',\n        args: [\n          calls.map((call) => ({\n            data: call.data ?? '0x',\n            target: call.to,\n            value: call.value ?? 0n,\n          })),\n        ],\n      })\n    },\n\n    async getAddress() {\n      return owner.address\n    },\n\n    async getFactoryArgs() {\n      return { factory: '0x7702', factoryData: '0x' }\n    },\n\n    async getStubSignature() {\n      return '0xfffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c'\n    },\n\n    async signMessage(parameters) {\n      const { message } = parameters\n      return await owner.signMessage({ message })\n    },\n\n    async signTypedData(parameters) {\n      const { domain, types, primaryType, message } =\n        parameters as TypedDataDefinition<TypedData, string>\n      return await owner.signTypedData({\n        domain,\n        message,\n        primaryType,\n        types,\n      })\n    },\n\n    async signUserOperation(parameters) {\n      const { chainId = client.chain!.id, ...userOperation } = parameters\n\n      const address = await this.getAddress()\n      const typedData = getUserOperationTypedData({\n        chainId,\n        entryPointAddress: entryPoint.address,\n        userOperation: {\n          ...userOperation,\n          sender: address,\n        },\n      })\n      return await owner.signTypedData(typedData)\n    },\n  })\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////\n// Constants\n\nconst abi = [\n  { inputs: [], name: 'ECDSAInvalidSignature', type: 'error' },\n  {\n    inputs: [{ internalType: 'uint256', name: 'length', type: 'uint256' }],\n    name: 'ECDSAInvalidSignatureLength',\n    type: 'error',\n  },\n  {\n    inputs: [{ internalType: 'bytes32', name: 's', type: 'bytes32' }],\n    name: 'ECDSAInvalidSignatureS',\n    type: 'error',\n  },\n  {\n    inputs: [\n      { internalType: 'uint256', name: 'index', type: 'uint256' },\n      { internalType: 'bytes', name: 'error', type: 'bytes' },\n    ],\n    name: 'ExecuteError',\n    type: 'error',\n  },\n  { stateMutability: 'payable', type: 'fallback' },\n  {\n    inputs: [],\n    name: 'entryPoint',\n    outputs: [\n      { internalType: 'contract IEntryPoint', name: '', type: 'address' },\n    ],\n    stateMutability: 'pure',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'address', name: 'target', type: 'address' },\n      { internalType: 'uint256', name: 'value', type: 'uint256' },\n      { internalType: 'bytes', name: 'data', type: 'bytes' },\n    ],\n    name: 'execute',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: 'address', name: 'target', type: 'address' },\n          { internalType: 'uint256', name: 'value', type: 'uint256' },\n          { internalType: 'bytes', name: 'data', type: 'bytes' },\n        ],\n        internalType: 'struct BaseAccount.Call[]',\n        name: 'calls',\n        type: 'tuple[]',\n      },\n    ],\n    name: 'executeBatch',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getNonce',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'bytes32', name: 'hash', type: 'bytes32' },\n      { internalType: 'bytes', name: 'signature', type: 'bytes' },\n    ],\n    name: 'isValidSignature',\n    outputs: [{ internalType: 'bytes4', name: 'magicValue', type: 'bytes4' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'address', name: '', type: 'address' },\n      { internalType: 'address', name: '', type: 'address' },\n      { internalType: 'uint256[]', name: '', type: 'uint256[]' },\n      { internalType: 'uint256[]', name: '', type: 'uint256[]' },\n      { internalType: 'bytes', name: '', type: 'bytes' },\n    ],\n    name: 'onERC1155BatchReceived',\n    outputs: [{ internalType: 'bytes4', name: '', type: 'bytes4' }],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'address', name: '', type: 'address' },\n      { internalType: 'address', name: '', type: 'address' },\n      { internalType: 'uint256', name: '', type: 'uint256' },\n      { internalType: 'uint256', name: '', type: 'uint256' },\n      { internalType: 'bytes', name: '', type: 'bytes' },\n    ],\n    name: 'onERC1155Received',\n    outputs: [{ internalType: 'bytes4', name: '', type: 'bytes4' }],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'address', name: '', type: 'address' },\n      { internalType: 'address', name: '', type: 'address' },\n      { internalType: 'uint256', name: '', type: 'uint256' },\n      { internalType: 'bytes', name: '', type: 'bytes' },\n    ],\n    name: 'onERC721Received',\n    outputs: [{ internalType: 'bytes4', name: '', type: 'bytes4' }],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'bytes4', name: 'id', type: 'bytes4' }],\n    name: 'supportsInterface',\n    outputs: [{ internalType: 'bool', name: '', type: 'bool' }],\n    stateMutability: 'pure',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: 'address', name: 'sender', type: 'address' },\n          { internalType: 'uint256', name: 'nonce', type: 'uint256' },\n          { internalType: 'bytes', name: 'initCode', type: 'bytes' },\n          { internalType: 'bytes', name: 'callData', type: 'bytes' },\n          {\n            internalType: 'bytes32',\n            name: 'accountGasLimits',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'uint256',\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { internalType: 'bytes32', name: 'gasFees', type: 'bytes32' },\n          { internalType: 'bytes', name: 'paymasterAndData', type: 'bytes' },\n          { internalType: 'bytes', name: 'signature', type: 'bytes' },\n        ],\n        internalType: 'struct PackedUserOperation',\n        name: 'userOp',\n        type: 'tuple',\n      },\n      { internalType: 'bytes32', name: 'userOpHash', type: 'bytes32' },\n      { internalType: 'uint256', name: 'missingAccountFunds', type: 'uint256' },\n    ],\n    name: 'validateUserOp',\n    outputs: [\n      { internalType: 'uint256', name: 'validationData', type: 'uint256' },\n    ],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  { stateMutability: 'payable', type: 'receive' },\n] as const\n", "import type { Abi, Address, TypedData } from 'abitype'\n\nimport { parseAccount } from '../../../accounts/utils/parseAccount.js'\nimport { readContract } from '../../../actions/public/readContract.js'\nimport { signMessage as signMessage_ } from '../../../actions/wallet/signMessage.js'\nimport { entryPoint07Address } from '../../../constants/address.js'\nimport { BaseError } from '../../../errors/base.js'\nimport { signMessage } from '../../../experimental/erc7739/actions/signMessage.js'\nimport { signTypedData } from '../../../experimental/erc7739/actions/signTypedData.js'\nimport type { Account } from '../../../types/account.js'\nimport type { Hex } from '../../../types/misc.js'\nimport type { TypedDataDefinition } from '../../../types/typedData.js'\nimport type { Prettify } from '../../../types/utils.js'\nimport { decodeFunctionData } from '../../../utils/abi/decodeFunctionData.js'\nimport { encodeFunctionData } from '../../../utils/abi/encodeFunctionData.js'\nimport { pad } from '../../../utils/data/pad.js'\nimport { getAction } from '../../../utils/getAction.js'\nimport { entryPoint07Abi } from '../../constants/abis.js'\nimport type { EntryPointVersion } from '../../types/entryPointVersion.js'\nimport { getUserOperationHash } from '../../utils/userOperation/getUserOperationHash.js'\nimport { toSmartAccount } from '../toSmartAccount.js'\nimport type { SmartAccount, SmartAccountImplementation } from '../types.js'\n\nexport type ToSoladySmartAccountParameters<\n  entryPointAbi extends Abi = Abi,\n  entryPointVersion extends EntryPointVersion = EntryPointVersion,\n> = {\n  address?: Address | undefined\n  client: SoladySmartAccountImplementation['client']\n  entryPoint?:\n    | {\n        abi: entryPointAbi\n        address: Address\n        version: entryPointVersion | EntryPointVersion\n      }\n    | undefined\n  factoryAddress?: Address | undefined\n  getNonce?: SmartAccountImplementation['getNonce'] | undefined\n  owner: Address | Account\n  salt?: Hex | undefined\n}\n\nexport type ToSoladySmartAccountReturnType<\n  entryPointAbi extends Abi = Abi,\n  entryPointVersion extends EntryPointVersion = EntryPointVersion,\n> = Prettify<\n  SmartAccount<\n    SoladySmartAccountImplementation<entryPointAbi, entryPointVersion>\n  >\n>\n\nexport type SoladySmartAccountImplementation<\n  entryPointAbi extends Abi = Abi,\n  entryPointVersion extends EntryPointVersion = EntryPointVersion,\n> = SmartAccountImplementation<\n  entryPointAbi,\n  entryPointVersion,\n  { abi: typeof abi; factory: { abi: typeof factoryAbi; address: Address } }\n>\n\n/**\n * @description Create a Solady Smart Account  based off [Solady's `ERC4337.sol`](https://github.com/Vectorized/solady/blob/main/src/accounts/ERC4337.sol).\n *\n * @param parameters - {@link ToSoladySmartAccountParameters}\n * @returns Solady Smart Account. {@link ToSoladySmartAccountReturnType}\n *\n * @example\n * import { toSoladySmartAccount } from 'viem/account-abstraction'\n * import { client } from './client.js'\n *\n * const implementation = toSoladySmartAccount({\n *   client,\n *   owner: '0x...',\n * })\n */\nexport async function toSoladySmartAccount<\n  entryPointAbi extends Abi = typeof entryPoint07Abi,\n  entryPointVersion extends EntryPointVersion = '0.7',\n>(\n  parameters: ToSoladySmartAccountParameters<entryPointAbi, entryPointVersion>,\n): Promise<ToSoladySmartAccountReturnType<entryPointAbi, entryPointVersion>> {\n  const {\n    address,\n    client,\n    entryPoint: entryPoint_ = {\n      abi: entryPoint07Abi,\n      address: entryPoint07Address,\n      version: '0.7',\n    },\n    factoryAddress = '0x5d82735936c6Cd5DE57cC3c1A799f6B2E6F933Df',\n    getNonce,\n    salt = '0x0',\n  } = parameters\n\n  const entryPoint = {\n    abi: entryPoint_.abi as entryPointAbi,\n    address: entryPoint_.address,\n    version: entryPoint_.version as entryPointVersion,\n  } as const\n  const factory = {\n    abi: factoryAbi,\n    address: factoryAddress,\n  } as const\n  const owner = parseAccount(parameters.owner)\n\n  return toSmartAccount({\n    client,\n    entryPoint,\n    getNonce,\n\n    extend: { abi, factory },\n\n    async decodeCalls(data) {\n      const result = decodeFunctionData({\n        abi,\n        data,\n      })\n\n      if (result.functionName === 'execute')\n        return [\n          { to: result.args[0], value: result.args[1], data: result.args[2] },\n        ]\n      if (result.functionName === 'executeBatch')\n        return result.args[0].map((arg) => ({\n          to: arg.target,\n          value: arg.value,\n          data: arg.data,\n        }))\n      throw new BaseError(`unable to decode calls for \"${result.functionName}\"`)\n    },\n\n    async encodeCalls(calls) {\n      if (calls.length === 1)\n        return encodeFunctionData({\n          abi,\n          functionName: 'execute',\n          args: [calls[0].to, calls[0].value ?? 0n, calls[0].data ?? '0x'],\n        })\n      return encodeFunctionData({\n        abi,\n        functionName: 'executeBatch',\n        args: [\n          calls.map((call) => ({\n            data: call.data ?? '0x',\n            target: call.to,\n            value: call.value ?? 0n,\n          })),\n        ],\n      })\n    },\n\n    async getAddress() {\n      if (address) return address\n      return await readContract(client, {\n        ...factory,\n        functionName: 'getAddress',\n        args: [pad(salt)],\n      })\n    },\n\n    async getFactoryArgs() {\n      const factoryData = encodeFunctionData({\n        abi: factory.abi,\n        functionName: 'createAccount',\n        args: [owner.address, pad(salt)],\n      })\n      return { factory: factory.address, factoryData }\n    },\n\n    async getStubSignature() {\n      return '0xfffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c'\n    },\n\n    async signMessage(parameters) {\n      const { message } = parameters\n      const [address, { factory, factoryData }] = await Promise.all([\n        this.getAddress(),\n        this.getFactoryArgs(),\n      ])\n      return await signMessage(client, {\n        account: owner,\n        factory,\n        factoryData,\n        message,\n        verifier: address,\n      })\n    },\n\n    async signTypedData(parameters) {\n      const { domain, types, primaryType, message } =\n        parameters as TypedDataDefinition<TypedData, string>\n      const [address, { factory, factoryData }] = await Promise.all([\n        this.getAddress(),\n        this.getFactoryArgs(),\n      ])\n      return await signTypedData(client, {\n        account: owner,\n        domain,\n        message,\n        factory,\n        factoryData,\n        primaryType,\n        types,\n        verifier: address,\n      })\n    },\n\n    async signUserOperation(parameters) {\n      const { chainId = client.chain!.id, ...userOperation } = parameters\n\n      const address = await this.getAddress()\n      const userOpHash = getUserOperationHash({\n        chainId,\n        entryPointAddress: entryPoint.address,\n        entryPointVersion: entryPoint.version,\n        userOperation: {\n          ...(userOperation as any),\n          sender: address,\n        },\n      })\n      const signature = await getAction(\n        client,\n        signMessage_,\n        'signMessage',\n      )({\n        account: owner,\n        message: {\n          raw: userOpHash,\n        },\n      })\n      return signature\n    },\n  })\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////\n// Constants\n\nconst abi = [\n  {\n    type: 'fallback',\n    stateMutability: 'payable',\n  },\n  {\n    type: 'receive',\n    stateMutability: 'payable',\n  },\n  {\n    type: 'function',\n    name: 'addDeposit',\n    inputs: [],\n    outputs: [],\n    stateMutability: 'payable',\n  },\n  {\n    type: 'function',\n    name: 'cancelOwnershipHandover',\n    inputs: [],\n    outputs: [],\n    stateMutability: 'payable',\n  },\n  {\n    type: 'function',\n    name: 'completeOwnershipHandover',\n    inputs: [\n      {\n        name: 'pendingOwner',\n        type: 'address',\n      },\n    ],\n    outputs: [],\n    stateMutability: 'payable',\n  },\n  {\n    type: 'function',\n    name: 'delegateExecute',\n    inputs: [\n      {\n        name: 'delegate',\n        type: 'address',\n      },\n      {\n        name: 'data',\n        type: 'bytes',\n      },\n    ],\n    outputs: [\n      {\n        name: 'result',\n        type: 'bytes',\n      },\n    ],\n    stateMutability: 'payable',\n  },\n  {\n    type: 'function',\n    name: 'eip712Domain',\n    inputs: [],\n    outputs: [\n      {\n        name: 'name',\n        type: 'string',\n      },\n      {\n        name: 'version',\n        type: 'string',\n      },\n      {\n        name: 'chainId',\n        type: 'uint256',\n      },\n      {\n        name: 'verifyingContract',\n        type: 'address',\n      },\n      {\n        name: 'salt',\n        type: 'bytes32',\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'entryPoint',\n    inputs: [],\n    outputs: [\n      {\n        name: '',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'execute',\n    inputs: [\n      {\n        name: 'target',\n        type: 'address',\n      },\n      {\n        name: 'value',\n        type: 'uint256',\n      },\n      {\n        name: 'data',\n        type: 'bytes',\n      },\n    ],\n    outputs: [\n      {\n        name: 'result',\n        type: 'bytes',\n      },\n    ],\n    stateMutability: 'payable',\n  },\n  {\n    type: 'function',\n    name: 'executeBatch',\n    inputs: [\n      {\n        name: 'calls',\n        type: 'tuple[]',\n\n        components: [\n          {\n            name: 'target',\n            type: 'address',\n          },\n          {\n            name: 'value',\n            type: 'uint256',\n          },\n          {\n            name: 'data',\n            type: 'bytes',\n          },\n        ],\n      },\n    ],\n    outputs: [\n      {\n        name: 'results',\n        type: 'bytes[]',\n      },\n    ],\n    stateMutability: 'payable',\n  },\n  {\n    type: 'function',\n    name: 'getDeposit',\n    inputs: [],\n    outputs: [\n      {\n        name: 'result',\n        type: 'uint256',\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'initialize',\n    inputs: [\n      {\n        name: 'newOwner',\n        type: 'address',\n      },\n    ],\n    outputs: [],\n    stateMutability: 'payable',\n  },\n  {\n    type: 'function',\n    name: 'isValidSignature',\n    inputs: [\n      {\n        name: 'hash',\n        type: 'bytes32',\n      },\n      {\n        name: 'signature',\n        type: 'bytes',\n      },\n    ],\n    outputs: [\n      {\n        name: 'result',\n        type: 'bytes4',\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'owner',\n    inputs: [],\n    outputs: [\n      {\n        name: 'result',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'ownershipHandoverExpiresAt',\n    inputs: [\n      {\n        name: 'pendingOwner',\n        type: 'address',\n      },\n    ],\n    outputs: [\n      {\n        name: 'result',\n        type: 'uint256',\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'proxiableUUID',\n    inputs: [],\n    outputs: [\n      {\n        name: '',\n        type: 'bytes32',\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'renounceOwnership',\n    inputs: [],\n    outputs: [],\n    stateMutability: 'payable',\n  },\n  {\n    type: 'function',\n    name: 'requestOwnershipHandover',\n    inputs: [],\n    outputs: [],\n    stateMutability: 'payable',\n  },\n  {\n    type: 'function',\n    name: 'storageLoad',\n    inputs: [\n      {\n        name: 'storageSlot',\n        type: 'bytes32',\n      },\n    ],\n    outputs: [\n      {\n        name: 'result',\n        type: 'bytes32',\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'storageStore',\n    inputs: [\n      {\n        name: 'storageSlot',\n        type: 'bytes32',\n      },\n      {\n        name: 'storageValue',\n        type: 'bytes32',\n      },\n    ],\n    outputs: [],\n    stateMutability: 'payable',\n  },\n  {\n    type: 'function',\n    name: 'transferOwnership',\n    inputs: [\n      {\n        name: 'newOwner',\n        type: 'address',\n      },\n    ],\n    outputs: [],\n    stateMutability: 'payable',\n  },\n  {\n    type: 'function',\n    name: 'upgradeToAndCall',\n    inputs: [\n      {\n        name: 'newImplementation',\n        type: 'address',\n      },\n      {\n        name: 'data',\n        type: 'bytes',\n      },\n    ],\n    outputs: [],\n    stateMutability: 'payable',\n  },\n  {\n    type: 'function',\n    name: 'validateUserOp',\n    inputs: [\n      {\n        name: 'userOp',\n        type: 'tuple',\n\n        components: [\n          {\n            name: 'sender',\n            type: 'address',\n          },\n          {\n            name: 'nonce',\n            type: 'uint256',\n          },\n          {\n            name: 'initCode',\n            type: 'bytes',\n          },\n          {\n            name: 'callData',\n            type: 'bytes',\n          },\n          {\n            name: 'accountGasLimits',\n            type: 'bytes32',\n          },\n          {\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          {\n            name: 'gasFees',\n            type: 'bytes32',\n          },\n          {\n            name: 'paymasterAndData',\n            type: 'bytes',\n          },\n          {\n            name: 'signature',\n            type: 'bytes',\n          },\n        ],\n      },\n      {\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        name: 'missingAccountFunds',\n        type: 'uint256',\n      },\n    ],\n    outputs: [\n      {\n        name: 'validationData',\n        type: 'uint256',\n      },\n    ],\n    stateMutability: 'payable',\n  },\n  {\n    type: 'function',\n    name: 'withdrawDepositTo',\n    inputs: [\n      {\n        name: 'to',\n        type: 'address',\n      },\n      {\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    outputs: [],\n    stateMutability: 'payable',\n  },\n  {\n    type: 'event',\n    name: 'OwnershipHandoverCanceled',\n    inputs: [\n      {\n        name: 'pendingOwner',\n        type: 'address',\n        indexed: true,\n      },\n    ],\n    anonymous: false,\n  },\n  {\n    type: 'event',\n    name: 'OwnershipHandoverRequested',\n    inputs: [\n      {\n        name: 'pendingOwner',\n        type: 'address',\n        indexed: true,\n      },\n    ],\n    anonymous: false,\n  },\n  {\n    type: 'event',\n    name: 'OwnershipTransferred',\n    inputs: [\n      {\n        name: 'oldOwner',\n        type: 'address',\n        indexed: true,\n      },\n      {\n        name: 'newOwner',\n        type: 'address',\n        indexed: true,\n      },\n    ],\n    anonymous: false,\n  },\n  {\n    type: 'event',\n    name: 'Upgraded',\n    inputs: [\n      {\n        name: 'implementation',\n        type: 'address',\n        indexed: true,\n      },\n    ],\n    anonymous: false,\n  },\n  {\n    type: 'error',\n    name: 'AlreadyInitialized',\n    inputs: [],\n  },\n  {\n    type: 'error',\n    name: 'FnSelectorNotRecognized',\n    inputs: [],\n  },\n  {\n    type: 'error',\n    name: 'NewOwnerIsZeroAddress',\n    inputs: [],\n  },\n  {\n    type: 'error',\n    name: 'NoHandoverRequest',\n    inputs: [],\n  },\n  {\n    type: 'error',\n    name: 'Unauthorized',\n    inputs: [],\n  },\n  {\n    type: 'error',\n    name: 'UnauthorizedCallContext',\n    inputs: [],\n  },\n  {\n    type: 'error',\n    name: 'UpgradeFailed',\n    inputs: [],\n  },\n] as const\n\nconst factoryAbi = [\n  {\n    type: 'constructor',\n    inputs: [\n      {\n        name: 'erc4337',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'nonpayable',\n  },\n  {\n    type: 'function',\n    name: 'createAccount',\n    inputs: [\n      {\n        name: 'owner',\n        type: 'address',\n      },\n      {\n        name: 'salt',\n        type: 'bytes32',\n      },\n    ],\n    outputs: [\n      {\n        name: '',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'payable',\n  },\n  {\n    type: 'function',\n    name: 'getAddress',\n    inputs: [\n      {\n        name: 'salt',\n        type: 'bytes32',\n      },\n    ],\n    outputs: [\n      {\n        name: '',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'implementation',\n    inputs: [],\n    outputs: [\n      {\n        name: '',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'initCodeHash',\n    inputs: [],\n    outputs: [\n      {\n        name: '',\n        type: 'bytes32',\n      },\n    ],\n    stateMutability: 'view',\n  },\n] as const\n", "import type { Address, TypedDataDomain } from 'abitype'\nimport type { Account } from '../../../accounts/types.js'\nimport { parseAccount } from '../../../accounts/utils/parseAccount.js'\nimport {\n  type GetEip712DomainParameters,\n  getEip712Domain,\n} from '../../../actions/public/getEip712Domain.js'\nimport { signTypedData } from '../../../actions/wallet/signTypedData.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport { AccountNotFoundError } from '../../../errors/account.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { GetAccountParameter } from '../../../types/account.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type { Hex, SignableMessage } from '../../../types/misc.js'\nimport type { OneOf, RequiredBy } from '../../../types/utils.js'\nimport { getAction } from '../../../utils/getAction.js'\nimport { toPrefixedMessage } from '../../../utils/signature/toPrefixedMessage.js'\nimport type { GetVerifierParameter } from '../types.js'\n\nexport type SignMessageParameters<\n  account extends Account | undefined = Account | undefined,\n  accountOverride extends Account | undefined = Account | undefined,\n  verifier extends Address | undefined = Address | undefined,\n> = Pick<GetEip712DomainParameters, 'factory' | 'factoryData'> &\n  GetAccountParameter<account, accountOverride> & {\n    message: SignableMessage\n  } & OneOf<\n    | {\n        verifierDomain: RequiredBy<\n          TypedDataDomain,\n          'chainId' | 'name' | 'verifyingContract' | 'version'\n        >\n        verifier?: undefined\n      }\n    | (GetVerifierParameter<verifier> & {\n        verifierDomain?:\n          | RequiredBy<\n              TypedDataDomain,\n              'chainId' | 'name' | 'verifyingContract' | 'version'\n            >\n          | undefined\n      })\n  >\n\nexport type SignMessageReturnType = Hex\n\nexport type SignMessageErrorType = ErrorType\n\n/**\n * Signs a [EIP-191](https://eips.ethereum.org/EIPS/eip-191) personal sign message via [ERC-7739 `PersonalSign` format](https://eips.ethereum.org/EIPS/eip-7702).\n *\n * This Action is suitable to sign messages for Smart Accounts that implement (or conform to) [ERC-7739](https://eips.ethereum.org/EIPS/eip-7702) (e.g. Solady's [ERC1271.sol](https://github.com/Vectorized/solady/blob/main/src/accounts/ERC1271.sol)).\n *\n * - Docs: https://viem.sh/experimental/erc7739/signMessage\n *\n * With the calculated signature, you can:\n * - use [`verifyMessage`](https://viem.sh/docs/utilities/verifyMessage) to verify the signature,\n *\n * @param client - Client to use\n * @param parameters - {@link SignMessageParameters}\n * @returns The signed message. {@link SignMessageReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { signMessage } from 'viem/experimental/erc7739'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n *\n * const signature = await signMessage(client, {\n *   account: '0xE8Df82fA4E10e6A12a9Dab552bceA2acd26De9bb',\n *   message: 'hello world',\n *   verifier: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, custom } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { signMessage } from 'viem/experimental/erc7739'\n *\n * const client = createWalletClient({\n *   account: '0xE8Df82fA4E10e6A12a9Dab552bceA2acd26De9bb',\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n *\n * const signature = await signMessage(client, {\n *   message: 'hello world',\n *   verifier: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * })\n */\nexport async function signMessage<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  accountOverride extends Account | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: SignMessageParameters<account, accountOverride>,\n): Promise<SignMessageReturnType> {\n  const {\n    account: account_ = client.account,\n    factory,\n    factoryData,\n    message,\n    verifier,\n  } = parameters\n\n  if (!account_)\n    throw new AccountNotFoundError({\n      docsPath: '/experimental/erc7739/signMessage',\n    })\n  const account = parseAccount(account_)\n\n  const { salt: _, ...domain } = await (async () => {\n    if (parameters.verifierDomain) return parameters.verifierDomain\n    const { domain } = await getAction(\n      client,\n      getEip712Domain,\n      'getEip712Domain',\n    )({\n      address: verifier!,\n      factory,\n      factoryData,\n    })\n    return domain\n  })()\n\n  return getAction(\n    client,\n    signTypedData,\n    'signTypedData',\n  )({\n    account,\n    domain,\n    types: {\n      PersonalSign: [{ name: 'prefixed', type: 'bytes' }],\n    },\n    primaryType: 'PersonalSign',\n    message: {\n      prefixed: toPrefixedMessage(message),\n    },\n  })\n}\n", "import type { Address, TypedData, TypedDataDomain } from 'abitype'\n\nimport type { Account } from '../../../accounts/types.js'\nimport { parseAccount } from '../../../accounts/utils/parseAccount.js'\nimport {\n  type GetEip712DomainParameters,\n  getEip712Domain,\n} from '../../../actions/public/getEip712Domain.js'\nimport { signTypedData as signTypedData_ } from '../../../actions/wallet/signTypedData.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport { AccountNotFoundError } from '../../../errors/account.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { GetAccountParameter } from '../../../types/account.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type { Hex } from '../../../types/misc.js'\nimport type { TypedDataDefinition } from '../../../types/typedData.js'\nimport type { OneOf, RequiredBy } from '../../../types/utils.js'\nimport { getAction } from '../../../utils/getAction.js'\nimport type { GetVerifierParameter } from '../types.js'\nimport { wrapTypedDataSignature } from '../utils/wrapTypedDataSignature.js'\n\nexport type SignTypedDataParameters<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n  account extends Account | undefined = undefined,\n  accountOverride extends Account | undefined = undefined,\n  verifier extends Address | undefined = Address | undefined,\n  ///\n  primaryTypes = typedData extends TypedData ? keyof typedData : string,\n> = TypedDataDefinition<typedData, primaryType, primaryTypes> &\n  Pick<GetEip712DomainParameters, 'factory' | 'factoryData'> &\n  GetAccountParameter<account, accountOverride> &\n  OneOf<\n    | {\n        verifierDomain: RequiredBy<\n          TypedDataDomain,\n          'chainId' | 'name' | 'verifyingContract' | 'salt' | 'version'\n        >\n        verifier?: undefined\n      }\n    | (GetVerifierParameter<verifier> & {\n        verifierDomain?:\n          | RequiredBy<\n              TypedDataDomain,\n              'chainId' | 'name' | 'verifyingContract' | 'salt' | 'version'\n            >\n          | undefined\n      })\n  >\n\nexport type SignTypedDataReturnType = Hex\n\nexport type SignTypedDataErrorType = ErrorType\n\n/**\n * Signs an [EIP-712](https://eips.ethereum.org/EIPS/eip-712) typed data message via [ERC-7739 `TypedDataSign` format](https://eips.ethereum.org/EIPS/eip-7702).\n *\n * This Action is suitable to sign messages for Smart Accounts that implement (or conform to) [ERC-7739](https://eips.ethereum.org/EIPS/eip-7702) (e.g. Solady's [ERC1271.sol](https://github.com/Vectorized/solady/blob/main/src/accounts/ERC1271.sol)).\n *\n * - Docs: https://viem.sh/experimental/erc7739/signTypedData\n *\n * @param client - Client to use\n * @param parameters - {@link SignTypedDataParameters}\n * @returns The signed data. {@link SignTypedDataReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { signTypedData } from 'viem/experimental/erc7739'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const signature = await signTypedData(client, {\n *   account: '0xE8Df82fA4E10e6A12a9Dab552bceA2acd26De9bb',\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   types: {\n *     Person: [\n *       { name: 'name', type: 'string' },\n *       { name: 'wallet', type: 'address' },\n *     ],\n *     Mail: [\n *       { name: 'from', type: 'Person' },\n *       { name: 'to', type: 'Person' },\n *       { name: 'contents', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Mail',\n *   message: {\n *     from: {\n *       name: 'Cow',\n *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n *     },\n *     to: {\n *       name: 'Bob',\n *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *     },\n *     contents: 'Hello, Bob!',\n *   },\n *   verifier: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { signTypedData } from 'viem/experimental/erc7739'\n *\n * const client = createWalletClient({\n *   account: '0xE8Df82fA4E10e6A12a9Dab552bceA2acd26De9bb'\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const signature = await signTypedData(client, {\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   types: {\n *     Person: [\n *       { name: 'name', type: 'string' },\n *       { name: 'wallet', type: 'address' },\n *     ],\n *     Mail: [\n *       { name: 'from', type: 'Person' },\n *       { name: 'to', type: 'Person' },\n *       { name: 'contents', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Mail',\n *   message: {\n *     from: {\n *       name: 'Cow',\n *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n *     },\n *     to: {\n *       name: 'Bob',\n *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *     },\n *     contents: 'Hello, Bob!',\n *   },\n *   verifier: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * })\n */\nexport async function signTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  accountOverride extends Account | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: SignTypedDataParameters<\n    typedData,\n    primaryType,\n    account,\n    accountOverride\n  >,\n): Promise<SignTypedDataReturnType> {\n  const {\n    account: account_ = client.account,\n    domain,\n    factory,\n    factoryData,\n    message,\n    primaryType,\n    types,\n    verifier,\n  } = parameters as unknown as SignTypedDataParameters\n\n  if (!account_)\n    throw new AccountNotFoundError({\n      docsPath: '/experimental/erc7739/signTypedData',\n    })\n  const account = parseAccount(account_!)\n\n  // Retrieve account EIP712 domain.\n  const { domain: verifierDomain } = await (async () => {\n    if (parameters.verifierDomain)\n      return {\n        domain: parameters.verifierDomain,\n      }\n    return getAction(\n      client,\n      getEip712Domain,\n      'getEip712Domain',\n    )({\n      address: verifier!,\n      factory,\n      factoryData,\n    })\n  })()\n\n  // Sign with typed data wrapper.\n  const signature = await getAction(\n    client,\n    signTypedData_,\n    'signTypedData',\n  )({\n    account,\n    domain,\n    types: {\n      ...types,\n      TypedDataSign: [\n        { name: 'contents', type: primaryType },\n        { name: 'name', type: 'string' },\n        { name: 'version', type: 'string' },\n        { name: 'chainId', type: 'uint256' },\n        { name: 'verifyingContract', type: 'address' },\n        { name: 'salt', type: 'bytes32' },\n      ],\n    },\n    primaryType: 'TypedDataSign',\n    message: {\n      contents: message as any,\n      ...(verifierDomain as any),\n    },\n  })\n\n  return wrapTypedDataSignature({\n    domain,\n    message,\n    primaryType,\n    signature,\n    types,\n  })\n}\n", "import type { TypedData } from 'abitype'\nimport { serializeSignature } from '../../../accounts/index.js'\nimport type { ByteArray, Hex, Signature } from '../../../types/misc.js'\nimport type { TypedDataDefinition } from '../../../types/typedData.js'\nimport { encodePacked } from '../../../utils/abi/encodePacked.js'\nimport { type IsHexErrorType, isHex } from '../../../utils/data/isHex.js'\nimport { size } from '../../../utils/data/size.js'\nimport { bytesToHex, stringToHex } from '../../../utils/encoding/toHex.js'\nimport {\n  encodeType,\n  hashStruct,\n} from '../../../utils/signature/hashTypedData.js'\nimport { getTypesForEIP712Domain } from '../../../utils/typedData.js'\n\nexport type WrapTypedDataSignatureParameters<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n  ///\n  primaryTypes = typedData extends TypedData ? keyof typedData : string,\n> = TypedDataDefinition<typedData, primaryType, primaryTypes> & {\n  signature: Hex | ByteArray | Signature\n}\n\nexport type WrapTypedDataSignatureReturnType = Hex\n\nexport type WrapTypedDataSignatureErrorType = IsHexErrorType\n\n/**\n * Wraps a typed data signature for ERC-7739.\n *\n * @example\n * ```ts\n * const signature = wrapTypedDataSignature({\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   types: {\n *     Person: [\n *       { name: 'name', type: 'string' },\n *       { name: 'wallet', type: 'address' },\n *     ],\n *     Mail: [\n *       { name: 'from', type: 'Person' },\n *       { name: 'to', type: 'Person' },\n *       { name: 'contents', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Mail',\n *   message: {\n *     from: {\n *       name: 'Cow',\n *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n *     },\n *     to: {\n *       name: 'Bob',\n *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *     },\n *     contents: 'Hello, Bob!',\n *   },\n *   signature: '0x...',\n * })\n * ```\n */\nexport function wrapTypedDataSignature(\n  parameters: WrapTypedDataSignatureParameters,\n): WrapTypedDataSignatureReturnType {\n  const { domain, message, primaryType, signature, types } = parameters\n\n  const signatureHex = (() => {\n    if (isHex(signature)) return signature\n    if (typeof signature === 'object' && 'r' in signature && 's' in signature)\n      return serializeSignature(signature)\n    return bytesToHex(signature)\n  })()\n\n  // Compute dependencies for wrapped signature.\n  const hashedDomain = hashStruct({\n    data: domain ?? {},\n    types: {\n      EIP712Domain: getTypesForEIP712Domain({ domain }),\n    },\n    primaryType: 'EIP712Domain',\n  })\n  const hashedContents = hashStruct({\n    data: message,\n    types: types as any,\n    primaryType,\n  })\n  const encodedType = encodeType({\n    primaryType,\n    types: types as any,\n  })\n\n  // Construct wrapped signature.\n  return encodePacked(\n    ['bytes', 'bytes32', 'bytes32', 'bytes', 'uint16'],\n    [\n      signatureHex,\n      hashedDomain,\n      hashedContents,\n      stringToHex(encodedType),\n      size(stringToHex(encodedType)),\n    ],\n  )\n}\n", "import * as Signature from 'ox/Signature'\nimport * as WebAuthnP256 from 'ox/WebAuthnP256'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport { hashMessage } from '../../utils/signature/hashMessage.js'\nimport { hashTypedData } from '../../utils/signature/hashTypedData.js'\nimport type { P256Credential } from './createWebAuthnCredential.js'\nimport type { WebAuthnAccount } from './types.js'\n\nexport type ToWebAuthnAccountParameters = {\n  /**\n   * The WebAuthn P256 credential to use.\n   */\n  credential: {\n    id: P256Credential['id']\n    publicKey: P256Credential['publicKey']\n  }\n  /**\n   * Credential request function. Useful for environments that do not support\n   * the WebAuthn API natively (i.e. React Native or testing environments).\n   *\n   * @default window.navigator.credentials.get\n   */\n  getFn?: WebAuthnP256.sign.Options['getFn'] | undefined\n  /**\n   * The relying party identifier to use.\n   */\n  rpId?: WebAuthnP256.sign.Options['rpId'] | undefined\n}\n\nexport type ToWebAuthnAccountReturnType = WebAuthnAccount\n\nexport type ToWebAuthnAccountErrorType = ErrorType\n\n/**\n * @description Creates an Account from a WebAuthn Credential.\n *\n * @returns A WebAuthn Account.\n */\nexport function toWebAuthnAccount(\n  parameters: ToWebAuthnAccountParameters,\n): WebAuthnAccount {\n  const { getFn, rpId } = parameters\n  const { id, publicKey } = parameters.credential\n  return {\n    id,\n    publicKey,\n    async sign({ hash }) {\n      const { metadata, raw, signature } = await WebAuthnP256.sign({\n        credentialId: id,\n        getFn,\n        challenge: hash,\n        rpId,\n      })\n      return {\n        signature: Signature.toHex(signature),\n        raw,\n        webauthn: metadata,\n      }\n    },\n    async signMessage({ message }) {\n      return this.sign({ hash: hashMessage(message) })\n    },\n    async signTypedData(parameters) {\n      return this.sign({ hash: hashTypedData(parameters) })\n    },\n    type: 'webAuthn',\n  }\n}\n", "import {\n  type Client,\n  type ClientConfig,\n  type CreateClientErrorType,\n  createClient,\n} from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { PaymasterRpcSchema, RpcSchema } from '../../types/eip1193.js'\nimport type { Prettify } from '../../types/utils.js'\nimport {\n  type PaymasterActions,\n  paymasterActions,\n} from './decorators/paymaster.js'\n\nexport type PaymasterClientConfig<\n  transport extends Transport = Transport,\n  rpcSchema extends RpcSchema | undefined = undefined,\n> = Prettify<\n  Pick<\n    ClientConfig<transport, undefined, undefined, rpcSchema>,\n    'cacheTime' | 'key' | 'name' | 'pollingInterval' | 'rpcSchema' | 'transport'\n  >\n>\n\nexport type PaymasterClient<\n  transport extends Transport = Transport,\n  rpcSchema extends RpcSchema | undefined = undefined,\n> = Prettify<\n  Client<\n    transport,\n    undefined,\n    undefined,\n    rpcSchema extends RpcSchema\n      ? [...PaymasterRpcSchema, ...rpcSchema]\n      : PaymasterRpcSchema,\n    PaymasterActions\n  >\n>\n\nexport type CreatePaymasterClientErrorType = CreateClientErrorType | ErrorType\n\n/**\n * Creates a Paymaster Client.\n *\n * - Docs: https://viem.sh/account-abstraction/clients/paymaster\n *\n * @param config - {@link PaymasterClientConfig}\n * @returns A Paymaster Client. {@link PaymasterClient}\n *\n * @example\n * import { http } from 'viem'\n * import { createPaymasterClient } from 'viem/account-abstraction'\n *\n * const paymasterClient = createPaymasterClient({\n *   transport: http('https://...'),\n * })\n */\nexport function createPaymasterClient<\n  transport extends Transport,\n  rpcSchema extends RpcSchema | undefined = undefined,\n>(\n  parameters: PaymasterClientConfig<transport, rpcSchema>,\n): PaymasterClient<transport, rpcSchema>\n\nexport function createPaymasterClient(\n  parameters: PaymasterClientConfig,\n): PaymasterClient {\n  const { key = 'bundler', name = 'Bundler Client', transport } = parameters\n  const client = createClient({\n    ...parameters,\n    key,\n    name,\n    transport,\n    type: 'PaymasterClient',\n  })\n  return client.extend(paymasterActions)\n}\n", "import type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport {\n  type GetPaymasterDataParameters,\n  type GetPaymasterDataReturnType,\n  getPaymasterData,\n} from '../../actions/paymaster/getPaymasterData.js'\nimport {\n  type GetPaymasterStubDataParameters,\n  type GetPaymasterStubDataReturnType,\n  getPaymasterStubData,\n} from '../../actions/paymaster/getPaymasterStubData.js'\n\nexport type PaymasterActions = {\n  /**\n   * Retrieves paymaster-related User Operation properties to be used for sending the User Operation.\n   *\n   * - Docs: https://viem.sh/account-abstraction/actions/paymaster/getPaymasterData\n   *\n   * @param client - Client to use\n   * @param parameters - {@link GetPaymasterDataParameters}\n   * @returns Paymaster-related User Operation properties. {@link GetPaymasterDataReturnType}\n   *\n   * @example\n   * import { http } from 'viem'\n   * import { createPaymasterClient } from 'viem/account-abstraction'\n   *\n   * const paymasterClient = createPaymasterClient({\n   *   transport: http('https://...'),\n   * })\n   *\n   * const userOperation = { ... }\n   *\n   * const values = await paymasterClient.getPaymasterData({\n   *   chainId: 1,\n   *   entryPointAddress: '0x...',\n   *   ...userOperation,\n   * })\n   */\n  getPaymasterData: (\n    parameters: GetPaymasterDataParameters,\n  ) => Promise<GetPaymasterDataReturnType>\n  /**\n   * Retrieves paymaster-related User Operation properties to be used for gas estimation.\n   *\n   * - Docs: https://viem.sh/account-abstraction/actions/paymaster/getPaymasterStubData\n   *\n   * @param client - Client to use\n   * @param parameters - {@link GetPaymasterStubDataParameters}\n   * @returns Paymaster-related User Operation properties. {@link GetPaymasterStubDataReturnType}\n   *\n   * @example\n   * import { http } from 'viem'\n   * import { createPaymasterClient } from 'viem/account-abstraction'\n   *\n   * const paymasterClient = createPaymasterClient({\n   *   transport: http('https://...'),\n   * })\n   *\n   * const userOperation = { ... }\n   *\n   * const values = await paymasterClient.getPaymasterStubData({\n   *   chainId: 1,\n   *   entryPointAddress: '0x...',\n   *   ...userOperation,\n   * })\n   */\n  getPaymasterStubData: (\n    parameters: GetPaymasterStubDataParameters,\n  ) => Promise<GetPaymasterStubDataReturnType>\n}\n\nexport function paymasterActions<transport extends Transport = Transport>(\n  client: Client<transport>,\n): PaymasterActions {\n  return {\n    getPaymasterData: (parameters) => getPaymasterData(client, parameters),\n    getPaymasterStubData: (parameters) =>\n      getPaymasterStubData(client, parameters),\n  }\n}\n", "export const entryPoint06Address =\n  '0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789' as const\nexport const entryPoint07Address =\n  '0x0000000071727De22E5E9d8BAf0edAc6f37da032' as const\nexport const entryPoint08Address =\n  '0x4337084D9E255Ff0702461CF8895CE9E3b5Ff108' as const\n", "import { UserOperation } from 'ox/erc4337'\n\nexport const toUserOperation = UserOperation.from\n", "/** @entrypointCategory ERCs */\n// biome-ignore lint/complexity/noUselessEmptyExport: tsdoc\nexport type {}\n\n/**\n * Utility functions and types for working with [ERC-4337 EntryPoints](https://eips.ethereum.org/EIPS/eip-4337).\n *\n * @category ERC-4337\n */\nexport * as EntryPoint from './EntryPoint.js'\n\n/**\n * Utility types for working with ERC-4337 JSON-RPC schemas.\n *\n * @category ERC-4337\n */\nexport * as RpcSchema from './RpcSchema.js'\n\n/**\n * Utility functions and types for working with [ERC-4337 User Operations](https://eips.ethereum.org/EIPS/eip-4337).\n *\n * @category ERC-4337\n */\nexport * as UserOperation from './UserOperation.js'\n\n/**\n * Utility functions and types for working with [ERC-4337 User Operation Gas](https://eips.ethereum.org/EIPS/eip-4337).\n *\n * @category ERC-4337\n */\nexport * as UserOperationGas from './UserOperationGas.js'\n\n/**\n * Utility functions and types for working with [ERC-4337 User Operation Receipts](https://eips.ethereum.org/EIPS/eip-4337).\n *\n * @category ERC-4337\n */\nexport * as UserOperationReceipt from './UserOperationReceipt.js'\n", "/**\n * EntryPoint version.\n *\n * @see https://github.com/eth-infinitism/account-abstraction/releases\n */\nexport type Version = '0.6' | '0.7' | '0.8'\n\n/** EntryPoint 0.6 ABI. */\nexport const abiV06 = [\n  {\n    inputs: [\n      { name: 'preOpGas', type: 'uint256' },\n      { name: 'paid', type: 'uint256' },\n      { name: 'validAfter', type: 'uint48' },\n      { name: 'validUntil', type: 'uint48' },\n      { name: 'targetSuccess', type: 'bool' },\n      { name: 'targetResult', type: 'bytes' },\n    ],\n    name: 'ExecutionResult',\n    type: 'error',\n  },\n  {\n    inputs: [\n      { name: 'opIndex', type: 'uint256' },\n      { name: 'reason', type: 'string' },\n    ],\n    name: 'FailedOp',\n    type: 'error',\n  },\n  {\n    inputs: [{ name: 'sender', type: 'address' }],\n    name: 'SenderAddressResult',\n    type: 'error',\n  },\n  {\n    inputs: [{ name: 'aggregator', type: 'address' }],\n    name: 'SignatureValidationFailed',\n    type: 'error',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'preOpGas', type: 'uint256' },\n          { name: 'prefund', type: 'uint256' },\n          { name: 'sigFailed', type: 'bool' },\n          { name: 'validAfter', type: 'uint48' },\n          { name: 'validUntil', type: 'uint48' },\n          { name: 'paymasterContext', type: 'bytes' },\n        ],\n\n        name: 'returnInfo',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { name: 'stake', type: 'uint256' },\n          { name: 'unstakeDelaySec', type: 'uint256' },\n        ],\n\n        name: 'senderInfo',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { name: 'stake', type: 'uint256' },\n          { name: 'unstakeDelaySec', type: 'uint256' },\n        ],\n\n        name: 'factoryInfo',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { name: 'stake', type: 'uint256' },\n          { name: 'unstakeDelaySec', type: 'uint256' },\n        ],\n\n        name: 'paymasterInfo',\n        type: 'tuple',\n      },\n    ],\n    name: 'ValidationResult',\n    type: 'error',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'preOpGas', type: 'uint256' },\n          { name: 'prefund', type: 'uint256' },\n          { name: 'sigFailed', type: 'bool' },\n          { name: 'validAfter', type: 'uint48' },\n          { name: 'validUntil', type: 'uint48' },\n          { name: 'paymasterContext', type: 'bytes' },\n        ],\n\n        name: 'returnInfo',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { name: 'stake', type: 'uint256' },\n          { name: 'unstakeDelaySec', type: 'uint256' },\n        ],\n\n        name: 'senderInfo',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { name: 'stake', type: 'uint256' },\n          { name: 'unstakeDelaySec', type: 'uint256' },\n        ],\n\n        name: 'factoryInfo',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { name: 'stake', type: 'uint256' },\n          { name: 'unstakeDelaySec', type: 'uint256' },\n        ],\n\n        name: 'paymasterInfo',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { name: 'aggregator', type: 'address' },\n          {\n            components: [\n              { name: 'stake', type: 'uint256' },\n              {\n                name: 'unstakeDelaySec',\n                type: 'uint256',\n              },\n            ],\n\n            name: 'stakeInfo',\n            type: 'tuple',\n          },\n        ],\n\n        name: 'aggregatorInfo',\n        type: 'tuple',\n      },\n    ],\n    name: 'ValidationResultWithAggregation',\n    type: 'error',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'factory',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'paymaster',\n        type: 'address',\n      },\n    ],\n    name: 'AccountDeployed',\n    type: 'event',\n  },\n  { anonymous: false, inputs: [], name: 'BeforeExecution', type: 'event' },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'totalDeposit',\n        type: 'uint256',\n      },\n    ],\n    name: 'Deposited',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'aggregator',\n        type: 'address',\n      },\n    ],\n    name: 'SignatureAggregatorChanged',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'totalStaked',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n\n        name: 'unstakeDelaySec',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeLocked',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'withdrawTime',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeUnlocked',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeWithdrawn',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: true,\n\n        name: 'paymaster',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'nonce',\n        type: 'uint256',\n      },\n      { indexed: false, name: 'success', type: 'bool' },\n      {\n        indexed: false,\n\n        name: 'actualGasCost',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n\n        name: 'actualGasUsed',\n        type: 'uint256',\n      },\n    ],\n    name: 'UserOperationEvent',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'nonce',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n\n        name: 'revertReason',\n        type: 'bytes',\n      },\n    ],\n    name: 'UserOperationRevertReason',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'Withdrawn',\n    type: 'event',\n  },\n  {\n    inputs: [],\n    name: 'SIG_VALIDATION_FAILED',\n    outputs: [{ name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: 'initCode', type: 'bytes' },\n      { name: 'sender', type: 'address' },\n      { name: 'paymasterAndData', type: 'bytes' },\n    ],\n    name: '_validateSenderAndPaymaster',\n    outputs: [],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'unstakeDelaySec', type: 'uint32' }],\n    name: 'addStake',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'account', type: 'address' }],\n    name: 'balanceOf',\n    outputs: [{ name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'account', type: 'address' }],\n    name: 'depositTo',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: '', type: 'address' }],\n    name: 'deposits',\n    outputs: [\n      { name: 'deposit', type: 'uint112' },\n      { name: 'staked', type: 'bool' },\n      { name: 'stake', type: 'uint112' },\n      { name: 'unstakeDelaySec', type: 'uint32' },\n      { name: 'withdrawTime', type: 'uint48' },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'account', type: 'address' }],\n    name: 'getDepositInfo',\n    outputs: [\n      {\n        components: [\n          { name: 'deposit', type: 'uint112' },\n          { name: 'staked', type: 'bool' },\n          { name: 'stake', type: 'uint112' },\n          { name: 'unstakeDelaySec', type: 'uint32' },\n          { name: 'withdrawTime', type: 'uint48' },\n        ],\n\n        name: 'info',\n        type: 'tuple',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: 'sender', type: 'address' },\n      { name: 'key', type: 'uint192' },\n    ],\n    name: 'getNonce',\n    outputs: [{ name: 'nonce', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'initCode', type: 'bytes' }],\n    name: 'getSenderAddress',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'sender', type: 'address' },\n          { name: 'nonce', type: 'uint256' },\n          { name: 'initCode', type: 'bytes' },\n          { name: 'callData', type: 'bytes' },\n          { name: 'callGasLimit', type: 'uint256' },\n          {\n            name: 'verificationGasLimit',\n            type: 'uint256',\n          },\n          {\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { name: 'maxFeePerGas', type: 'uint256' },\n          {\n            name: 'maxPriorityFeePerGas',\n            type: 'uint256',\n          },\n          { name: 'paymasterAndData', type: 'bytes' },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'userOp',\n        type: 'tuple',\n      },\n    ],\n    name: 'getUserOpHash',\n    outputs: [{ name: '', type: 'bytes32' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            components: [\n              { name: 'sender', type: 'address' },\n              { name: 'nonce', type: 'uint256' },\n              { name: 'initCode', type: 'bytes' },\n              { name: 'callData', type: 'bytes' },\n              {\n                name: 'callGasLimit',\n                type: 'uint256',\n              },\n              {\n                name: 'verificationGasLimit',\n                type: 'uint256',\n              },\n              {\n                name: 'preVerificationGas',\n                type: 'uint256',\n              },\n              {\n                name: 'maxFeePerGas',\n                type: 'uint256',\n              },\n              {\n                name: 'maxPriorityFeePerGas',\n                type: 'uint256',\n              },\n              {\n                name: 'paymasterAndData',\n                type: 'bytes',\n              },\n              { name: 'signature', type: 'bytes' },\n            ],\n\n            name: 'userOps',\n            type: 'tuple[]',\n          },\n          {\n            name: 'aggregator',\n            type: 'address',\n          },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'opsPerAggregator',\n        type: 'tuple[]',\n      },\n      { name: 'beneficiary', type: 'address' },\n    ],\n    name: 'handleAggregatedOps',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'sender', type: 'address' },\n          { name: 'nonce', type: 'uint256' },\n          { name: 'initCode', type: 'bytes' },\n          { name: 'callData', type: 'bytes' },\n          { name: 'callGasLimit', type: 'uint256' },\n          {\n            name: 'verificationGasLimit',\n            type: 'uint256',\n          },\n          {\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { name: 'maxFeePerGas', type: 'uint256' },\n          {\n            name: 'maxPriorityFeePerGas',\n            type: 'uint256',\n          },\n          { name: 'paymasterAndData', type: 'bytes' },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'ops',\n        type: 'tuple[]',\n      },\n      { name: 'beneficiary', type: 'address' },\n    ],\n    name: 'handleOps',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'key', type: 'uint192' }],\n    name: 'incrementNonce',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: 'callData', type: 'bytes' },\n      {\n        components: [\n          {\n            components: [\n              { name: 'sender', type: 'address' },\n              { name: 'nonce', type: 'uint256' },\n              {\n                name: 'callGasLimit',\n                type: 'uint256',\n              },\n              {\n                name: 'verificationGasLimit',\n                type: 'uint256',\n              },\n              {\n                name: 'preVerificationGas',\n                type: 'uint256',\n              },\n              { name: 'paymaster', type: 'address' },\n              {\n                name: 'maxFeePerGas',\n                type: 'uint256',\n              },\n              {\n                name: 'maxPriorityFeePerGas',\n                type: 'uint256',\n              },\n            ],\n\n            name: 'mUserOp',\n            type: 'tuple',\n          },\n          { name: 'userOpHash', type: 'bytes32' },\n          { name: 'prefund', type: 'uint256' },\n          { name: 'contextOffset', type: 'uint256' },\n          { name: 'preOpGas', type: 'uint256' },\n        ],\n\n        name: 'opInfo',\n        type: 'tuple',\n      },\n      { name: 'context', type: 'bytes' },\n    ],\n    name: 'innerHandleOp',\n    outputs: [{ name: 'actualGasCost', type: 'uint256' }],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: '', type: 'address' },\n      { name: '', type: 'uint192' },\n    ],\n    name: 'nonceSequenceNumber',\n    outputs: [{ name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'sender', type: 'address' },\n          { name: 'nonce', type: 'uint256' },\n          { name: 'initCode', type: 'bytes' },\n          { name: 'callData', type: 'bytes' },\n          { name: 'callGasLimit', type: 'uint256' },\n          {\n            name: 'verificationGasLimit',\n            type: 'uint256',\n          },\n          {\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { name: 'maxFeePerGas', type: 'uint256' },\n          {\n            name: 'maxPriorityFeePerGas',\n            type: 'uint256',\n          },\n          { name: 'paymasterAndData', type: 'bytes' },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'op',\n        type: 'tuple',\n      },\n      { name: 'target', type: 'address' },\n      { name: 'targetCallData', type: 'bytes' },\n    ],\n    name: 'simulateHandleOp',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'sender', type: 'address' },\n          { name: 'nonce', type: 'uint256' },\n          { name: 'initCode', type: 'bytes' },\n          { name: 'callData', type: 'bytes' },\n          { name: 'callGasLimit', type: 'uint256' },\n          {\n            name: 'verificationGasLimit',\n            type: 'uint256',\n          },\n          {\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { name: 'maxFeePerGas', type: 'uint256' },\n          {\n            name: 'maxPriorityFeePerGas',\n            type: 'uint256',\n          },\n          { name: 'paymasterAndData', type: 'bytes' },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'userOp',\n        type: 'tuple',\n      },\n    ],\n    name: 'simulateValidation',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'unlockStake',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n    ],\n    name: 'withdrawStake',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      { name: 'withdrawAmount', type: 'uint256' },\n    ],\n    name: 'withdrawTo',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  { stateMutability: 'payable', type: 'receive' },\n] as const\n\n/** EntryPoint 0.7 ABI. */\nexport const abiV07 = [\n  {\n    inputs: [\n      { name: 'success', type: 'bool' },\n      { name: 'ret', type: 'bytes' },\n    ],\n    name: 'DelegateAndRevert',\n    type: 'error',\n  },\n  {\n    inputs: [\n      { name: 'opIndex', type: 'uint256' },\n      { name: 'reason', type: 'string' },\n    ],\n    name: 'FailedOp',\n    type: 'error',\n  },\n  {\n    inputs: [\n      { name: 'opIndex', type: 'uint256' },\n      { name: 'reason', type: 'string' },\n      { name: 'inner', type: 'bytes' },\n    ],\n    name: 'FailedOpWithRevert',\n    type: 'error',\n  },\n  {\n    inputs: [{ name: 'returnData', type: 'bytes' }],\n    name: 'PostOpReverted',\n    type: 'error',\n  },\n  { inputs: [], name: 'ReentrancyGuardReentrantCall', type: 'error' },\n  {\n    inputs: [{ name: 'sender', type: 'address' }],\n    name: 'SenderAddressResult',\n    type: 'error',\n  },\n  {\n    inputs: [{ name: 'aggregator', type: 'address' }],\n    name: 'SignatureValidationFailed',\n    type: 'error',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'factory',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'paymaster',\n        type: 'address',\n      },\n    ],\n    name: 'AccountDeployed',\n    type: 'event',\n  },\n  { anonymous: false, inputs: [], name: 'BeforeExecution', type: 'event' },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'totalDeposit',\n        type: 'uint256',\n      },\n    ],\n    name: 'Deposited',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'nonce',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n\n        name: 'revertReason',\n        type: 'bytes',\n      },\n    ],\n    name: 'PostOpRevertReason',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'aggregator',\n        type: 'address',\n      },\n    ],\n    name: 'SignatureAggregatorChanged',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'totalStaked',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n\n        name: 'unstakeDelaySec',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeLocked',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'withdrawTime',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeUnlocked',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeWithdrawn',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: true,\n\n        name: 'paymaster',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'nonce',\n        type: 'uint256',\n      },\n      { indexed: false, name: 'success', type: 'bool' },\n      {\n        indexed: false,\n\n        name: 'actualGasCost',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n\n        name: 'actualGasUsed',\n        type: 'uint256',\n      },\n    ],\n    name: 'UserOperationEvent',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'nonce',\n        type: 'uint256',\n      },\n    ],\n    name: 'UserOperationPrefundTooLow',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'nonce',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n\n        name: 'revertReason',\n        type: 'bytes',\n      },\n    ],\n    name: 'UserOperationRevertReason',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'Withdrawn',\n    type: 'event',\n  },\n  {\n    inputs: [{ name: 'unstakeDelaySec', type: 'uint32' }],\n    name: 'addStake',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'account', type: 'address' }],\n    name: 'balanceOf',\n    outputs: [{ name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: 'target', type: 'address' },\n      { name: 'data', type: 'bytes' },\n    ],\n    name: 'delegateAndRevert',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'account', type: 'address' }],\n    name: 'depositTo',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: '', type: 'address' }],\n    name: 'deposits',\n    outputs: [\n      { name: 'deposit', type: 'uint256' },\n      { name: 'staked', type: 'bool' },\n      { name: 'stake', type: 'uint112' },\n      { name: 'unstakeDelaySec', type: 'uint32' },\n      { name: 'withdrawTime', type: 'uint48' },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'account', type: 'address' }],\n    name: 'getDepositInfo',\n    outputs: [\n      {\n        components: [\n          { name: 'deposit', type: 'uint256' },\n          { name: 'staked', type: 'bool' },\n          { name: 'stake', type: 'uint112' },\n          { name: 'unstakeDelaySec', type: 'uint32' },\n          { name: 'withdrawTime', type: 'uint48' },\n        ],\n\n        name: 'info',\n        type: 'tuple',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: 'sender', type: 'address' },\n      { name: 'key', type: 'uint192' },\n    ],\n    name: 'getNonce',\n    outputs: [{ name: 'nonce', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'initCode', type: 'bytes' }],\n    name: 'getSenderAddress',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'sender', type: 'address' },\n          { name: 'nonce', type: 'uint256' },\n          { name: 'initCode', type: 'bytes' },\n          { name: 'callData', type: 'bytes' },\n          {\n            name: 'accountGasLimits',\n            type: 'bytes32',\n          },\n          {\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { name: 'gasFees', type: 'bytes32' },\n          { name: 'paymasterAndData', type: 'bytes' },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'userOp',\n        type: 'tuple',\n      },\n    ],\n    name: 'getUserOpHash',\n    outputs: [{ name: '', type: 'bytes32' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            components: [\n              { name: 'sender', type: 'address' },\n              { name: 'nonce', type: 'uint256' },\n              { name: 'initCode', type: 'bytes' },\n              { name: 'callData', type: 'bytes' },\n              {\n                name: 'accountGasLimits',\n                type: 'bytes32',\n              },\n              {\n                name: 'preVerificationGas',\n                type: 'uint256',\n              },\n              { name: 'gasFees', type: 'bytes32' },\n              {\n                name: 'paymasterAndData',\n                type: 'bytes',\n              },\n              { name: 'signature', type: 'bytes' },\n            ],\n\n            name: 'userOps',\n            type: 'tuple[]',\n          },\n          {\n            name: 'aggregator',\n            type: 'address',\n          },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'opsPerAggregator',\n        type: 'tuple[]',\n      },\n      { name: 'beneficiary', type: 'address' },\n    ],\n    name: 'handleAggregatedOps',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'sender', type: 'address' },\n          { name: 'nonce', type: 'uint256' },\n          { name: 'initCode', type: 'bytes' },\n          { name: 'callData', type: 'bytes' },\n          {\n            name: 'accountGasLimits',\n            type: 'bytes32',\n          },\n          {\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { name: 'gasFees', type: 'bytes32' },\n          { name: 'paymasterAndData', type: 'bytes' },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'ops',\n        type: 'tuple[]',\n      },\n      { name: 'beneficiary', type: 'address' },\n    ],\n    name: 'handleOps',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'key', type: 'uint192' }],\n    name: 'incrementNonce',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: 'callData', type: 'bytes' },\n      {\n        components: [\n          {\n            components: [\n              { name: 'sender', type: 'address' },\n              { name: 'nonce', type: 'uint256' },\n              {\n                name: 'verificationGasLimit',\n                type: 'uint256',\n              },\n              {\n                name: 'callGasLimit',\n                type: 'uint256',\n              },\n              {\n                name: 'paymasterVerificationGasLimit',\n                type: 'uint256',\n              },\n              {\n                name: 'paymasterPostOpGasLimit',\n                type: 'uint256',\n              },\n              {\n                name: 'preVerificationGas',\n                type: 'uint256',\n              },\n              { name: 'paymaster', type: 'address' },\n              {\n                name: 'maxFeePerGas',\n                type: 'uint256',\n              },\n              {\n                name: 'maxPriorityFeePerGas',\n                type: 'uint256',\n              },\n            ],\n\n            name: 'mUserOp',\n            type: 'tuple',\n          },\n          { name: 'userOpHash', type: 'bytes32' },\n          { name: 'prefund', type: 'uint256' },\n          { name: 'contextOffset', type: 'uint256' },\n          { name: 'preOpGas', type: 'uint256' },\n        ],\n\n        name: 'opInfo',\n        type: 'tuple',\n      },\n      { name: 'context', type: 'bytes' },\n    ],\n    name: 'innerHandleOp',\n    outputs: [{ name: 'actualGasCost', type: 'uint256' }],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: '', type: 'address' },\n      { name: '', type: 'uint192' },\n    ],\n    name: 'nonceSequenceNumber',\n    outputs: [{ name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'interfaceId', type: 'bytes4' }],\n    name: 'supportsInterface',\n    outputs: [{ name: '', type: 'bool' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'unlockStake',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n    ],\n    name: 'withdrawStake',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      { name: 'withdrawAmount', type: 'uint256' },\n    ],\n    name: 'withdrawTo',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  { stateMutability: 'payable', type: 'receive' },\n] as const\n\n/** EntryPoint 0.8 ABI. */\nexport const abiV08 = [\n  { inputs: [], stateMutability: 'nonpayable', type: 'constructor' },\n  {\n    inputs: [\n      { internalType: 'bool', name: 'success', type: 'bool' },\n      { internalType: 'bytes', name: 'ret', type: 'bytes' },\n    ],\n    name: 'DelegateAndRevert',\n    type: 'error',\n  },\n  {\n    inputs: [\n      { internalType: 'uint256', name: 'opIndex', type: 'uint256' },\n      { internalType: 'string', name: 'reason', type: 'string' },\n    ],\n    name: 'FailedOp',\n    type: 'error',\n  },\n  {\n    inputs: [\n      { internalType: 'uint256', name: 'opIndex', type: 'uint256' },\n      { internalType: 'string', name: 'reason', type: 'string' },\n      { internalType: 'bytes', name: 'inner', type: 'bytes' },\n    ],\n    name: 'FailedOpWithRevert',\n    type: 'error',\n  },\n  { inputs: [], name: 'InvalidShortString', type: 'error' },\n  {\n    inputs: [{ internalType: 'bytes', name: 'returnData', type: 'bytes' }],\n    name: 'PostOpReverted',\n    type: 'error',\n  },\n  { inputs: [], name: 'ReentrancyGuardReentrantCall', type: 'error' },\n  {\n    inputs: [{ internalType: 'address', name: 'sender', type: 'address' }],\n    name: 'SenderAddressResult',\n    type: 'error',\n  },\n  {\n    inputs: [{ internalType: 'address', name: 'aggregator', type: 'address' }],\n    name: 'SignatureValidationFailed',\n    type: 'error',\n  },\n  {\n    inputs: [{ internalType: 'string', name: 'str', type: 'string' }],\n    name: 'StringTooLong',\n    type: 'error',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'address',\n        name: 'factory',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'address',\n        name: 'paymaster',\n        type: 'address',\n      },\n    ],\n    name: 'AccountDeployed',\n    type: 'event',\n  },\n  { anonymous: false, inputs: [], name: 'BeforeExecution', type: 'event' },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'totalDeposit',\n        type: 'uint256',\n      },\n    ],\n    name: 'Deposited',\n    type: 'event',\n  },\n  { anonymous: false, inputs: [], name: 'EIP712DomainChanged', type: 'event' },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'nonce',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n        internalType: 'bytes',\n        name: 'revertReason',\n        type: 'bytes',\n      },\n    ],\n    name: 'PostOpRevertReason',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'aggregator',\n        type: 'address',\n      },\n    ],\n    name: 'SignatureAggregatorChanged',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'totalStaked',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'unstakeDelaySec',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeLocked',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'withdrawTime',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeUnlocked',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'address',\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeWithdrawn',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'paymaster',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'nonce',\n        type: 'uint256',\n      },\n      { indexed: false, internalType: 'bool', name: 'success', type: 'bool' },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'actualGasCost',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'actualGasUsed',\n        type: 'uint256',\n      },\n    ],\n    name: 'UserOperationEvent',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'nonce',\n        type: 'uint256',\n      },\n    ],\n    name: 'UserOperationPrefundTooLow',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'nonce',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n        internalType: 'bytes',\n        name: 'revertReason',\n        type: 'bytes',\n      },\n    ],\n    name: 'UserOperationRevertReason',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'address',\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'Withdrawn',\n    type: 'event',\n  },\n  {\n    inputs: [\n      { internalType: 'uint32', name: 'unstakeDelaySec', type: 'uint32' },\n    ],\n    name: 'addStake',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'address', name: 'account', type: 'address' }],\n    name: 'balanceOf',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'address', name: 'target', type: 'address' },\n      { internalType: 'bytes', name: 'data', type: 'bytes' },\n    ],\n    name: 'delegateAndRevert',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'address', name: 'account', type: 'address' }],\n    name: 'depositTo',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'eip712Domain',\n    outputs: [\n      { internalType: 'bytes1', name: 'fields', type: 'bytes1' },\n      { internalType: 'string', name: 'name', type: 'string' },\n      { internalType: 'string', name: 'version', type: 'string' },\n      { internalType: 'uint256', name: 'chainId', type: 'uint256' },\n      { internalType: 'address', name: 'verifyingContract', type: 'address' },\n      { internalType: 'bytes32', name: 'salt', type: 'bytes32' },\n      { internalType: 'uint256[]', name: 'extensions', type: 'uint256[]' },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'address', name: 'account', type: 'address' }],\n    name: 'getDepositInfo',\n    outputs: [\n      {\n        components: [\n          { internalType: 'uint256', name: 'deposit', type: 'uint256' },\n          { internalType: 'bool', name: 'staked', type: 'bool' },\n          { internalType: 'uint112', name: 'stake', type: 'uint112' },\n          { internalType: 'uint32', name: 'unstakeDelaySec', type: 'uint32' },\n          { internalType: 'uint48', name: 'withdrawTime', type: 'uint48' },\n        ],\n        internalType: 'struct IStakeManager.DepositInfo',\n        name: 'info',\n        type: 'tuple',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getDomainSeparatorV4',\n    outputs: [{ internalType: 'bytes32', name: '', type: 'bytes32' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'address', name: 'sender', type: 'address' },\n      { internalType: 'uint192', name: 'key', type: 'uint192' },\n    ],\n    name: 'getNonce',\n    outputs: [{ internalType: 'uint256', name: 'nonce', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getPackedUserOpTypeHash',\n    outputs: [{ internalType: 'bytes32', name: '', type: 'bytes32' }],\n    stateMutability: 'pure',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'bytes', name: 'initCode', type: 'bytes' }],\n    name: 'getSenderAddress',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: 'address', name: 'sender', type: 'address' },\n          { internalType: 'uint256', name: 'nonce', type: 'uint256' },\n          { internalType: 'bytes', name: 'initCode', type: 'bytes' },\n          { internalType: 'bytes', name: 'callData', type: 'bytes' },\n          {\n            internalType: 'bytes32',\n            name: 'accountGasLimits',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'uint256',\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { internalType: 'bytes32', name: 'gasFees', type: 'bytes32' },\n          { internalType: 'bytes', name: 'paymasterAndData', type: 'bytes' },\n          { internalType: 'bytes', name: 'signature', type: 'bytes' },\n        ],\n        internalType: 'struct PackedUserOperation',\n        name: 'userOp',\n        type: 'tuple',\n      },\n    ],\n    name: 'getUserOpHash',\n    outputs: [{ internalType: 'bytes32', name: '', type: 'bytes32' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            components: [\n              { internalType: 'address', name: 'sender', type: 'address' },\n              { internalType: 'uint256', name: 'nonce', type: 'uint256' },\n              { internalType: 'bytes', name: 'initCode', type: 'bytes' },\n              { internalType: 'bytes', name: 'callData', type: 'bytes' },\n              {\n                internalType: 'bytes32',\n                name: 'accountGasLimits',\n                type: 'bytes32',\n              },\n              {\n                internalType: 'uint256',\n                name: 'preVerificationGas',\n                type: 'uint256',\n              },\n              { internalType: 'bytes32', name: 'gasFees', type: 'bytes32' },\n              {\n                internalType: 'bytes',\n                name: 'paymasterAndData',\n                type: 'bytes',\n              },\n              { internalType: 'bytes', name: 'signature', type: 'bytes' },\n            ],\n            internalType: 'struct PackedUserOperation[]',\n            name: 'userOps',\n            type: 'tuple[]',\n          },\n          {\n            internalType: 'contract IAggregator',\n            name: 'aggregator',\n            type: 'address',\n          },\n          { internalType: 'bytes', name: 'signature', type: 'bytes' },\n        ],\n        internalType: 'struct IEntryPoint.UserOpsPerAggregator[]',\n        name: 'opsPerAggregator',\n        type: 'tuple[]',\n      },\n      { internalType: 'address payable', name: 'beneficiary', type: 'address' },\n    ],\n    name: 'handleAggregatedOps',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: 'address', name: 'sender', type: 'address' },\n          { internalType: 'uint256', name: 'nonce', type: 'uint256' },\n          { internalType: 'bytes', name: 'initCode', type: 'bytes' },\n          { internalType: 'bytes', name: 'callData', type: 'bytes' },\n          {\n            internalType: 'bytes32',\n            name: 'accountGasLimits',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'uint256',\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { internalType: 'bytes32', name: 'gasFees', type: 'bytes32' },\n          { internalType: 'bytes', name: 'paymasterAndData', type: 'bytes' },\n          { internalType: 'bytes', name: 'signature', type: 'bytes' },\n        ],\n        internalType: 'struct PackedUserOperation[]',\n        name: 'ops',\n        type: 'tuple[]',\n      },\n      { internalType: 'address payable', name: 'beneficiary', type: 'address' },\n    ],\n    name: 'handleOps',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'uint192', name: 'key', type: 'uint192' }],\n    name: 'incrementNonce',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'bytes', name: 'callData', type: 'bytes' },\n      {\n        components: [\n          {\n            components: [\n              { internalType: 'address', name: 'sender', type: 'address' },\n              { internalType: 'uint256', name: 'nonce', type: 'uint256' },\n              {\n                internalType: 'uint256',\n                name: 'verificationGasLimit',\n                type: 'uint256',\n              },\n              {\n                internalType: 'uint256',\n                name: 'callGasLimit',\n                type: 'uint256',\n              },\n              {\n                internalType: 'uint256',\n                name: 'paymasterVerificationGasLimit',\n                type: 'uint256',\n              },\n              {\n                internalType: 'uint256',\n                name: 'paymasterPostOpGasLimit',\n                type: 'uint256',\n              },\n              {\n                internalType: 'uint256',\n                name: 'preVerificationGas',\n                type: 'uint256',\n              },\n              { internalType: 'address', name: 'paymaster', type: 'address' },\n              {\n                internalType: 'uint256',\n                name: 'maxFeePerGas',\n                type: 'uint256',\n              },\n              {\n                internalType: 'uint256',\n                name: 'maxPriorityFeePerGas',\n                type: 'uint256',\n              },\n            ],\n            internalType: 'struct EntryPoint.MemoryUserOp',\n            name: 'mUserOp',\n            type: 'tuple',\n          },\n          { internalType: 'bytes32', name: 'userOpHash', type: 'bytes32' },\n          { internalType: 'uint256', name: 'prefund', type: 'uint256' },\n          { internalType: 'uint256', name: 'contextOffset', type: 'uint256' },\n          { internalType: 'uint256', name: 'preOpGas', type: 'uint256' },\n        ],\n        internalType: 'struct EntryPoint.UserOpInfo',\n        name: 'opInfo',\n        type: 'tuple',\n      },\n      { internalType: 'bytes', name: 'context', type: 'bytes' },\n    ],\n    name: 'innerHandleOp',\n    outputs: [\n      { internalType: 'uint256', name: 'actualGasCost', type: 'uint256' },\n    ],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'address', name: '', type: 'address' },\n      { internalType: 'uint192', name: '', type: 'uint192' },\n    ],\n    name: 'nonceSequenceNumber',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'senderCreator',\n    outputs: [\n      { internalType: 'contract ISenderCreator', name: '', type: 'address' },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'bytes4', name: 'interfaceId', type: 'bytes4' }],\n    name: 'supportsInterface',\n    outputs: [{ internalType: 'bool', name: '', type: 'bool' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'unlockStake',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address payable',\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n    ],\n    name: 'withdrawStake',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address payable',\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      { internalType: 'uint256', name: 'withdrawAmount', type: 'uint256' },\n    ],\n    name: 'withdrawTo',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  { stateMutability: 'payable', type: 'receive' },\n] as const\n\n/** EntryPoint 0.6 address. */\nexport const addressV06 = '0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789' as const\n\n/** EntryPoint 0.7 address. */\nexport const addressV07 = '0x0000000071727De22E5E9d8BAf0edAc6f37da032' as const\n\n/** EntryPoint 0.8 address. */\nexport const addressV08 = '0x4337084D9E255Ff0702461CF8895CE9E3b5Ff108' as const\n", "export {};\n//# sourceMappingURL=RpcSchema.js.map", "import * as AbiParameters from '../core/AbiParameters.js'\nimport type * as Address from '../core/Address.js'\nimport type * as Authorization from '../core/Authorization.js'\nimport type * as Errors from '../core/Errors.js'\nimport * as Hash from '../core/Hash.js'\nimport * as Hex from '../core/Hex.js'\nimport type { Assign, Compute, OneOf } from '../core/internal/types.js'\nimport * as Signature from '../core/Signature.js'\nimport * as TypedData from '../core/TypedData.js'\nimport type * as EntryPoint from './EntryPoint.js'\n\n/** User Operation. */\nexport type UserOperation<\n  entryPointVersion extends EntryPoint.Version = EntryPoint.Version,\n  signed extends boolean = boolean,\n  bigintType = bigint,\n  numberType = number,\n> = OneOf<\n  | (entryPointVersion extends '0.6' ? V06<signed, bigintType> : never)\n  | (entryPointVersion extends '0.7' ? V07<signed, bigintType> : never)\n  | (entryPointVersion extends '0.8'\n      ? V08<signed, bigintType, numberType>\n      : never)\n>\n\n/**\n * Packed User Operation.\n *\n * @see https://eips.ethereum.org/EIPS/eip-4337#entrypoint-definition\n */\nexport type Packed = {\n  /** Concatenation of `verificationGasLimit` (16 bytes) and `callGasLimit` (16 bytes) */\n  accountGasLimits: Hex.Hex\n  /** The data to pass to the `sender` during the main execution call. */\n  callData: Hex.Hex\n  /** Concatenation of `factory` and `factoryData`. */\n  initCode: Hex.Hex\n  /** Concatenation of `maxPriorityFee` (16 bytes) and `maxFeePerGas` (16 bytes) */\n  gasFees: Hex.Hex\n  /** Anti-replay parameter. */\n  nonce: bigint\n  /** Concatenation of paymaster fields (or empty). */\n  paymasterAndData: Hex.Hex\n  /** Extra gas to pay the Bundler. */\n  preVerificationGas: bigint\n  /** The account making the operation. */\n  sender: Address.Address\n  /** Data passed into the account to verify authorization. */\n  signature: Hex.Hex\n}\n\n/** RPC User Operation type. */\nexport type Rpc<\n  entryPointVersion extends EntryPoint.Version = EntryPoint.Version,\n  signed extends boolean = true,\n> = OneOf<\n  | (entryPointVersion extends '0.6' ? V06<signed, Hex.Hex> : never)\n  | (entryPointVersion extends '0.7' ? V07<signed, Hex.Hex> : never)\n  | (entryPointVersion extends '0.8' ? V08<signed, Hex.Hex, Hex.Hex> : never)\n>\n\n/** Transaction Info. */\nexport type TransactionInfo<\n  entryPointVersion extends EntryPoint.Version = EntryPoint.Version,\n  bigintType = bigint,\n> = {\n  blockHash: Hex.Hex\n  blockNumber: bigintType\n  entryPoint: Address.Address\n  transactionHash: Hex.Hex\n  userOperation: UserOperation<entryPointVersion, true, bigintType>\n}\n\n/** RPC Transaction Info. */\nexport type RpcTransactionInfo<\n  entryPointVersion extends EntryPoint.Version = EntryPoint.Version,\n> = TransactionInfo<entryPointVersion, Hex.Hex>\n\n/** Type for User Operation on EntryPoint 0.6 */\nexport type V06<signed extends boolean = boolean, bigintType = bigint> = {\n  /** The data to pass to the `sender` during the main execution call. */\n  callData: Hex.Hex\n  /** The amount of gas to allocate the main execution call */\n  callGasLimit: bigintType\n  /** Account init code. Only for new accounts. */\n  initCode?: Hex.Hex | undefined\n  /** Maximum fee per gas. */\n  maxFeePerGas: bigintType\n  /** Maximum priority fee per gas. */\n  maxPriorityFeePerGas: bigintType\n  /** Anti-replay parameter. */\n  nonce: bigintType\n  /** Paymaster address with calldata. */\n  paymasterAndData?: Hex.Hex | undefined\n  /** Extra gas to pay the Bundler. */\n  preVerificationGas: bigintType\n  /** The account making the operation. */\n  sender: Address.Address\n  /** Data passed into the account to verify authorization. */\n  signature?: Hex.Hex | undefined\n  /** The amount of gas to allocate for the verification step. */\n  verificationGasLimit: bigintType\n} & (signed extends true ? { signature: Hex.Hex } : {})\n\n/** RPC User Operation on EntryPoint 0.6 */\nexport type RpcV06<signed extends boolean = true> = V06<signed, Hex.Hex>\n\n/** Type for User Operation on EntryPoint 0.7 */\nexport type V07<signed extends boolean = boolean, bigintType = bigint> = {\n  /** The data to pass to the `sender` during the main execution call. */\n  callData: Hex.Hex\n  /** The amount of gas to allocate the main execution call */\n  callGasLimit: bigintType\n  /** Account factory. Only for new accounts. */\n  factory?: Address.Address | undefined\n  /** Data for account factory. */\n  factoryData?: Hex.Hex | undefined\n  /** Maximum fee per gas. */\n  maxFeePerGas: bigintType\n  /** Maximum priority fee per gas. */\n  maxPriorityFeePerGas: bigintType\n  /** Anti-replay parameter. */\n  nonce: bigintType\n  /** Address of paymaster contract. */\n  paymaster?: Address.Address | undefined\n  /** Data for paymaster. */\n  paymasterData?: Hex.Hex | undefined\n  /** The amount of gas to allocate for the paymaster post-operation code. */\n  paymasterPostOpGasLimit?: bigintType | undefined\n  /** The amount of gas to allocate for the paymaster validation code. */\n  paymasterVerificationGasLimit?: bigintType | undefined\n  /** Extra gas to pay the Bundler. */\n  preVerificationGas: bigintType\n  /** The account making the operation. */\n  sender: Address.Address\n  /** Data passed into the account to verify authorization. */\n  signature?: Hex.Hex | undefined\n  /** The amount of gas to allocate for the verification step. */\n  verificationGasLimit: bigintType\n} & (signed extends true ? { signature: Hex.Hex } : {})\n\n/** RPC User Operation on EntryPoint 0.7 */\nexport type RpcV07<signed extends boolean = true> = V07<signed, Hex.Hex>\n\n/** Type for User Operation on EntryPoint 0.8 */\nexport type V08<\n  signed extends boolean = boolean,\n  bigintType = bigint,\n  numberType = number,\n> = {\n  /** Authorization data. */\n  authorization?: Authorization.Signed<bigintType, numberType> | undefined\n  /** The data to pass to the `sender` during the main execution call. */\n  callData: Hex.Hex\n  /** The amount of gas to allocate the main execution call */\n  callGasLimit: bigintType\n  /** Account factory. Only for new accounts. */\n  factory?: Address.Address | undefined\n  /** Data for account factory. */\n  factoryData?: Hex.Hex | undefined\n  /** Maximum fee per gas. */\n  maxFeePerGas: bigintType\n  /** Maximum priority fee per gas. */\n  maxPriorityFeePerGas: bigintType\n  /** Anti-replay parameter. */\n  nonce: bigintType\n  /** Address of paymaster contract. */\n  paymaster?: Address.Address | undefined\n  /** Data for paymaster. */\n  paymasterData?: Hex.Hex | undefined\n  /** The amount of gas to allocate for the paymaster post-operation code. */\n  paymasterPostOpGasLimit?: bigintType | undefined\n  /** The amount of gas to allocate for the paymaster validation code. */\n  paymasterVerificationGasLimit?: bigintType | undefined\n  /** Extra gas to pay the Bundler. */\n  preVerificationGas: bigintType\n  /** The account making the operation. */\n  sender: Address.Address\n  /** Data passed into the account to verify authorization. */\n  signature?: Hex.Hex | undefined\n  /** The amount of gas to allocate for the verification step. */\n  verificationGasLimit: bigintType\n} & (signed extends true ? { signature: Hex.Hex } : {})\n\n/** RPC User Operation on EntryPoint 0.8 */\nexport type RpcV08<signed extends boolean = true> = V08<\n  signed,\n  Hex.Hex,\n  Hex.Hex\n>\n\n/**\n * Instantiates a {@link ox#UserOperation.UserOperation} from a provided input.\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n * import { UserOperation } from 'ox/erc4337'\n *\n * const userOperation = UserOperation.from({\n *   callData: '0xdeadbeef',\n *   callGasLimit: 300_000n,\n *   maxFeePerGas: Value.fromGwei('20'),\n *   maxPriorityFeePerGas: Value.fromGwei('2'),\n *   nonce: 69n,\n *   preVerificationGas: 100_000n,\n *   sender: '0x9f1fdab6458c5fc642fa0f4c5af7473c46837357',\n *   verificationGasLimit: 100_000n,\n * })\n * ```\n *\n * @example\n * ### From Packed User Operation\n *\n * ```ts twoslash\n * import { UserOperation } from 'ox/erc4337'\n *\n * const packed: UserOperation.Packed = {\n *   accountGasLimits: '0x...',\n *   callData: '0xdeadbeef',\n *   initCode: '0x',\n *   gasFees: '0x...',\n *   nonce: 69n,\n *   paymasterAndData: '0x',\n *   preVerificationGas: 100_000n,\n *   sender: '0x9f1fdab6458c5fc642fa0f4c5af7473c46837357',\n *   signature: '0x',\n * }\n *\n * const userOperation = UserOperation.from(packed)\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * ```ts twoslash\n * import { Secp256k1, Value } from 'ox'\n * import { UserOperation } from 'ox/erc4337'\n *\n * const userOperation = UserOperation.from({\n *   callData: '0xdeadbeef',\n *   callGasLimit: 300_000n,\n *   maxFeePerGas: Value.fromGwei('20'),\n *   maxPriorityFeePerGas: Value.fromGwei('2'),\n *   nonce: 69n,\n *   preVerificationGas: 100_000n,\n *   sender: '0x9f1fdab6458c5fc642fa0f4c5af7473c46837357',\n *   verificationGasLimit: 100_000n,\n * })\n *\n * const payload = UserOperation.getSignPayload(userOperation, {\n *   chainId: 1,\n *   entryPointAddress: '0x1234567890123456789012345678901234567890',\n *   entryPointVersion: '0.7',\n * })\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n *\n * const userOperation_signed = UserOperation.from(userOperation, { signature }) // [!code focus]\n * ```\n *\n * @param userOperation - The user operation to instantiate (structured or packed format).\n * @returns User Operation.\n */\nexport function from<\n  const userOperation extends UserOperation | Packed,\n  const signature extends Hex.Hex | undefined = undefined,\n>(\n  userOperation: userOperation | UserOperation | Packed,\n  options: from.Options<signature> = {},\n): from.ReturnType<userOperation, signature> {\n  const signature = (() => {\n    if (typeof options.signature === 'string') return options.signature\n    if (typeof options.signature === 'object')\n      return Signature.toHex(options.signature)\n    if (userOperation.signature) return userOperation.signature\n    return undefined\n  })()\n\n  const packed =\n    'accountGasLimits' in userOperation && 'gasFees' in userOperation\n\n  const userOp = packed ? fromPacked(userOperation) : userOperation\n  return { ...userOp, signature } as never\n}\n\nexport declare namespace from {\n  export type Options<\n    signature extends Signature.Signature | Hex.Hex | undefined = undefined,\n  > = {\n    signature?: signature | Signature.Signature | Hex.Hex | undefined\n  }\n\n  export type ReturnType<\n    userOperation extends UserOperation | Packed = UserOperation | Packed,\n    signature extends Signature.Signature | Hex.Hex | undefined = undefined,\n  > = Compute<\n    Assign<\n      userOperation,\n      signature extends Signature.Signature | Hex.Hex\n        ? Readonly<{ signature: Hex.Hex }>\n        : {}\n    >\n  >\n\n  export type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#UserOperation.Rpc} to an {@link ox#UserOperation.UserOperation}.\n *\n * @example\n * ```ts twoslash\n * import { UserOperation } from 'ox/erc4337'\n *\n * const userOperation = UserOperation.fromRpc({\n *   callData: '0xdeadbeef',\n *   callGasLimit: '0x69420',\n *   maxFeePerGas: '0x2ca6ae494',\n *   maxPriorityFeePerGas: '0x41cc3c0',\n *   nonce: '0x357',\n *   preVerificationGas: '0x69420',\n *   signature: '0x',\n *   sender: '0x1234567890123456789012345678901234567890',\n *   verificationGasLimit: '0x69420',\n * })\n * ```\n *\n * @param rpc - The RPC user operation to convert.\n * @returns An instantiated {@link ox#UserOperation.UserOperation}.\n */\nexport function fromRpc(rpc: Rpc): UserOperation {\n  return {\n    ...rpc,\n    callGasLimit: BigInt(rpc.callGasLimit),\n    maxFeePerGas: BigInt(rpc.maxFeePerGas),\n    maxPriorityFeePerGas: BigInt(rpc.maxPriorityFeePerGas),\n    nonce: BigInt(rpc.nonce),\n    preVerificationGas: BigInt(rpc.preVerificationGas),\n    verificationGasLimit: BigInt(rpc.verificationGasLimit),\n    ...(rpc.paymasterPostOpGasLimit && {\n      paymasterPostOpGasLimit: BigInt(rpc.paymasterPostOpGasLimit),\n    }),\n    ...(rpc.paymasterVerificationGasLimit && {\n      paymasterVerificationGasLimit: BigInt(rpc.paymasterVerificationGasLimit),\n    }),\n  } as UserOperation\n}\n\nexport declare namespace fromRpc {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Obtains the signing payload for a {@link ox#UserOperation.UserOperation}.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, Value } from 'ox'\n * import { UserOperation } from 'ox/erc4337'\n *\n * const userOperation = UserOperation.from({\n *   callData: '0xdeadbeef',\n *   callGasLimit: 300_000n,\n *   maxFeePerGas: Value.fromGwei('20'),\n *   maxPriorityFeePerGas: Value.fromGwei('2'),\n *   nonce: 69n,\n *   preVerificationGas: 100_000n,\n *   sender: '0x9f1fdab6458c5fc642fa0f4c5af7473c46837357',\n *   verificationGasLimit: 100_000n,\n * })\n *\n * const payload = UserOperation.getSignPayload(userOperation, { // [!code focus]\n *   chainId: 1, // [!code focus]\n *   entryPointAddress: '0x1234567890123456789012345678901234567890', // [!code focus]\n *   entryPointVersion: '0.6', // [!code focus]\n * }) // [!code focus]\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param userOperation - The user operation to get the sign payload for.\n * @returns The signing payload for the user operation.\n */\nexport function getSignPayload<\n  entrypointVersion extends EntryPoint.Version = EntryPoint.Version,\n>(\n  userOperation: UserOperation<entrypointVersion>,\n  options: getSignPayload.Options<entrypointVersion>,\n): Hex.Hex {\n  return hash(userOperation, options)\n}\n\nexport declare namespace getSignPayload {\n  type Options<\n    entrypointVersion extends EntryPoint.Version = EntryPoint.Version,\n  > = hash.Options<entrypointVersion>\n\n  type ErrorType = hash.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Hashes a {@link ox#UserOperation.UserOperation}. This is the \"user operation hash\".\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n * import { UserOperation } from 'ox/erc4337'\n *\n * const userOperation = UserOperation.hash({\n *   callData: '0xdeadbeef',\n *   callGasLimit: 300_000n,\n *   maxFeePerGas: Value.fromGwei('20'),\n *   maxPriorityFeePerGas: Value.fromGwei('2'),\n *   nonce: 69n,\n *   preVerificationGas: 100_000n,\n *   sender: '0x9f1fdab6458c5fc642fa0f4c5af7473c46837357',\n *   verificationGasLimit: 100_000n,\n * }, {\n *   chainId: 1,\n *   entryPointAddress: '0x1234567890123456789012345678901234567890',\n *   entryPointVersion: '0.6',\n * })\n * ```\n *\n * @param userOperation - The user operation to hash.\n * @returns The hash of the user operation.\n */\nexport function hash<\n  entrypointVersion extends EntryPoint.Version = EntryPoint.Version,\n>(\n  userOperation: UserOperation<entrypointVersion>,\n  options: hash.Options<entrypointVersion>,\n): Hex.Hex {\n  const { chainId, entryPointAddress, entryPointVersion } = options\n  const {\n    callData,\n    callGasLimit,\n    initCode,\n    factory,\n    factoryData,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    paymaster,\n    paymasterAndData,\n    paymasterData,\n    paymasterPostOpGasLimit,\n    paymasterVerificationGasLimit,\n    preVerificationGas,\n    sender,\n    verificationGasLimit,\n  } = userOperation as UserOperation\n\n  if (entryPointVersion === '0.8') {\n    const typedData = toTypedData(userOperation as UserOperation<'0.8', true>, {\n      chainId,\n      entryPointAddress,\n    })\n    return TypedData.getSignPayload(typedData)\n  }\n\n  const packedUserOp = (() => {\n    if (entryPointVersion === '0.6') {\n      return AbiParameters.encode(\n        [\n          { type: 'address' },\n          { type: 'uint256' },\n          { type: 'bytes32' },\n          { type: 'bytes32' },\n          { type: 'uint256' },\n          { type: 'uint256' },\n          { type: 'uint256' },\n          { type: 'uint256' },\n          { type: 'uint256' },\n          { type: 'bytes32' },\n        ],\n        [\n          sender,\n          nonce,\n          Hash.keccak256(initCode ?? '0x'),\n          Hash.keccak256(callData),\n          callGasLimit,\n          verificationGasLimit,\n          preVerificationGas,\n          maxFeePerGas,\n          maxPriorityFeePerGas,\n          Hash.keccak256(paymasterAndData ?? '0x'),\n        ],\n      )\n    }\n\n    if (entryPointVersion === '0.7') {\n      const accountGasLimits = Hex.concat(\n        Hex.padLeft(Hex.fromNumber(verificationGasLimit), 16),\n        Hex.padLeft(Hex.fromNumber(callGasLimit), 16),\n      )\n      const gasFees = Hex.concat(\n        Hex.padLeft(Hex.fromNumber(maxPriorityFeePerGas), 16),\n        Hex.padLeft(Hex.fromNumber(maxFeePerGas), 16),\n      )\n      const initCode_hashed = Hash.keccak256(\n        factory && factoryData ? Hex.concat(factory, factoryData) : '0x',\n      )\n      const paymasterAndData_hashed = Hash.keccak256(\n        paymaster\n          ? Hex.concat(\n              paymaster,\n              Hex.padLeft(\n                Hex.fromNumber(paymasterVerificationGasLimit || 0),\n                16,\n              ),\n              Hex.padLeft(Hex.fromNumber(paymasterPostOpGasLimit || 0), 16),\n              paymasterData || '0x',\n            )\n          : '0x',\n      )\n\n      return AbiParameters.encode(\n        [\n          { type: 'address' },\n          { type: 'uint256' },\n          { type: 'bytes32' },\n          { type: 'bytes32' },\n          { type: 'bytes32' },\n          { type: 'uint256' },\n          { type: 'bytes32' },\n          { type: 'bytes32' },\n        ],\n        [\n          sender,\n          nonce,\n          initCode_hashed,\n          Hash.keccak256(callData),\n          accountGasLimits,\n          preVerificationGas,\n          gasFees,\n          paymasterAndData_hashed,\n        ],\n      )\n    }\n\n    throw new Error(`entryPointVersion \"${entryPointVersion}\" not supported.`)\n  })()\n\n  return Hash.keccak256(\n    AbiParameters.encode(\n      [{ type: 'bytes32' }, { type: 'address' }, { type: 'uint256' }],\n      [Hash.keccak256(packedUserOp), entryPointAddress, BigInt(chainId)],\n    ),\n  )\n}\n\nexport declare namespace hash {\n  type Options<\n    entrypointVersion extends EntryPoint.Version = EntryPoint.Version,\n  > = {\n    chainId: number\n    entryPointAddress: Address.Address\n    entryPointVersion: entrypointVersion | EntryPoint.Version\n  }\n\n  type ErrorType =\n    | AbiParameters.encode.ErrorType\n    | Hash.keccak256.ErrorType\n    | Hex.concat.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Hex.padLeft.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#UserOperation.UserOperation} to `initCode`.\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n * import { UserOperation } from 'ox/erc4337'\n *\n * const initCode = UserOperation.toInitCode({\n *   authorization: {\n *     address: '0x9f1fdab6458c5fc642fa0f4c5af7473c46837357',\n *     chainId: 1,\n *     nonce: 69n,\n *     yParity: 0,\n *     r: 1n,\n *     s: 2n,\n *   },\n *   callData: '0xdeadbeef',\n *   callGasLimit: 300_000n,\n *   factory: '0x7702',\n *   factoryData: '0xdeadbeef',\n *   maxFeePerGas: Value.fromGwei('20'),\n *   maxPriorityFeePerGas: Value.fromGwei('2'),\n *   nonce: 69n,\n *   preVerificationGas: 100_000n,\n *   sender: '0x9f1fdab6458c5fc642fa0f4c5af7473c46837357',\n * })\n * ```\n *\n * @param userOperation - The user operation to convert.\n * @returns The init code.\n */\nexport function toInitCode(userOperation: Partial<UserOperation>): Hex.Hex {\n  const { authorization, factory, factoryData } = userOperation\n  if (\n    factory === '0x7702' ||\n    factory === '0x7702000000000000000000000000000000000000'\n  ) {\n    if (!authorization) return '0x7702000000000000000000000000000000000000'\n    const delegation = authorization.address\n    return Hex.concat(delegation, factoryData ?? '0x')\n  }\n  if (!factory) return '0x'\n  return Hex.concat(factory, factoryData ?? '0x')\n}\n\n/**\n * Transforms a User Operation into \"packed\" format.\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n * import { UserOperation } from 'ox/erc4337'\n *\n * const packed = UserOperation.toPacked({\n *   callData: '0xdeadbeef',\n *   callGasLimit: 300_000n,\n *   maxFeePerGas: Value.fromGwei('20'),\n *   maxPriorityFeePerGas: Value.fromGwei('2'),\n *   nonce: 69n,\n *   preVerificationGas: 100_000n,\n *   sender: '0x9f1fdab6458c5fc642fa0f4c5af7473c46837357',\n *   signature: '0x...',\n *   verificationGasLimit: 100_000n,\n * })\n * ```\n *\n * @param userOperation - The user operation to transform.\n * @returns The packed user operation.\n */\nexport function toPacked(\n  userOperation: UserOperation<'0.7' | '0.8', true>,\n): Packed {\n  const {\n    callGasLimit,\n    callData,\n    maxPriorityFeePerGas,\n    maxFeePerGas,\n    nonce,\n    paymaster,\n    paymasterData,\n    paymasterPostOpGasLimit,\n    paymasterVerificationGasLimit,\n    sender,\n    signature,\n    verificationGasLimit,\n  } = userOperation\n\n  const accountGasLimits = Hex.concat(\n    Hex.padLeft(Hex.fromNumber(verificationGasLimit || 0n), 16),\n    Hex.padLeft(Hex.fromNumber(callGasLimit || 0n), 16),\n  )\n  const initCode = toInitCode(userOperation)\n  const gasFees = Hex.concat(\n    Hex.padLeft(Hex.fromNumber(maxPriorityFeePerGas || 0n), 16),\n    Hex.padLeft(Hex.fromNumber(maxFeePerGas || 0n), 16),\n  )\n  const paymasterAndData = paymaster\n    ? Hex.concat(\n        paymaster,\n        Hex.padLeft(Hex.fromNumber(paymasterVerificationGasLimit || 0n), 16),\n        Hex.padLeft(Hex.fromNumber(paymasterPostOpGasLimit || 0n), 16),\n        paymasterData || '0x',\n      )\n    : '0x'\n  const preVerificationGas = userOperation.preVerificationGas ?? 0n\n\n  return {\n    accountGasLimits,\n    callData,\n    initCode,\n    gasFees,\n    nonce,\n    paymasterAndData,\n    preVerificationGas,\n    sender,\n    signature,\n  }\n}\n\nexport declare namespace toPacked {\n  export type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Transforms a \"packed\" User Operation into a structured {@link ox#UserOperation.UserOperation}.\n *\n * @example\n * ```ts twoslash\n * import { UserOperation } from 'ox/erc4337'\n *\n * const packed: UserOperation.Packed = {\n *   accountGasLimits: '0x...',\n *   callData: '0xdeadbeef',\n *   initCode: '0x...',\n *   gasFees: '0x...',\n *   nonce: 69n,\n *   paymasterAndData: '0x',\n *   preVerificationGas: 100_000n,\n *   sender: '0x9f1fdab6458c5fc642fa0f4c5af7473c46837357',\n *   signature: '0x...',\n * }\n *\n * const userOperation = UserOperation.fromPacked(packed)\n * ```\n *\n * @param packed - The packed user operation to transform.\n * @returns The structured user operation.\n */\nexport function fromPacked(packed: Packed): UserOperation<'0.7' | '0.8', true> {\n  const {\n    accountGasLimits,\n    callData,\n    initCode,\n    gasFees,\n    nonce,\n    paymasterAndData,\n    preVerificationGas,\n    sender,\n    signature,\n  } = packed\n\n  const verificationGasLimit = BigInt(Hex.slice(accountGasLimits, 0, 16))\n  const callGasLimit = BigInt(Hex.slice(accountGasLimits, 16, 32))\n\n  const { factory, factoryData } = (() => {\n    if (initCode === '0x') return { factory: undefined, factoryData: undefined }\n\n    const factory = Hex.slice(initCode, 0, 20)\n    const factoryData =\n      Hex.size(initCode) > 20 ? Hex.slice(initCode, 20) : undefined\n\n    return { factory, factoryData }\n  })()\n\n  const maxPriorityFeePerGas = BigInt(Hex.slice(gasFees, 0, 16))\n  const maxFeePerGas = BigInt(Hex.slice(gasFees, 16, 32))\n\n  const {\n    paymaster,\n    paymasterVerificationGasLimit,\n    paymasterPostOpGasLimit,\n    paymasterData,\n  } = (() => {\n    if (paymasterAndData === '0x')\n      return {\n        paymaster: undefined,\n        paymasterVerificationGasLimit: undefined,\n        paymasterPostOpGasLimit: undefined,\n        paymasterData: undefined,\n      }\n\n    const paymaster = Hex.slice(paymasterAndData, 0, 20)\n    const paymasterVerificationGasLimit = BigInt(\n      Hex.slice(paymasterAndData, 20, 36),\n    )\n    const paymasterPostOpGasLimit = BigInt(Hex.slice(paymasterAndData, 36, 52))\n    const paymasterData =\n      Hex.size(paymasterAndData) > 52\n        ? Hex.slice(paymasterAndData, 52)\n        : undefined\n\n    return {\n      paymaster,\n      paymasterVerificationGasLimit,\n      paymasterPostOpGasLimit,\n      paymasterData,\n    }\n  })()\n\n  return {\n    callData,\n    callGasLimit,\n    ...(factory && { factory }),\n    ...(factoryData && { factoryData }),\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    ...(paymaster && { paymaster }),\n    ...(paymasterData && { paymasterData }),\n    ...(typeof paymasterPostOpGasLimit === 'bigint' && {\n      paymasterPostOpGasLimit,\n    }),\n    ...(typeof paymasterVerificationGasLimit === 'bigint' && {\n      paymasterVerificationGasLimit,\n    }),\n    preVerificationGas,\n    sender,\n    signature,\n    verificationGasLimit,\n  }\n}\n\nexport declare namespace fromPacked {\n  export type ErrorType = Hex.slice.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#UserOperation.UserOperation} to a {@link ox#UserOperation.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n * import { UserOperation } from 'ox/erc4337'\n *\n * const userOperation = UserOperation.toRpc({\n *   callData: '0xdeadbeef',\n *   callGasLimit: 300_000n,\n *   maxFeePerGas: Value.fromGwei('20'),\n *   maxPriorityFeePerGas: Value.fromGwei('2'),\n *   nonce: 69n,\n *   preVerificationGas: 100_000n,\n *   sender: '0x9f1fdab6458c5fc642fa0f4c5af7473c46837357',\n *   verificationGasLimit: 100_000n,\n * })\n * ```\n *\n * @param userOperation - The user operation to convert.\n * @returns An RPC-formatted user operation.\n */\nexport function toRpc(userOperation: UserOperation): Rpc {\n  const rpc = {} as Rpc\n\n  rpc.callData = userOperation.callData\n  rpc.callGasLimit = Hex.fromNumber(userOperation.callGasLimit)\n  rpc.maxFeePerGas = Hex.fromNumber(userOperation.maxFeePerGas)\n  rpc.maxPriorityFeePerGas = Hex.fromNumber(userOperation.maxPriorityFeePerGas)\n  rpc.nonce = Hex.fromNumber(userOperation.nonce)\n  rpc.preVerificationGas = Hex.fromNumber(userOperation.preVerificationGas)\n  rpc.sender = userOperation.sender\n  rpc.verificationGasLimit = Hex.fromNumber(userOperation.verificationGasLimit)\n\n  if (userOperation.factory) rpc.factory = userOperation.factory\n  if (userOperation.factoryData) rpc.factoryData = userOperation.factoryData\n  if (userOperation.initCode) rpc.initCode = userOperation.initCode\n  if (userOperation.paymaster) rpc.paymaster = userOperation.paymaster\n  if (userOperation.paymasterData)\n    rpc.paymasterData = userOperation.paymasterData\n  if (typeof userOperation.paymasterPostOpGasLimit === 'bigint')\n    rpc.paymasterPostOpGasLimit = Hex.fromNumber(\n      userOperation.paymasterPostOpGasLimit,\n    )\n  if (typeof userOperation.paymasterVerificationGasLimit === 'bigint')\n    rpc.paymasterVerificationGasLimit = Hex.fromNumber(\n      userOperation.paymasterVerificationGasLimit,\n    )\n  if (userOperation.signature) rpc.signature = userOperation.signature\n\n  return rpc\n}\n\nexport declare namespace toRpc {\n  export type ErrorType = Hex.fromNumber.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Converts a signed {@link ox#UserOperation.UserOperation} to a {@link ox#TypedData.Definition}.\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n * import { UserOperation } from 'ox/erc4337'\n *\n * const typedData = UserOperation.toTypedData({\n *   authorization: {\n *     chainId: 1,\n *     address: '0x9f1fdab6458c5fc642fa0f4c5af7473c46837357',\n *     nonce: 69n,\n *     yParity: 0,\n *     r: 1n,\n *     s: 2n,\n *   },\n *   callData: '0xdeadbeef',\n *   callGasLimit: 300_000n,\n *   maxFeePerGas: Value.fromGwei('20'),\n *   maxPriorityFeePerGas: Value.fromGwei('2'),\n *   nonce: 69n,\n *   preVerificationGas: 100_000n,\n *   sender: '0x9f1fdab6458c5fc642fa0f4c5af7473c46837357',\n *   signature: '0x...',\n *   verificationGasLimit: 100_000n,\n * }, {\n *   chainId: 1,\n *   entryPointAddress: '0x1234567890123456789012345678901234567890',\n * })\n * ```\n *\n * @param userOperation - The user operation to convert.\n * @returns A Typed Data definition.\n */\nexport function toTypedData(\n  userOperation: UserOperation<'0.8', true>,\n  options: toTypedData.Options,\n): TypedData.Definition<typeof toTypedData.types, 'PackedUserOperation'> {\n  const { chainId, entryPointAddress } = options\n\n  const packedUserOp = toPacked(userOperation)\n\n  return {\n    domain: {\n      name: 'ERC4337',\n      version: '1',\n      chainId,\n      verifyingContract: entryPointAddress,\n    },\n    message: packedUserOp,\n    primaryType: 'PackedUserOperation',\n    types: toTypedData.types,\n  }\n}\n\nexport namespace toTypedData {\n  export type Options = {\n    chainId: number\n    entryPointAddress: Address.Address\n  }\n\n  export type ErrorType = Errors.GlobalErrorType\n\n  export const types = {\n    PackedUserOperation: [\n      { type: 'address', name: 'sender' },\n      { type: 'uint256', name: 'nonce' },\n      { type: 'bytes', name: 'initCode' },\n      { type: 'bytes', name: 'callData' },\n      { type: 'bytes32', name: 'accountGasLimits' },\n      { type: 'uint256', name: 'preVerificationGas' },\n      { type: 'bytes32', name: 'gasFees' },\n      { type: 'bytes', name: 'paymasterAndData' },\n    ],\n  } as const\n}\n", "import * as Hex from '../core/Hex.js'\nimport type { OneOf } from '../core/internal/types.js'\nimport type * as EntryPoint from './EntryPoint.js'\n\n/** User Operation Gas type. */\nexport type UserOperationGas<\n  entryPointVersion extends EntryPoint.Version = EntryPoint.Version,\n  bigintType = bigint,\n> = OneOf<\n  | (entryPointVersion extends '0.6' ? V06<bigintType> : never)\n  | (entryPointVersion extends '0.7' ? V07<bigintType> : never)\n>\n\n/** RPC User Operation Gas on EntryPoint 0.6 */\nexport type Rpc<\n  entryPointVersion extends EntryPoint.Version = EntryPoint.Version,\n> = UserOperationGas<entryPointVersion, Hex.Hex>\n\n/** Type for User Operation Gas on EntryPoint 0.6 */\nexport type V06<bigintType = bigint> = {\n  callGasLimit: bigintType\n  preVerificationGas: bigintType\n  verificationGasLimit: bigintType\n}\n\n/** RPC User Operation Gas on EntryPoint 0.6 */\nexport type RpcV06 = V06<Hex.Hex>\n\n/** Type for User Operation Gas on EntryPoint 0.7 */\nexport type V07<bigintType = bigint> = {\n  callGasLimit: bigintType\n  paymasterVerificationGasLimit?: bigintType | undefined\n  paymasterPostOpGasLimit?: bigintType | undefined\n  preVerificationGas: bigintType\n  verificationGasLimit: bigintType\n}\n\n/** RPC User Operation Gas on EntryPoint 0.7 */\nexport type RpcV07 = V07<Hex.Hex>\n\n/**\n * Converts an {@link ox#UserOperationGas.Rpc} to an {@link ox#UserOperationGas.UserOperationGas}.\n *\n * @example\n * ```ts twoslash\n * import { UserOperationGas } from 'ox/erc4337'\n *\n * const userOperationGas = UserOperationGas.fromRpc({\n *   callGasLimit: '0x69420',\n *   preVerificationGas: '0x69420',\n *   verificationGasLimit: '0x69420',\n * })\n * ```\n *\n * @param rpc - The RPC user operation gas to convert.\n * @returns An instantiated {@link ox#UserOperationGas.UserOperationGas}.\n */\nexport function fromRpc(rpc: Rpc): UserOperationGas {\n  return {\n    ...rpc,\n    callGasLimit: BigInt(rpc.callGasLimit),\n    preVerificationGas: BigInt(rpc.preVerificationGas),\n    verificationGasLimit: BigInt(rpc.verificationGasLimit),\n    ...(rpc.paymasterVerificationGasLimit && {\n      paymasterVerificationGasLimit: BigInt(rpc.paymasterVerificationGasLimit),\n    }),\n    ...(rpc.paymasterPostOpGasLimit && {\n      paymasterPostOpGasLimit: BigInt(rpc.paymasterPostOpGasLimit),\n    }),\n  } as UserOperationGas\n}\n\n/**\n * Converts a {@link ox#UserOperationGas.UserOperationGas} to a {@link ox#UserOperationGas.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { UserOperationGas } from 'ox/erc4337'\n *\n * const userOperationGas = UserOperationGas.toRpc({\n *   callGasLimit: 300_000n,\n *   preVerificationGas: 100_000n,\n *   verificationGasLimit: 100_000n,\n * })\n * ```\n *\n * @param userOperationGas - The user operation gas to convert.\n * @returns An RPC-formatted user operation gas.\n */\nexport function toRpc(userOperationGas: UserOperationGas): Rpc {\n  const rpc = {} as Rpc\n\n  rpc.callGasLimit = Hex.fromNumber(userOperationGas.callGasLimit)\n  rpc.preVerificationGas = Hex.fromNumber(userOperationGas.preVerificationGas)\n  rpc.verificationGasLimit = Hex.fromNumber(\n    userOperationGas.verificationGasLimit,\n  )\n\n  if (typeof userOperationGas.paymasterVerificationGasLimit === 'bigint')\n    rpc.paymasterVerificationGasLimit = Hex.fromNumber(\n      userOperationGas.paymasterVerificationGasLimit,\n    )\n  if (typeof userOperationGas.paymasterPostOpGasLimit === 'bigint')\n    rpc.paymasterPostOpGasLimit = Hex.fromNumber(\n      userOperationGas.paymasterPostOpGasLimit,\n    )\n\n  return rpc\n}\n", "import type * as Address from '../core/Address.js'\nimport * as Hex from '../core/Hex.js'\nimport * as Log from '../core/Log.js'\nimport * as TransactionReceipt from '../core/TransactionReceipt.js'\nimport type * as EntryPoint from './EntryPoint.js'\n\n/**\n * User Operation Receipt type.\n *\n * @see https://eips.ethereum.org/EIPS/eip-4337#-eth_getuseroperationreceipt\n */\nexport type UserOperationReceipt<\n  _entryPointVersion extends EntryPoint.Version = EntryPoint.Version,\n  bigIntType = bigint,\n  intType = number,\n  receipt = TransactionReceipt.TransactionReceipt<\n    TransactionReceipt.Status,\n    TransactionReceipt.Type,\n    bigIntType,\n    intType\n  >,\n> = {\n  /** Actual gas cost. */\n  actualGasCost: bigIntType\n  /** Actual gas used. */\n  actualGasUsed: bigIntType\n  /** Entrypoint address. */\n  entryPoint: Address.Address\n  /** Logs emitted during execution. */\n  logs: Log.Log<false, bigIntType, intType>[]\n  /** Anti-replay parameter. */\n  nonce: bigIntType\n  /** Paymaster for the user operation. */\n  paymaster?: Address.Address | undefined\n  /** Revert reason, if unsuccessful. */\n  reason?: string | undefined\n  /** Transaction receipt of the user operation execution. */\n  receipt: receipt\n  /** The account sending the user operation. */\n  sender: Address.Address\n  /** If the user operation execution was successful. */\n  success: boolean\n  /** Hash of the user operation. */\n  userOpHash: Hex.Hex\n}\n\n/** RPC User Operation Receipt on EntryPoint 0.6 */\nexport type Rpc<\n  entryPointVersion extends EntryPoint.Version = EntryPoint.Version,\n> = UserOperationReceipt<\n  entryPointVersion,\n  Hex.Hex,\n  Hex.Hex,\n  TransactionReceipt.TransactionReceipt<\n    TransactionReceipt.RpcStatus,\n    TransactionReceipt.RpcType,\n    Hex.Hex,\n    Hex.Hex\n  >\n>\n\n/**\n * Converts an {@link ox#UserOperationReceipt.Rpc} to an {@link ox#UserOperationReceipt.UserOperationReceipt}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { UserOperationReceipt } from 'ox/erc4337'\n *\n * const userOperationReceipt = UserOperationReceipt.fromRpc({\n *   actualGasCost: '0x1',\n *   actualGasUsed: '0x2',\n *   entryPoint: '0x0000000071727de22e5e9d8baf0edac6f37da032',\n *   logs: [],\n *   nonce: '0x1',\n *   receipt: { ... },\n *   sender: '0xE911628bF8428C23f179a07b081325cAe376DE1f',\n *   success: true,\n *   userOpHash: '0x5ab163e9b2f30549274c7c567ca0696edf9ef1aa476d9784d22974468fdb24d8',\n * })\n * ```\n *\n * @param rpc - The RPC user operation receipt to convert.\n * @returns An instantiated {@link ox#UserOperationReceipt.UserOperationReceipt}.\n */\nexport function fromRpc(rpc: Rpc): UserOperationReceipt {\n  return {\n    ...rpc,\n    actualGasCost: BigInt(rpc.actualGasCost),\n    actualGasUsed: BigInt(rpc.actualGasUsed),\n    logs: rpc.logs.map((log) => Log.fromRpc(log)),\n    nonce: BigInt(rpc.nonce),\n    receipt: TransactionReceipt.fromRpc(rpc.receipt),\n  } as UserOperationReceipt\n}\n\n/**\n * Converts a {@link ox#UserOperationReceipt.UserOperationReceipt} to a {@link ox#UserOperationReceipt.Rpc}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { UserOperationReceipt } from 'ox/erc4337'\n *\n * const userOperationReceipt = UserOperationReceipt.toRpc({\n *   actualGasCost: 1n,\n *   actualGasUsed: 2n,\n *   entryPoint: '0x0000000071727de22e5e9d8baf0edac6f37da032',\n *   logs: [],\n *   nonce: 1n,\n *   receipt: { ... },\n *   sender: '0xE911628bF8428C23f179a07b081325cAe376DE1f',\n *   success: true,\n *   userOpHash: '0x5ab163e9b2f30549274c7c567ca0696edf9ef1aa476d9784d22974468fdb24d8',\n * })\n * ```\n *\n * @param userOperationReceipt - The user operation receipt to convert.\n * @returns An RPC-formatted user operation receipt.\n */\nexport function toRpc(userOperationReceipt: UserOperationReceipt): Rpc {\n  const rpc = {} as Rpc\n\n  rpc.actualGasCost = Hex.fromNumber(userOperationReceipt.actualGasCost)\n  rpc.actualGasUsed = Hex.fromNumber(userOperationReceipt.actualGasUsed)\n  rpc.entryPoint = userOperationReceipt.entryPoint\n  rpc.logs = userOperationReceipt.logs.map((log) => Log.toRpc(log))\n  rpc.nonce = Hex.fromNumber(userOperationReceipt.nonce)\n  rpc.receipt = TransactionReceipt.toRpc(userOperationReceipt.receipt)\n  rpc.sender = userOperationReceipt.sender\n  rpc.success = userOperationReceipt.success\n  rpc.userOpHash = userOperationReceipt.userOpHash\n\n  if (userOperationReceipt.paymaster)\n    rpc.paymaster = userOperationReceipt.paymaster\n  if (userOperationReceipt.reason) rpc.reason = userOperationReceipt.reason\n\n  return rpc\n}\n", "// biome-ignore lint/performance/noBarrelFile: entrypoint module\nexport {\n  /** @deprecated This is no longer experimental  use `import type { GetCallsStatusErrorType } from 'viem/actions'` instead. */\n  type GetCallsStatusErrorType,\n  /** @deprecated This is no longer experimental  use `import type { GetCallsStatusParameters } from 'viem/actions'` instead. */\n  type GetCallsStatusParameters,\n  /** @deprecated This is no longer experimental  use `import type { GetCallsStatusReturnType } from 'viem/actions'` instead. */\n  type GetCallsStatusReturnType,\n  /** @deprecated This is no longer experimental  use `import { getCallsStatus } from 'viem/actions'` instead. */\n  getCallsStatus,\n} from '../actions/wallet/getCallsStatus.js'\nexport {\n  /** @deprecated This is no longer experimental  use `import type { GetCapabilitiesErrorType } from 'viem/actions'` instead. */\n  type GetCapabilitiesErrorType,\n  /** @deprecated This is no longer experimental  use `import type { GetCapabilitiesParameters } from 'viem/actions'` instead. */\n  type GetCapabilitiesParameters,\n  /** @deprecated This is no longer experimental  use `import type { GetCapabilitiesReturnType } from 'viem/actions'` instead. */\n  type GetCapabilitiesReturnType,\n  /** @deprecated This is no longer experimental  use `import { getCapabilities } from 'viem/actions'` instead. */\n  getCapabilities,\n} from '../actions/wallet/getCapabilities.js'\nexport {\n  /** @deprecated This is no longer experimental  use `import type { PrepareAuthorizationErrorType } from 'viem/actions'` instead. */\n  type PrepareAuthorizationErrorType,\n  /** @deprecated This is no longer experimental  use `import type { PrepareAuthorizationParameters } from 'viem/actions'` instead. */\n  type PrepareAuthorizationParameters,\n  /** @deprecated This is no longer experimental  use `import type { PrepareAuthorizationReturnType } from 'viem/actions'` instead. */\n  type PrepareAuthorizationReturnType,\n  /** @deprecated This is no longer experimental  use `import { prepareAuthorization } from 'viem/actions'` instead. */\n  prepareAuthorization,\n} from '../actions/wallet/prepareAuthorization.js'\nexport {\n  /** @deprecated This is no longer experimental  use `import type { SendCallsErrorType } from 'viem/actions'` instead. */\n  type SendCallsErrorType,\n  /** @deprecated This is no longer experimental  use `import type { SendCallsParameters } from 'viem/actions'` instead. */\n  type SendCallsParameters,\n  /** @deprecated This is no longer experimental  use `import type { SendCallsReturnType } from 'viem/actions'` instead. */\n  type SendCallsReturnType,\n  /** @deprecated This is no longer experimental  use `import { sendCalls } from 'viem/actions'` instead. */\n  sendCalls,\n} from '../actions/wallet/sendCalls.js'\nexport {\n  /** @deprecated This is no longer experimental  use `import type { ShowCallsStatusErrorType } from 'viem/actions'` instead. */\n  type ShowCallsStatusErrorType,\n  /** @deprecated This is no longer experimental  use `import type { ShowCallsStatusParameters } from 'viem/actions'` instead. */\n  type ShowCallsStatusParameters,\n  /** @deprecated This is no longer experimental  use `import type { ShowCallsStatusReturnType } from 'viem/actions'` instead. */\n  type ShowCallsStatusReturnType,\n  /** @deprecated This is no longer experimental  use `import { showCallsStatus } from 'viem/actions'` instead. */\n  showCallsStatus,\n} from '../actions/wallet/showCallsStatus.js'\nexport {\n  /** @deprecated This is no longer experimental  use `import type { SignAuthorizationErrorType } from 'viem/actions'` instead. */\n  type SignAuthorizationErrorType,\n  /** @deprecated This is no longer experimental  use `import type { SignAuthorizationParameters } from 'viem/actions'` instead. */\n  type SignAuthorizationParameters,\n  /** @deprecated This is no longer experimental  use `import type { SignAuthorizationReturnType } from 'viem/actions'` instead. */\n  type SignAuthorizationReturnType,\n  /** @deprecated This is no longer experimental  use `import { signAuthorization } from 'viem/actions'` instead. */\n  signAuthorization,\n} from '../actions/wallet/signAuthorization.js'\nexport {\n  /** @deprecated This is no longer experimental  use `import type { WaitForCallsStatusErrorType } from 'viem/actions'` instead. */\n  type WaitForCallsStatusErrorType,\n  /** @deprecated This is no longer experimental  use `import type { WaitForCallsStatusParameters } from 'viem/actions'` instead. */\n  type WaitForCallsStatusParameters,\n  /** @deprecated This is no longer experimental  use `import type { WaitForCallsStatusReturnType } from 'viem/actions'` instead. */\n  type WaitForCallsStatusReturnType,\n  /** @deprecated This is no longer experimental  use `import type { WaitForCallsStatusTimeoutErrorType } from 'viem/actions'` instead. */\n  type WaitForCallsStatusTimeoutErrorType,\n  /** @deprecated This is no longer experimental  use `import { waitForCallsStatus } from 'viem/actions'` instead. */\n  waitForCallsStatus,\n} from '../actions/wallet/waitForCallsStatus.js'\n\nexport {\n  /** @deprecated This is no longer experimental  use `import type { WalletActions } from 'viem'` instead. */\n  type WalletActions as Eip7702Actions,\n  /** @deprecated This is no longer experimental  use `import { createWalletClient } from 'viem'` or `import { walletActions } from 'viem'` instead. */\n  walletActions as eip7702Actions,\n} from '../clients/decorators/wallet.js'\nexport type {\n  /** @deprecated This is no longer experimental  use `import type { Authorization } from 'viem'` instead. */\n  Authorization,\n  /** @deprecated This is no longer experimental  use `import type { AuthorizationList } from 'viem'` instead. */\n  AuthorizationList,\n  /** @deprecated This is no longer experimental  use `import type { SerializedAuthorization } from 'viem'` instead. */\n  SerializedAuthorization,\n  /** @deprecated This is no longer experimental  use `import type { SerializedAuthorizationList } from 'viem'` instead. */\n  SerializedAuthorizationList,\n  /** @deprecated This is no longer experimental  use `import type { SignedAuthorization } from 'viem'` instead. */\n  SignedAuthorization,\n  /** @deprecated This is no longer experimental  use `import type { SignedAuthorizationList } from 'viem'` instead. */\n  SignedAuthorizationList,\n} from '../types/authorization.js'\nexport type {\n  /** @deprecated This is no longer experimental  use `import type { RpcAuthorization } from 'viem'` instead. */\n  RpcAuthorization,\n  /** @deprecated This is no longer experimental  use `import type { RpcAuthorizationList } from 'viem'` instead. */\n  RpcAuthorizationList,\n} from '../types/rpc.js'\nexport {\n  /** @deprecated This is no longer experimental  use `import type { HashAuthorizationErrorType } from 'viem/utils'` instead. */\n  type HashAuthorizationErrorType,\n  /** @deprecated This is no longer experimental  use `import type { HashAuthorizationParameters } from 'viem/utils'` instead. */\n  type HashAuthorizationParameters,\n  /** @deprecated This is no longer experimental  use `import type { HashAuthorizationReturnType } from 'viem/utils'` instead. */\n  type HashAuthorizationReturnType,\n  /** @deprecated This is no longer experimental  use `import { hashAuthorization } from 'viem/utils'` instead. */\n  hashAuthorization,\n} from '../utils/authorization/hashAuthorization.js'\nexport {\n  /** @deprecated This is no longer experimental  use `import type { RecoverAuthorizationAddressErrorType } from 'viem/utils'` instead. */\n  type RecoverAuthorizationAddressErrorType,\n  /** @deprecated This is no longer experimental  use `import type { RecoverAuthorizationAddressParameters } from 'viem/utils'` instead. */\n  type RecoverAuthorizationAddressParameters,\n  /** @deprecated This is no longer experimental  use `import type { RecoverAuthorizationAddressReturnType } from 'viem/utils'` instead. */\n  type RecoverAuthorizationAddressReturnType,\n  /** @deprecated This is no longer experimental  use `import { recoverAuthorizationAddress } from 'viem/utils'` instead. */\n  recoverAuthorizationAddress,\n} from '../utils/authorization/recoverAuthorizationAddress.js'\nexport {\n  /** @deprecated This is no longer experimental  use `import type { SerializeAuthorizationListErrorType } from 'viem/utils'` instead. */\n  type SerializeAuthorizationListErrorType,\n  /** @deprecated This is no longer experimental  use `import type { SerializeAuthorizationListReturnType } from 'viem/utils'` instead. */\n  type SerializeAuthorizationListReturnType,\n  /** @deprecated This is no longer experimental  use `import { serializeAuthorizationList } from 'viem/utils'` instead. */\n  serializeAuthorizationList,\n} from '../utils/authorization/serializeAuthorizationList.js'\nexport {\n  /** @deprecated This is no longer experimental  use `import type { VerifyAuthorizationErrorType } from 'viem/utils'` instead. */\n  type VerifyAuthorizationErrorType,\n  /** @deprecated This is no longer experimental  use `import type { VerifyAuthorizationParameters } from 'viem/utils'` instead. */\n  type VerifyAuthorizationParameters,\n  /** @deprecated This is no longer experimental  use `import type { VerifyAuthorizationReturnType } from 'viem/utils'` instead. */\n  type VerifyAuthorizationReturnType,\n  /** @deprecated This is no longer experimental  use `import { verifyAuthorization } from 'viem/utils'` instead. */\n  verifyAuthorization,\n} from '../utils/authorization/verifyAuthorization.js'\nexport {\n  /** @deprecated */\n  type WriteContractFunctionParameters,\n  /** @deprecated Use `SendCallsErrorType` instead. */\n  type WriteContractsErrorType,\n  /** @deprecated Use `SendCallsParameters` instead. */\n  type WriteContractsParameters,\n  /** @deprecated Use `SendCallsReturnType` instead. */\n  type WriteContractsReturnType,\n  /** @deprecated Use `sendCalls` instead. */\n  writeContracts,\n} from './eip5792/actions/writeContracts.js'\nexport {\n  /** @deprecated This is no longer experimental  use `import type { WalletActions } from 'viem'` instead. */\n  type Eip5792Actions,\n  /** @deprecated This is no longer experimental  use `import { createWalletClient } from 'viem'` or `import { walletActions } from 'viem'` instead. */\n  eip5792Actions,\n} from './eip5792/decorators/eip5792.js'\n\nexport {\n  type GrantPermissionsParameters,\n  type GrantPermissionsReturnType,\n  grantPermissions,\n} from './erc7715/actions/grantPermissions.js'\nexport {\n  type Erc7715Actions,\n  erc7715Actions,\n} from './erc7715/decorators/erc7715.js'\n\nexport {\n  type Erc7739Actions,\n  type Erc7739ActionsParameters,\n  erc7739Actions,\n} from './erc7739/decorators/erc7739.js'\nexport {\n  type Erc7811Actions,\n  erc7811Actions,\n} from './erc7811/decorators/erc7811.js'\nexport {\n  type Erc7821Actions,\n  erc7821Actions,\n} from './erc7821/decorators/erc7821.js'\nexport {\n  type Erc7846Actions,\n  erc7846Actions,\n} from './erc7846/decorators/erc7846.js'\n\nexport {\n  type Erc7895Actions,\n  erc7895Actions,\n} from './erc7895/decorators/erc7895.js'\n", "// TODO(v3): Remove this.\n\nimport type { Abi, AbiStateMutability, Address, Narrow } from 'abitype'\n\nimport {\n  type SendCallsErrorType,\n  type SendCallsParameters,\n  type SendCallsReturnType,\n  sendCalls,\n} from '../../../actions/wallet/sendCalls.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Account, GetAccountParameter } from '../../../types/account.js'\nimport type { Chain, GetChainParameter } from '../../../types/chain.js'\nimport type {\n  ContractFunctionArgs,\n  ContractFunctionName,\n  GetValue,\n  UnionWiden,\n  Widen,\n} from '../../../types/contract.js'\nimport type { MulticallContracts } from '../../../types/multicall.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../../utils/abi/encodeFunctionData.js'\nimport { getAction } from '../../../utils/getAction.js'\n\nexport type WriteContractsParameters<\n  contracts extends\n    readonly unknown[] = readonly WriteContractFunctionParameters[],\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n> = Pick<\n  SendCallsParameters<chain, account, chainOverride>,\n  'capabilities' | 'version'\n> & {\n  contracts: MulticallContracts<\n    Narrow<contracts>,\n    { mutability: AbiStateMutability }\n  >\n} & GetAccountParameter<account> &\n  GetChainParameter<chain, chainOverride>\n\nexport type WriteContractsReturnType = SendCallsReturnType\n\nexport type WriteContractsErrorType =\n  | EncodeFunctionDataErrorType\n  | SendCallsErrorType\n  | ErrorType\n\n/**\n * Requests for the wallet to sign and broadcast a batch of write contract calls (transactions) to the network.\n *\n * - Docs: https://viem.sh/experimental/eip5792/writeContracts\n *\n * @param client - Client to use\n * @param parameters - {@link WriteContractsParameters}\n * @returns Unique identifier for the call batch. {@link WriteContractsReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { writeContracts } from 'viem/experimental'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const abi = parseAbi([\n *   'function approve(address, uint256) returns (bool)',\n *   'function transferFrom(address, address, uint256) returns (bool)',\n * ])\n * const id = await writeContracts(client, {\n *   contracts: [\n *     {\n *       address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *       abi,\n *       functionName: 'approve',\n *       args: ['0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC', 100n],\n *     },\n *     {\n *       address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *       abi,\n *       functionName: 'transferFrom',\n *       args: [\n *         '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',\n *         '0x0000000000000000000000000000000000000000',\n *         100n\n *       ],\n *     },\n *   ],\n * })\n */\nexport async function writeContracts<\n  const contracts extends readonly unknown[],\n  chain extends Chain | undefined,\n  account extends Account | undefined = undefined,\n  chainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, chain>,\n  parameters: WriteContractsParameters<\n    contracts,\n    chain,\n    account,\n    chainOverride\n  >,\n): Promise<WriteContractsReturnType> {\n  const contracts = parameters.contracts as WriteContractFunctionParameters[]\n  const calls = contracts.map((contract) => {\n    const { address, abi, functionName, args, value } = contract\n    return {\n      data: encodeFunctionData({\n        abi,\n        functionName,\n        args,\n      }),\n      to: address,\n      value,\n    } satisfies SendCallsParameters['calls'][number]\n  })\n  return getAction(\n    client,\n    sendCalls,\n    'sendCalls',\n  )({ ...parameters, calls } as SendCallsParameters)\n}\n\nexport type WriteContractFunctionParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  mutability extends AbiStateMutability = AbiStateMutability,\n  functionName extends ContractFunctionName<\n    abi,\n    mutability\n  > = ContractFunctionName<abi, mutability>,\n  args extends ContractFunctionArgs<\n    abi,\n    mutability,\n    functionName\n  > = ContractFunctionArgs<abi, mutability, functionName>,\n  ///\n  allFunctionNames = ContractFunctionName<abi, mutability>,\n  allArgs = ContractFunctionArgs<abi, mutability, functionName>,\n  // when `args` is inferred to `readonly []` (\"inputs\": []) or `never` (`abi` declared as `Abi` or not inferrable), allow `args` to be optional.\n  // important that both branches return same structural type\n> = {\n  address: Address\n  abi: abi\n  functionName:\n    | allFunctionNames // show all options\n    | (functionName extends allFunctionNames ? functionName : never) // infer value\n  args?: (abi extends Abi ? UnionWiden<args> : never) | allArgs | undefined\n} & (readonly [] extends allArgs ? {} : { args: Widen<args> }) &\n  GetValue<abi, functionName>\n", "// TODO(v3): Remove this.\n\nimport {\n  type GetCallsStatusParameters,\n  type GetCallsStatusReturnType,\n  getCallsStatus,\n} from '../../../actions/wallet/getCallsStatus.js'\nimport {\n  type GetCapabilitiesParameters,\n  type GetCapabilitiesReturnType,\n  getCapabilities,\n} from '../../../actions/wallet/getCapabilities.js'\nimport {\n  type SendCallsParameters,\n  type SendCallsReturnType,\n  sendCalls,\n} from '../../../actions/wallet/sendCalls.js'\nimport {\n  type ShowCallsStatusParameters,\n  type ShowCallsStatusReturnType,\n  showCallsStatus,\n} from '../../../actions/wallet/showCallsStatus.js'\nimport {\n  type WaitForCallsStatusParameters,\n  type WaitForCallsStatusReturnType,\n  waitForCallsStatus,\n} from '../../../actions/wallet/waitForCallsStatus.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { Account } from '../../../types/account.js'\nimport type { Chain } from '../../../types/chain.js'\nimport {\n  type WriteContractsParameters,\n  type WriteContractsReturnType,\n  writeContracts,\n} from '../actions/writeContracts.js'\n\nexport type Eip5792Actions<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n> = {\n  /**\n   * Returns the status of a call batch that was sent via `sendCalls`.\n   *\n   * - Docs: https://viem.sh/experimental/eip5792/getCallsStatus\n   * - JSON-RPC Methods: [`wallet_getCallsStatus`](https://eips.ethereum.org/EIPS/eip-5792)\n   *\n   * @param client - Client to use\n   * @returns Status of the calls. {@link GetCallsStatusReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { eip5792Actions } from 'viem/experimental'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * }).extend(eip5792Actions())\n   *\n   * const { receipts, status } = await client.getCallsStatus({ id: '0xdeadbeef' })\n   */\n  getCallsStatus: (\n    parameters: GetCallsStatusParameters,\n  ) => Promise<GetCallsStatusReturnType>\n  /**\n   * Extract capabilities that a connected wallet supports (e.g. paymasters, session keys, etc).\n   *\n   * - Docs: https://viem.sh/experimental/eip5792/getCapabilities\n   * - JSON-RPC Methods: [`wallet_getCapabilities`](https://eips.ethereum.org/EIPS/eip-5792)\n   *\n   * @param client - Client to use\n   * @returns The wallet's capabilities. {@link GetCapabilitiesReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { eip5792Actions } from 'viem/experimental'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * }).extend(eip5792Actions())\n   *\n   * const capabilities = await client.getCapabilities({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   * })\n   */\n  getCapabilities: (\n    parameters?: GetCapabilitiesParameters,\n  ) => Promise<GetCapabilitiesReturnType>\n  /**\n   * Requests the connected wallet to send a batch of calls.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/sendCalls\n   * - JSON-RPC Methods: [`wallet_sendCalls`](https://eips.ethereum.org/EIPS/eip-5792)\n   *\n   * @param client - Client to use\n   * @returns Transaction identifier. {@link SendCallsReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { eip5792Actions } from 'viem/experimental'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * }).extend(eip5792Actions())\n   *\n   * const id = await client.sendCalls({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   *   calls: [\n   *     {\n   *       data: '0xdeadbeef',\n   *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *     },\n   *     {\n   *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *       value: 69420n,\n   *     },\n   *   ],\n   * })\n   */\n  sendCalls: <\n    const calls extends readonly unknown[],\n    chainOverride extends Chain | undefined = undefined,\n  >(\n    parameters: SendCallsParameters<chain, account, chainOverride, calls>,\n  ) => Promise<SendCallsReturnType>\n  /**\n   * Requests for the wallet to show information about a call batch\n   * that was sent via `sendCalls`.\n   *\n   * - Docs: https://viem.sh/experimental/eip5792/showCallsStatus\n   * - JSON-RPC Methods: [`wallet_showCallsStatus`](https://eips.ethereum.org/EIPS/eip-5792)\n   *\n   * @param client - Client to use\n   * @returns Displays status of the calls in wallet. {@link ShowCallsStatusReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { eip5792Actions } from 'viem/experimental'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * }).extend(eip5792Actions())\n   *\n   * await client.showCallsStatus({ id: '0xdeadbeef' })\n   */\n  showCallsStatus: (\n    parameters: ShowCallsStatusParameters,\n  ) => Promise<ShowCallsStatusReturnType>\n  /**\n   * Waits for the status & receipts of a call bundle that was sent via `sendCalls`.\n   *\n   * - Docs: https://viem.sh/experimental/eip5792/waitForCallsStatus\n   * - JSON-RPC Methods: [`wallet_getCallsStatus`](https://eips.ethereum.org/EIPS/eip-5792)\n   *\n   * @param client - Client to use\n   * @param parameters - {@link WaitForCallsStatusParameters}\n   * @returns Status & receipts of the call bundle. {@link WaitForCallsStatusReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { waitForCallsStatus } from 'viem/experimental'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   *\n   * const { receipts, status } = await waitForCallsStatus(client, { id: '0xdeadbeef' })\n   */\n  waitForCallsStatus: (\n    parameters: WaitForCallsStatusParameters,\n  ) => Promise<WaitForCallsStatusReturnType>\n  /**\n   * Requests for the wallet to sign and broadcast a batch of write contract calls (transactions) to the network.\n   *\n   * - Docs: https://viem.sh/experimental/eip5792/writeContracts\n   *\n   * @param client - Client to use\n   * @param parameters - {@link WriteContractsParameters}\n   * @returns Unique identifier for the call batch. {@link WriteContractsReturnType}\n   *\n   * @example\n   * import { createPublicClient, http, parseAbi } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { writeContracts } from 'viem/experimental'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const abi = parseAbi([\n   *   'function approve(address, uint256) returns (bool)',\n   *   'function transferFrom(address, address, uint256) returns (bool)',\n   * ])\n   * const id = await client.writeContracts({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   *   contracts: [\n   *     {\n   *       address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n   *       abi,\n   *       functionName: 'approve',\n   *       args: ['0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC', 100n],\n   *     },\n   *     {\n   *       address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n   *       abi,\n   *       functionName: 'transferFrom',\n   *       args: [\n   *         '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',\n   *         '0x0000000000000000000000000000000000000000',\n   *         100n\n   *       ],\n   *     },\n   *   ],\n   * })\n   */\n  writeContracts: <\n    const contracts extends readonly unknown[],\n    chainOverride extends Chain | undefined = undefined,\n  >(\n    parameters: WriteContractsParameters<\n      contracts,\n      chain,\n      account,\n      chainOverride\n    >,\n  ) => Promise<WriteContractsReturnType>\n}\n\n/**\n * A suite of EIP-5792 Wallet Actions.\n *\n * - Docs: https://viem.sh/experimental\n *\n * @example\n * import { createPublicClient, createWalletClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { eip5792Actions } from 'viem/experimental'\n *\n * const walletClient = createWalletClient({\n *   chain: mainnet,\n *   transport: http(),\n * }).extend(eip5792Actions())\n *\n * const hash = await walletClient.sendCalls({...})\n */\nexport function eip5792Actions() {\n  return <\n    transport extends Transport,\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  >(\n    client: Client<transport, chain, account>,\n  ): Eip5792Actions<chain, account> => {\n    return {\n      getCallsStatus: (parameters) => getCallsStatus(client, parameters),\n      getCapabilities: ((parameters: any) =>\n        getCapabilities(client as any, parameters)) as any,\n      sendCalls: (parameters) => sendCalls(client, parameters),\n      showCallsStatus: (parameters) => showCallsStatus(client, parameters),\n      waitForCallsStatus: (parameters) =>\n        waitForCallsStatus(client, parameters),\n      writeContracts: (parameters) => writeContracts(client, parameters),\n    }\n  }\n}\n", "import type { Address } from 'abitype'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { Account } from '../../../types/account.js'\nimport type { WalletGrantPermissionsReturnType } from '../../../types/eip1193.js'\nimport type { Hex } from '../../../types/misc.js'\nimport type { OneOf } from '../../../types/utils.js'\nimport { numberToHex, parseAccount } from '../../../utils/index.js'\nimport type { Permission } from '../types/permission.js'\nimport type { Signer } from '../types/signer.js'\n\nexport type GrantPermissionsParameters = {\n  /** Timestamp (in seconds) that specifies the time by which this session MUST expire. */\n  expiry: number\n  /** Set of permissions to grant to the user. */\n  permissions: readonly Permission[]\n} & OneOf<\n  | {\n      /** Signer to assign the permissions to. */\n      signer?: Signer | undefined\n    }\n  | {\n      /** Account to assign the permissions to. */\n      account?: Address | Account | undefined\n    }\n>\n\nexport type GrantPermissionsReturnType = {\n  /** Timestamp (in seconds) that specifies the time by which this session MUST expire. */\n  expiry: number\n  /** ERC-4337 Factory to deploy smart contract account. */\n  factory?: Hex | undefined\n  /** Calldata to use when calling the ERC-4337 Factory. */\n  factoryData?: string | undefined\n  /** Set of granted permissions. */\n  grantedPermissions: readonly Permission[]\n  /** Permissions identifier. */\n  permissionsContext: string\n  /** Signer attached to the permissions. */\n  signerData?:\n    | {\n        userOpBuilder?: Hex | undefined\n        submitToAddress?: Hex | undefined\n      }\n    | undefined\n}\n\n/**\n * Request permissions from a wallet to perform actions on behalf of a user.\n *\n * - Docs: https://viem.sh/experimental/erc7715/grantPermissions\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { grantPermissions } from 'viem/experimental'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n *\n * const result = await grantPermissions(client, {\n *   expiry: 1716846083638,\n *   permissions: [\n *     {\n *       type: 'native-token-transfer',\n *       data: {\n *         ticker: 'ETH',\n *       },\n *       policies: [\n *         {\n *           type: 'token-allowance',\n *           data: {\n *             allowance: parseEther('1'),\n *           },\n *         }\n *       ],\n *       required: true,\n *     },\n *   ],\n * })\n */\nexport async function grantPermissions(\n  client: Client<Transport>,\n  parameters: GrantPermissionsParameters,\n): Promise<GrantPermissionsReturnType> {\n  const { account, expiry, permissions, signer } = parameters\n  const result = await client.request(\n    {\n      method: 'wallet_grantPermissions',\n      params: [\n        formatParameters({ account, expiry, permissions, signer } as any),\n      ],\n    },\n    { retryCount: 0 },\n  )\n  return formatRequest(result) as GrantPermissionsReturnType\n}\n\nfunction formatParameters(parameters: GrantPermissionsParameters) {\n  const { expiry, permissions, signer: signer_ } = parameters\n\n  const account = parameters.account\n    ? parseAccount(parameters.account)\n    : undefined\n\n  const signer = (() => {\n    if (!account && !signer_) return undefined\n\n    // JSON-RPC Account as signer.\n    if (account?.type === 'json-rpc')\n      return {\n        type: 'wallet',\n      }\n\n    // Local Account as signer.\n    if (account?.type === 'local')\n      return {\n        type: 'account',\n        data: {\n          id: account.address,\n        },\n      }\n\n    // ERC-7715 Signer as signer.\n    return signer_\n  })()\n\n  return {\n    expiry,\n    permissions: permissions.map((permission) => ({\n      ...permission,\n      policies: permission.policies.map((policy) => {\n        const data = (() => {\n          if (policy.type === 'token-allowance')\n            return {\n              allowance: numberToHex(policy.data.allowance),\n            }\n          if (policy.type === 'gas-limit')\n            return {\n              limit: numberToHex(policy.data.limit),\n            }\n          return policy.data\n        })()\n\n        return {\n          data,\n          type:\n            typeof policy.type === 'string' ? policy.type : policy.type.custom,\n        }\n      }),\n      required: permission.required ?? false,\n      type:\n        typeof permission.type === 'string'\n          ? permission.type\n          : permission.type.custom,\n    })),\n    ...(signer ? { signer } : {}),\n  }\n}\n\nfunction formatRequest(result: WalletGrantPermissionsReturnType) {\n  return {\n    expiry: result.expiry,\n    ...(result.factory ? { factory: result.factory } : {}),\n    ...(result.factoryData ? { factoryData: result.factoryData } : {}),\n    grantedPermissions: result.grantedPermissions.map((permission) => ({\n      ...permission,\n      policies: permission.policies.map((policy) => {\n        const data = (() => {\n          if (policy.type === 'token-allowance')\n            return {\n              allowance: BigInt((policy.data as any).allowance),\n            }\n          if (policy.type === 'gas-limit')\n            return {\n              limit: BigInt((policy.data as any).limit),\n            }\n          return policy.data\n        })()\n\n        return {\n          data,\n          type: policy.type,\n        }\n      }),\n    })),\n    permissionsContext: result.permissionsContext,\n    ...(result.signerData ? { signerData: result.signerData } : {}),\n  }\n}\n", "import type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { Account } from '../../../types/account.js'\nimport type { Chain } from '../../../types/chain.js'\nimport {\n  type GrantPermissionsParameters,\n  type GrantPermissionsReturnType,\n  grantPermissions,\n} from '../actions/grantPermissions.js'\n\nexport type Erc7715Actions = {\n  /**\n   * Request permissions from a wallet to perform actions on behalf of a user.\n   *\n   * - Docs: https://viem.sh/experimental/erc7715/grantPermissions\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { erc7715Actions } from 'viem/experimental'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * }).extend(erc7715Actions())\n   *\n   * const result = await client.grantPermissions({\n   *   expiry: 1716846083638,\n   *   permissions: [\n   *     {\n   *       type: 'contract-call',\n   *       data: {\n   *         address: '0x0000000000000000000000000000000000000000',\n   *       },\n   *     },\n   *     {\n   *       type: 'native-token-limit',\n   *       data: {\n   *         amount: 69420n,\n   *       },\n   *       required: true,\n   *     },\n   *   ],\n   * })\n   */\n  grantPermissions: (\n    parameters: GrantPermissionsParameters,\n  ) => Promise<GrantPermissionsReturnType>\n}\n\n/**\n * A suite of ERC-7715 Wallet Actions.\n *\n * - Docs: https://viem.sh/experimental\n *\n * @example\n * import { createPublicClient, createWalletClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { erc7715Actions } from 'viem/experimental'\n *\n * const walletClient = createWalletClient({\n *   chain: mainnet,\n *   transport: http(),\n * }).extend(erc7715Actions())\n *\n * const result = await walletClient.grantPermissions({...})\n */\nexport function erc7715Actions() {\n  return <\n    transport extends Transport,\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  >(\n    client: Client<transport, chain, account>,\n  ): Erc7715Actions => {\n    return {\n      grantPermissions: (parameters) => grantPermissions(client, parameters),\n    }\n  }\n}\n", "import type { Address, TypedData } from 'abitype'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { Account } from '../../../types/account.js'\nimport type { Chain } from '../../../types/chain.js'\nimport {\n  type SignMessageParameters,\n  type SignMessageReturnType,\n  signMessage,\n} from '../actions/signMessage.js'\nimport {\n  type SignTypedDataParameters,\n  type SignTypedDataReturnType,\n  signTypedData,\n} from '../actions/signTypedData.js'\n\nexport type Erc7739Actions<\n  account extends Account | undefined = Account | undefined,\n  verifier extends Address | undefined = Address | undefined,\n> = {\n  /**\n   * Signs a [EIP-191](https://eips.ethereum.org/EIPS/eip-191) personal sign message via [ERC-7739 `PersonalSign` format](https://eips.ethereum.org/EIPS/eip-7702).\n   *\n   * This Action is suitable to sign messages for Smart Accounts that implement (or conform to) [ERC-7739](https://eips.ethereum.org/EIPS/eip-7702) (e.g. Solady's [ERC1271.sol](https://github.com/Vectorized/solady/blob/main/src/accounts/ERC1271.sol)).\n   *\n   * - Docs: https://viem.sh/experimental/erc7739/signMessage\n   *\n   * With the calculated signature, you can:\n   * - use [`verifyMessage`](https://viem.sh/docs/utilities/verifyMessage) to verify the signature,\n   *\n   * @param client - Client to use\n   * @param parameters - {@link SignMessageParameters}\n   * @returns The signed message. {@link SignMessageReturnType}\n   *\n   * @example\n   * ```ts\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { erc7739Actions } from 'viem/experimental/erc7739'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * }).extend(erc7739Actions())\n   *\n   * const signature = await client.signMessage({\n   *   account: '0xE8Df82fA4E10e6A12a9Dab552bceA2acd26De9bb',\n   *   message: 'hello world',\n   *   verifier: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   * })\n   * ```\n   *\n   * @example Account & Signer Hoisting\n   * ```ts\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { erc7739Actions } from 'viem/experimental/erc7739'\n   *\n   * const client = createWalletClient({\n   *   account: '0xE8Df82fA4E10e6A12a9Dab552bceA2acd26De9bb',\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * }).extend(erc7739Actions({ verifier: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e' }))\n   *\n   * const signature = await client.signMessage({\n   *   message: 'hello world',\n   * })\n   * ```\n   */\n  signMessage: <accountOverride extends Account | undefined = undefined>(\n    parameters: SignMessageParameters<account, accountOverride, verifier>,\n  ) => Promise<SignMessageReturnType>\n  /**\n   * Signs an [EIP-712](https://eips.ethereum.org/EIPS/eip-712) typed data message via [ERC-7739 `TypedDataSign` format](https://eips.ethereum.org/EIPS/eip-7702).\n   *\n   * This Action is suitable to sign messages for Smart Accounts that implement (or conform to) [ERC-7739](https://eips.ethereum.org/EIPS/eip-7702) (e.g. Solady's [ERC1271.sol](https://github.com/Vectorized/solady/blob/main/src/accounts/ERC1271.sol)).\n   *\n   * - Docs: https://viem.sh/experimental/erc7739/signTypedData\n   *\n   * @param client - Client to use\n   * @param parameters - {@link SignTypedDataParameters}\n   * @returns The signed data. {@link SignTypedDataReturnType}\n   *\n   * @example\n   * ```ts\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { erc7739Actions } from 'viem/experimental/erc7739'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * }).extend(erc7739Actions())\n   *\n   * const signature = await client.signTypedData({\n   *   account: '0xE8Df82fA4E10e6A12a9Dab552bceA2acd26De9bb',\n   *   domain: {\n   *     name: 'Ether Mail',\n   *     version: '1',\n   *     chainId: 1,\n   *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n   *   },\n   *   types: {\n   *     Person: [\n   *       { name: 'name', type: 'string' },\n   *       { name: 'wallet', type: 'address' },\n   *     ],\n   *     Mail: [\n   *       { name: 'from', type: 'Person' },\n   *       { name: 'to', type: 'Person' },\n   *       { name: 'contents', type: 'string' },\n   *     ],\n   *   },\n   *   primaryType: 'Mail',\n   *   message: {\n   *     from: {\n   *       name: 'Cow',\n   *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n   *     },\n   *     to: {\n   *       name: 'Bob',\n   *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n   *     },\n   *     contents: 'Hello, Bob!',\n   *   },\n   *   verifier: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   * })\n   * ```\n   *\n   * @example Account & Signer Hoisting\n   * ```ts\n   * import { createWalletClient, http } from 'viem'\n   * import { privateKeyToAccount } from 'viem/accounts'\n   * import { mainnet } from 'viem/chains'\n   * import { erc7739Actions } from 'viem/experimental/erc7739'\n   *\n   * const client = createWalletClient({\n   *   account: '0xE8Df82fA4E10e6A12a9Dab552bceA2acd26De9bb',\n   *   chain: mainnet,\n   *   transport: http(),\n   * }).extend(erc7739Actions({ verifier: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e' }))\n   *\n   * const signature = await client.signTypedData({\n   *   domain: {\n   *     name: 'Ether Mail',\n   *     version: '1',\n   *     chainId: 1,\n   *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n   *   },\n   *   types: {\n   *     Person: [\n   *       { name: 'name', type: 'string' },\n   *       { name: 'wallet', type: 'address' },\n   *     ],\n   *     Mail: [\n   *       { name: 'from', type: 'Person' },\n   *       { name: 'to', type: 'Person' },\n   *       { name: 'contents', type: 'string' },\n   *     ],\n   *   },\n   *   primaryType: 'Mail',\n   *   message: {\n   *     from: {\n   *       name: 'Cow',\n   *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n   *     },\n   *     to: {\n   *       name: 'Bob',\n   *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n   *     },\n   *     contents: 'Hello, Bob!',\n   *   },\n   * })\n   * ```\n   */\n  signTypedData: <\n    const typedData extends TypedData | Record<string, unknown>,\n    primaryType extends keyof typedData | 'EIP712Domain',\n    accountOverride extends Account | undefined = undefined,\n  >(\n    parameters: SignTypedDataParameters<\n      typedData,\n      primaryType,\n      account,\n      accountOverride\n    >,\n  ) => Promise<SignTypedDataReturnType>\n}\n\nexport type Erc7739ActionsParameters<\n  verifier extends Account | Address | undefined =\n    | Account\n    | Address\n    | undefined,\n> = {\n  verifier?: verifier | undefined\n}\n\n/**\n * A suite of Actions based on [Solady contracts](https://github.com/Vectorized/solady).\n *\n * @example\n * import { createPublicClient, createWalletClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { erc7739Actions } from 'viem/experimental'\n *\n * const walletClient = createWalletClient({\n *   chain: mainnet,\n *   transport: http(),\n * }).extend(erc7739Actions())\n *\n * const result = await walletClient.signMessage({...})\n */\nexport function erc7739Actions<\n  verifier extends Address | undefined = undefined,\n>(parameters: Erc7739ActionsParameters<verifier> = {}) {\n  const { verifier } = parameters\n  return <\n    transport extends Transport,\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  >(\n    client: Client<transport, chain, account>,\n  ): Erc7739Actions<account, verifier> => {\n    return {\n      signMessage: (parameters) =>\n        signMessage(client, { verifier, ...parameters }),\n      signTypedData: (parameters) =>\n        signTypedData(client, { verifier, ...(parameters as any) }),\n    }\n  }\n}\n", "import type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { Account } from '../../../types/account.js'\nimport type { Chain } from '../../../types/chain.js'\nimport {\n  type GetAssetsParameters,\n  type GetAssetsReturnType,\n  getAssets,\n} from '../actions/getAssets.js'\n\nexport type Erc7811Actions<\n  account extends Account | undefined = Account | undefined,\n> = {\n  /**\n   * Requests to get assets for an account from a wallet.\n   *\n   * - Docs: https://viem.sh/experimental/erc7811/getAssets\n   *\n   * @param client - Client to use\n   * @param parameters - {@link GetAssetsParameters}\n   * @returns List of assets for the given account {@link GetAssetsReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { erc7811Actions } from 'viem/experimental/erc7811'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * }).extend(erc7811Actions())\n   *\n   * const response = await client.getAssets({\n   *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n   * })\n   */\n  getAssets: <\n    aggregate extends\n      | boolean\n      | ((asset: getAssets.Asset) => string)\n      | undefined = undefined,\n  >(\n    ...[parameters]: account extends Account\n      ? [GetAssetsParameters<aggregate, account>] | []\n      : [GetAssetsParameters<aggregate, account>]\n  ) => Promise<GetAssetsReturnType<aggregate>>\n}\n\n/**\n * A suite of ERC-7811 Wallet Actions.\n *\n * @example\n * import { createPublicClient, createWalletClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { erc7811Actions } from 'viem/experimental/erc7811'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: http(),\n * }).extend(erc7811Actions())\n *\n * const response = await client.getAssets({\n *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n * })\n */\nexport function erc7811Actions() {\n  return <\n    transport extends Transport,\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account | undefined = Account | undefined,\n  >(\n    client: Client<transport, chain, account>,\n  ): Erc7811Actions<account> => {\n    return {\n      // @ts-expect-error\n      getAssets: (...[parameters]) => getAssets(client, parameters),\n    }\n  }\n}\n", "import type { Address } from 'abitype'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport { ethAddress } from '../../../constants/address.js'\nimport { AccountNotFoundError } from '../../../errors/account.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Account, GetAccountParameter } from '../../../types/account.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type {\n  WalletGetAssetsParameters,\n  WalletGetAssetsReturnType,\n} from '../../../types/eip1193.js'\nimport type { Hex } from '../../../types/misc.js'\nimport type { OneOf, Prettify } from '../../../types/utils.js'\nimport {\n  type HexToBigIntErrorType,\n  hexToBigInt,\n} from '../../../utils/encoding/fromHex.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../../utils/encoding/toHex.js'\n\nexport type GetAssetsParameters<\n  aggregate extends\n    | boolean\n    | ((asset: getAssets.Asset) => string)\n    | undefined = undefined,\n  account extends Account | undefined = Account | undefined,\n> = GetAccountParameter<account> & {\n  /**\n   * Whether or not to aggregate assets across multiple chains,\n   * and assign them to a '0' key.\n   * @default true\n   */\n  aggregate?:\n    | aggregate\n    | boolean\n    | ((asset: getAssets.Asset) => string)\n    | undefined\n  /** Filter by assets. */\n  assets?:\n    | {\n        [chainId: number]: readonly (\n          | {\n              address: 'native'\n              type: 'native'\n            }\n          | {\n              address: Address\n              type: getAssets.AssetType\n            }\n        )[]\n      }\n    | undefined\n  /** Filter by asset types. */\n  assetTypes?: readonly getAssets.AssetType[] | undefined\n  /** Filter by chain IDs. */\n  chainIds?: readonly number[] | undefined\n}\n\nexport type GetAssetsReturnType<\n  aggregate extends\n    | boolean\n    | ((asset: getAssets.Asset) => string)\n    | undefined = undefined,\n> = {\n  [chainId: number]: readonly getAssets.Asset<false>[]\n} & (aggregate extends false ? {} : { 0: readonly getAssets.Asset<true>[] })\n\nexport type GetAssetsErrorType =\n  | HexToBigIntErrorType\n  | NumberToHexErrorType\n  | ParseAccountErrorType\n  | ErrorType\n\n/**\n * Retrieves assets for a given account from the target Wallet.\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getAssets } from 'viem/experimental'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n *\n * const result = await getAssets(client, {\n *   account: '0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef',\n * })\n *\n * @param client - Client to use to make the request.\n * @param parameters - Parameters.\n * @returns Assets for the given account.\n */\nexport async function getAssets<\n  chain extends Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  aggregate extends\n    | boolean\n    | ((asset: getAssets.Asset) => string)\n    | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  ...[parameters]: account extends Account\n    ? [GetAssetsParameters<aggregate, account>] | []\n    : [GetAssetsParameters<aggregate, account>]\n): Promise<Prettify<GetAssetsReturnType<aggregate>>> {\n  const { account = client.account, aggregate = true } = parameters ?? {}\n\n  const result = await client.request({\n    method: 'wallet_getAssets',\n    params: [formatRequest({ ...parameters, account })],\n  })\n  const response = formatResponse(result)\n\n  const aggregated = (() => {\n    if (!aggregate) return undefined\n    const aggregated = {} as Record<string, getAssets.Asset<boolean>>\n    for (const [chainId, assets] of Object.entries(response)) {\n      if (chainId === '0') continue\n      const seen = new Set<string>()\n      for (const asset of assets) {\n        const key =\n          typeof aggregate === 'function'\n            ? aggregate(asset)\n            : (asset.address ?? ethAddress)\n        const item = (aggregated[key] ?? {}) as getAssets.Asset<true>\n        if (seen.has(key)) continue\n        seen.add(key)\n        aggregated[key] = {\n          ...asset,\n          balance: asset.balance + (item?.balance ?? 0n),\n          chainIds: [...(item?.chainIds ?? []), Number(chainId)],\n        }\n      }\n    }\n    return Object.values(aggregated)\n  })()\n\n  if (aggregated) return { 0: aggregated, ...response } as never\n  return response as never\n}\n\nexport declare namespace getAssets {\n  type Asset<chainIds extends boolean = false> = OneOf<\n    CustomAsset | Erc20Asset | Erc721Asset | NativeAsset\n  > &\n    (chainIds extends true ? { chainIds: readonly number[] } : {})\n\n  type AssetType = 'native' | 'erc20' | 'erc721' | (string & {})\n\n  type CustomAsset = {\n    address: Address\n    balance: bigint\n    metadata: {\n      [key: string]: unknown\n    }\n    type: { custom: string }\n  }\n\n  type Erc20Asset = {\n    address: Address\n    balance: bigint\n    metadata: {\n      name: string\n      symbol: string\n      decimals: number\n    }\n    type: 'erc20'\n  }\n\n  type Erc721Asset = {\n    address: Address\n    balance: bigint\n    metadata: {\n      name: string\n      symbol: string\n      tokenId: bigint\n      tokenUri?: string | undefined\n    }\n    type: 'erc721'\n  }\n\n  type NativeAsset = {\n    balance: bigint\n    type: 'native'\n  }\n}\n\n/** @internal */\nfunction formatRequest(\n  parameters: GetAssetsParameters<undefined, Account> | undefined = {},\n): WalletGetAssetsParameters {\n  const { account: account_, assets, assetTypes, chainIds } = parameters\n\n  if (typeof account_ === 'undefined')\n    throw new AccountNotFoundError({\n      docsPath: '/experimental/erc7811/getAssets',\n    })\n  const account = parseAccount(account_)\n\n  return {\n    account: account.address,\n    assetFilter: assets,\n    assetTypeFilter: assetTypes,\n    chainFilter: chainIds?.map((chainId) => numberToHex(chainId)),\n  }\n}\n\n/** @internal */\nfunction formatResponse(\n  response: WalletGetAssetsReturnType,\n): GetAssetsReturnType<false> {\n  return Object.fromEntries(\n    Object.entries(response).map(([chainId, assets]) => [\n      Number(chainId),\n      assets.map((asset) => {\n        const balance = hexToBigInt(asset.balance)\n        const metadata = asset.metadata as getAssets.Asset['metadata']\n        const type = (() => {\n          if (asset.type === 'native') return 'native'\n          if (asset.type === 'erc20') return 'erc20'\n          if (asset.type === 'erc721') return 'erc721'\n          return { custom: asset.type }\n        })()\n        const address = type === 'native' ? undefined : asset.address\n\n        return {\n          balance,\n          type,\n          ...(address ? { address } : {}),\n          ...(metadata\n            ? {\n                metadata: {\n                  ...metadata,\n                  ...('tokenId' in metadata\n                    ? { tokenId: hexToBigInt(metadata.tokenId as Hex) }\n                    : {}),\n                },\n              }\n            : {}),\n        }\n      }),\n    ]),\n  ) as GetAssetsReturnType<false>\n}\n", "import type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { Chain } from '../../../types/chain.js'\nimport {\n  type ConnectParameters,\n  type ConnectReturnType,\n  connect,\n} from '../actions/connect.js'\nimport { disconnect } from '../actions/disconnect.js'\n\nexport type Erc7846Actions = {\n  /**\n   * Requests to connect to a wallet.\n   *\n   * - Docs: https://viem.sh/experimental/erc7846/connect\n   * - JSON-RPC Methods: [`wallet_connect`](https://github.com/ethereum/ERCs/blob/abd1c9f4eda2d6ad06ade0e3af314637a27d1ee7/ERCS/erc-7846.md)\n   *\n   * @param client - Client to use\n   * @param parameters - {@link ConnectParameters}\n   * @returns List of accounts managed by a wallet {@link ConnectReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { erc7846Actions } from 'viem/experimental/erc7846'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * }).extend(erc7846Actions())\n   *\n   * const response = await client.connect()\n   */\n  connect: (\n    parameters?: ConnectParameters | undefined,\n  ) => Promise<ConnectReturnType>\n  /**\n   * Requests to disconnect connected accounts.\n   *\n   * - Docs: https://viem.sh/experimental/erc7846/disconnect\n   * - JSON-RPC Methods: [`wallet_disconnect`](https://github.com/ethereum/ERCs/blob/abd1c9f4eda2d6ad06ade0e3af314637a27d1ee7/ERCS/erc-7846.md)\n   *\n   * @param client - Client to use\n   * @returns void\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { erc7846Actions } from 'viem/experimental/erc7846'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * }).extend(erc7846Actions())\n   *\n   * await client.disconnect()\n   */\n  disconnect: () => Promise<void>\n}\n\n/**\n * A suite of ERC-7846 Wallet Actions.\n *\n * @example\n * import { createPublicClient, createWalletClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { erc7846Actions } from 'viem/experimental/erc7846'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: http(),\n * }).extend(erc7846Actions())\n *\n * const response = await client.connect()\n */\nexport function erc7846Actions() {\n  return <\n    transport extends Transport,\n    chain extends Chain | undefined = Chain | undefined,\n  >(\n    client: Client<transport, chain>,\n  ): Erc7846Actions => {\n    return {\n      connect: (parameters) => connect(client, parameters),\n      disconnect: () => disconnect(client),\n    }\n  }\n}\n", "import type { Address } from 'abitype'\nimport {\n  type RequestAddressesErrorType,\n  requestAddresses,\n} from '../../../actions/wallet/requestAddresses.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { BaseError } from '../../../errors/base.js'\nimport type { ExtractCapabilities } from '../../../types/capabilities.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type { Prettify } from '../../../types/utils.js'\nimport type { RequestErrorType } from '../../../utils/buildRequest.js'\nimport { numberToHex } from '../../../utils/encoding/toHex.js'\n\nexport type ConnectParameters = Prettify<{\n  capabilities?: ExtractCapabilities<'connect', 'Request'> | undefined\n}>\n\nexport type ConnectReturnType = Prettify<{\n  accounts: readonly {\n    address: Address\n    capabilities?: ExtractCapabilities<'connect', 'ReturnType'> | undefined\n  }[]\n}>\n\nexport type ConnectErrorType = RequestErrorType | RequestAddressesErrorType\n\n/**\n * Requests to connect account(s) with optional capabilities.\n *\n * - Docs: https://viem.sh/experimental/erc7846/connect\n * - JSON-RPC Methods: [`wallet_connect`](https://github.com/ethereum/ERCs/blob/abd1c9f4eda2d6ad06ade0e3af314637a27d1ee7/ERCS/erc-7846.md)\n *\n * @param client - Client to use\n * @param parameters - {@link ConnectParameters}\n * @returns List of accounts managed by a wallet {@link ConnectReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { connect } from 'viem/experimental/erc7846'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const response = await connect(client)\n */\nexport async function connect<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: ConnectParameters = {},\n): Promise<ConnectReturnType> {\n  const capabilities = formatRequestCapabilities(parameters.capabilities)\n\n  const response = await (async () => {\n    try {\n      return await client.request(\n        { method: 'wallet_connect', params: [{ capabilities, version: '1' }] },\n        { dedupe: true, retryCount: 0 },\n      )\n    } catch (e) {\n      const error = e as BaseError\n\n      // If the wallet does not support `wallet_connect`, and has no\n      // capabilities, attempt to use `eth_requestAccounts` instead.\n      if (\n        !parameters.capabilities &&\n        (error.name === 'InvalidInputRpcError' ||\n          error.name === 'InvalidParamsRpcError' ||\n          error.name === 'MethodNotFoundRpcError' ||\n          error.name === 'MethodNotSupportedRpcError' ||\n          error.name === 'UnsupportedProviderMethodError')\n      ) {\n        const addresses = await requestAddresses(client)\n        return {\n          accounts: addresses.map((address) => ({\n            address,\n            capabilities: {},\n          })),\n        }\n      }\n\n      throw error\n    }\n  })()\n\n  return {\n    ...response,\n    accounts: (response.accounts ?? []).map((account) => ({\n      ...account,\n      capabilities: formatResponseCapabilities(account.capabilities),\n    })),\n  }\n}\n\nfunction formatRequestCapabilities(\n  capabilities: ExtractCapabilities<'connect', 'Request'> | undefined,\n) {\n  const {\n    unstable_addSubAccount,\n    unstable_getSubAccounts: getSubAccounts,\n    unstable_signInWithEthereum,\n    ...rest\n  } = capabilities ?? {}\n\n  const addSubAccount = unstable_addSubAccount\n    ? {\n        ...unstable_addSubAccount,\n        account: {\n          ...unstable_addSubAccount.account,\n          ...(unstable_addSubAccount.account.chainId\n            ? {\n                chainId: numberToHex(unstable_addSubAccount.account.chainId),\n              }\n            : {}),\n        },\n      }\n    : undefined\n\n  const { chainId, expirationTime, issuedAt, notBefore } =\n    unstable_signInWithEthereum ?? {}\n  const signInWithEthereum = unstable_signInWithEthereum\n    ? {\n        ...unstable_signInWithEthereum,\n        chainId: numberToHex(chainId!),\n        ...(expirationTime\n          ? {\n              expirationTime: expirationTime.toISOString(),\n            }\n          : {}),\n        ...(issuedAt\n          ? {\n              issuedAt: issuedAt.toISOString(),\n            }\n          : {}),\n        ...(notBefore\n          ? {\n              notBefore: notBefore.toISOString(),\n            }\n          : {}),\n      }\n    : undefined\n\n  return {\n    ...rest,\n    ...(addSubAccount\n      ? {\n          addSubAccount,\n        }\n      : {}),\n    ...(getSubAccounts\n      ? {\n          getSubAccounts,\n        }\n      : {}),\n    ...(signInWithEthereum\n      ? {\n          signInWithEthereum,\n        }\n      : {}),\n  }\n}\n\nfunction formatResponseCapabilities(\n  capabilities: ExtractCapabilities<'connect', 'ReturnType'> | undefined,\n) {\n  return Object.entries(capabilities ?? {}).reduce(\n    (capabilities, [key, value]) => {\n      const k = (() => {\n        if (key === 'signInWithEthereum') return 'unstable_signInWithEthereum'\n        if (key === 'subAccounts') return 'unstable_subAccounts'\n        return key\n      })()\n      capabilities[k] = value\n      return capabilities\n    },\n    {} as Record<string, unknown>,\n  )\n}\n", "import type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type { RequestErrorType } from '../../../utils/buildRequest.js'\n\nexport type DisconnectErrorType = RequestErrorType\n\n/**\n * Requests to disconnect connected accounts.\n *\n * - Docs: https://viem.sh/experimental/erc7846/disconnect\n * - JSON-RPC Methods: [`wallet_disconnect`](https://github.com/ethereum/ERCs/blob/abd1c9f4eda2d6ad06ade0e3af314637a27d1ee7/ERCS/erc-7846.md)\n *\n * @param client - Client to use\n * @returns void\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { disconnect } from 'viem/experimental/erc7846'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n *\n * await disconnect(client)\n */\nexport async function disconnect<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n) {\n  return await client.request(\n    { method: 'wallet_disconnect' },\n    { dedupe: true, retryCount: 0 },\n  )\n}\n", "import type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { Chain } from '../../../types/chain.js'\nimport {\n  type AddSubAccountParameters,\n  type AddSubAccountReturnType,\n  addSubAccount,\n} from '../actions/addSubAccount.js'\n\nexport type Erc7895Actions = {\n  /**\n   * Requests to add a Sub Account.\n   *\n   * - Docs: https://viem.sh/experimental/erc7895/addSubAccount\n   * - JSON-RPC Methods: [`wallet_addSubAccount`](https://github.com/ethereum/ERCs/blob/abd1c9f4eda2d6ad06ade0e3af314637a27d1ee7/ERCS/erc-7895.md)\n   *\n   * @param client - Client to use\n   * @param parameters - {@link AddSubAccountParameters}\n   * @returns Sub Account. {@link AddSubAccountReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { erc7895Actions } from 'viem/experimental'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * }).extend(erc7895Actions())\n   *\n   * const response = await client.addSubAccount({\n   *   keys: [{ key: '0x0000000000000000000000000000000000000000', type: 'address' }],\n   *   type: 'create',\n   * })\n   */\n  addSubAccount: (\n    parameters: AddSubAccountParameters,\n  ) => Promise<AddSubAccountReturnType>\n}\n\n/**\n * A suite of ERC-7895 Wallet Actions.\n *\n * @example\n * import { createPublicClient, createWalletClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { erc7895Actions } from 'viem/experimental'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: http(),\n * }).extend(erc7895Actions())\n *\n * const response = await client.addSubAccount({\n *   keys: [{ key: '0x0000000000000000000000000000000000000000', type: 'address' }],\n *   type: 'create',\n * })\n */\nexport function erc7895Actions() {\n  return <\n    transport extends Transport,\n    chain extends Chain | undefined = Chain | undefined,\n  >(\n    client: Client<transport, chain>,\n  ): Erc7895Actions => {\n    return {\n      addSubAccount: (parameters) => addSubAccount(client, parameters),\n    }\n  }\n}\n", "import type { Address } from 'abitype'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type { Hex } from '../../../types/misc.js'\nimport type { OneOf, Prettify } from '../../../types/utils.js'\nimport type { RequestErrorType } from '../../../utils/buildRequest.js'\nimport { numberToHex } from '../../../utils/index.js'\n\nexport type AddSubAccountParameters = Prettify<\n  OneOf<\n    | {\n        keys?:\n          | readonly {\n              publicKey: Hex\n              type: 'address' | 'p256' | 'webcrypto-p256' | 'webauthn-p256'\n            }[]\n          | undefined\n        type: 'create'\n      }\n    | {\n        address: Address\n        chainId?: number | undefined\n        type: 'deployed'\n      }\n    | {\n        address: Address\n        chainId?: number | undefined\n        factory: Address\n        factoryData: Hex\n        type: 'undeployed'\n      }\n  >\n>\n\nexport type AddSubAccountReturnType = Prettify<{\n  address: Address\n  factory?: Address | undefined\n  factoryData?: Hex | undefined\n}>\n\nexport type AddSubAccountErrorType = RequestErrorType\n\n/**\n * Requests to add a Sub Account.\n *\n * - Docs: https://viem.sh/experimental/erc7895/addSubAccount\n * - JSON-RPC Methods: [`wallet_addSubAccount`](https://github.com/ethereum/ERCs/blob/abd1c9f4eda2d6ad06ade0e3af314637a27d1ee7/ERCS/erc-7895.md)\n *\n * @param client - Client to use\n * @param parameters - {@link AddSubAccountParameters}\n * @returns Sub Account. {@link AddSubAccountReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { addSubAccount } from 'viem/experimental/erc7895'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const response = await addSubAccount(client, {\n *   keys: [{ publicKey: '0x0000000000000000000000000000000000000000', type: 'address' }],\n *   type: 'create',\n * })\n */\nexport async function addSubAccount<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: AddSubAccountParameters,\n): Promise<AddSubAccountReturnType> {\n  return client.request({\n    method: 'wallet_addSubAccount',\n    params: [\n      {\n        account: {\n          ...parameters,\n          ...(parameters.chainId\n            ? { chainId: numberToHex(parameters.chainId) }\n            : {}),\n        } as never,\n        version: '1',\n      },\n    ],\n  })\n}\n"],
  "mappings": "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",
  "names": ["import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "hash", "import_dist", "error", "cause", "error", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "getPaymasterStubData", "getPaymasterData", "parameters", "factory", "fees", "authorization", "getChainId", "paymaster", "import_dist", "import_dist", "import_dist", "hash", "import_dist", "import_dist", "hash", "import_dist", "import_dist", "hash", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "packedUserOp", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "entryPoint06Address", "import_dist", "import_dist", "import_dist", "import_dist", "getSignPayload", "import_dist", "getSignPayload", "keccak256", "concat", "factory", "factoryData", "paymaster", "paymasterVerificationGasLimit", "paymasterPostOpGasLimit", "paymasterData", "toTypedData", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist"]
}
